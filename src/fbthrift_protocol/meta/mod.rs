// @generated by Thrift for src/interface/meta.thrift
// This file is probably not the place you want to edit!

#![allow(bare_trait_objects)]
#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals, clippy::all)]

pub use self::errors::*;
pub use self::types::*;

pub mod types;

pub mod services {
    pub mod meta_service {
        #[derive(Clone, Debug)]
        pub enum CreateSpaceExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::ExecResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::CreateSpaceError> for CreateSpaceExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::CreateSpaceError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::CreateSpaceError::ApplicationException(aexn) => CreateSpaceExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::CreateSpaceError::ThriftError(err) => CreateSpaceExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for CreateSpaceExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for CreateSpaceExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for CreateSpaceExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for CreateSpaceExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for CreateSpaceExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("CreateSpace");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for CreateSpaceExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "CreateSpaceExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "CreateSpaceExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DropSpaceExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::ExecResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::DropSpaceError> for DropSpaceExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::DropSpaceError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::DropSpaceError::ApplicationException(aexn) => DropSpaceExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::DropSpaceError::ThriftError(err) => DropSpaceExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for DropSpaceExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for DropSpaceExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for DropSpaceExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for DropSpaceExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for DropSpaceExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("DropSpace");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for DropSpaceExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DropSpaceExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DropSpaceExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ClearSpaceExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::ExecResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::ClearSpaceError> for ClearSpaceExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::ClearSpaceError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::ClearSpaceError::ApplicationException(aexn) => ClearSpaceExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::ClearSpaceError::ThriftError(err) => ClearSpaceExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for ClearSpaceExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for ClearSpaceExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for ClearSpaceExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for ClearSpaceExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for ClearSpaceExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("ClearSpace");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for ClearSpaceExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ClearSpaceExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ClearSpaceExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetSpaceExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::GetSpaceResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::GetSpaceError> for GetSpaceExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::GetSpaceError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::GetSpaceError::ApplicationException(aexn) => GetSpaceExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::GetSpaceError::ThriftError(err) => GetSpaceExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for GetSpaceExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for GetSpaceExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for GetSpaceExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for GetSpaceExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for GetSpaceExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetSpace");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for GetSpaceExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetSpaceExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetSpaceExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListSpacesExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::ListSpacesResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::ListSpacesError> for ListSpacesExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::ListSpacesError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::ListSpacesError::ApplicationException(aexn) => ListSpacesExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::ListSpacesError::ThriftError(err) => ListSpacesExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for ListSpacesExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for ListSpacesExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for ListSpacesExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for ListSpacesExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for ListSpacesExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("ListSpaces");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for ListSpacesExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListSpacesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListSpacesExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum AlterSpaceExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::ExecResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::AlterSpaceError> for AlterSpaceExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::AlterSpaceError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::AlterSpaceError::ApplicationException(aexn) => AlterSpaceExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::AlterSpaceError::ThriftError(err) => AlterSpaceExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for AlterSpaceExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for AlterSpaceExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for AlterSpaceExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for AlterSpaceExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for AlterSpaceExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("AlterSpace");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for AlterSpaceExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "AlterSpaceExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "AlterSpaceExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum CreateSpaceAsExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::ExecResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::CreateSpaceAsError> for CreateSpaceAsExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::CreateSpaceAsError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::CreateSpaceAsError::ApplicationException(aexn) => CreateSpaceAsExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::CreateSpaceAsError::ThriftError(err) => CreateSpaceAsExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for CreateSpaceAsExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for CreateSpaceAsExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for CreateSpaceAsExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for CreateSpaceAsExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for CreateSpaceAsExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("CreateSpaceAs");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for CreateSpaceAsExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "CreateSpaceAsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "CreateSpaceAsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum CreateTagExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::ExecResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::CreateTagError> for CreateTagExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::CreateTagError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::CreateTagError::ApplicationException(aexn) => CreateTagExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::CreateTagError::ThriftError(err) => CreateTagExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for CreateTagExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for CreateTagExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for CreateTagExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for CreateTagExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for CreateTagExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("CreateTag");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for CreateTagExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "CreateTagExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "CreateTagExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum AlterTagExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::ExecResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::AlterTagError> for AlterTagExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::AlterTagError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::AlterTagError::ApplicationException(aexn) => AlterTagExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::AlterTagError::ThriftError(err) => AlterTagExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for AlterTagExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for AlterTagExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for AlterTagExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for AlterTagExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for AlterTagExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("AlterTag");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for AlterTagExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "AlterTagExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "AlterTagExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DropTagExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::ExecResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::DropTagError> for DropTagExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::DropTagError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::DropTagError::ApplicationException(aexn) => DropTagExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::DropTagError::ThriftError(err) => DropTagExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for DropTagExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for DropTagExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for DropTagExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for DropTagExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for DropTagExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("DropTag");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for DropTagExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DropTagExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DropTagExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetTagExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::GetTagResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::GetTagError> for GetTagExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::GetTagError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::GetTagError::ApplicationException(aexn) => GetTagExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::GetTagError::ThriftError(err) => GetTagExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for GetTagExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for GetTagExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for GetTagExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for GetTagExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for GetTagExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetTag");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for GetTagExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetTagExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetTagExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListTagsExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::ListTagsResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::ListTagsError> for ListTagsExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::ListTagsError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::ListTagsError::ApplicationException(aexn) => ListTagsExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::ListTagsError::ThriftError(err) => ListTagsExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for ListTagsExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for ListTagsExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for ListTagsExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for ListTagsExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for ListTagsExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("ListTags");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for ListTagsExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListTagsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListTagsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum CreateEdgeExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::ExecResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::CreateEdgeError> for CreateEdgeExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::CreateEdgeError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::CreateEdgeError::ApplicationException(aexn) => CreateEdgeExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::CreateEdgeError::ThriftError(err) => CreateEdgeExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for CreateEdgeExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for CreateEdgeExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for CreateEdgeExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for CreateEdgeExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for CreateEdgeExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("CreateEdge");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for CreateEdgeExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "CreateEdgeExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "CreateEdgeExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum AlterEdgeExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::ExecResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::AlterEdgeError> for AlterEdgeExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::AlterEdgeError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::AlterEdgeError::ApplicationException(aexn) => AlterEdgeExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::AlterEdgeError::ThriftError(err) => AlterEdgeExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for AlterEdgeExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for AlterEdgeExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for AlterEdgeExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for AlterEdgeExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for AlterEdgeExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("AlterEdge");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for AlterEdgeExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "AlterEdgeExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "AlterEdgeExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DropEdgeExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::ExecResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::DropEdgeError> for DropEdgeExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::DropEdgeError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::DropEdgeError::ApplicationException(aexn) => DropEdgeExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::DropEdgeError::ThriftError(err) => DropEdgeExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for DropEdgeExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for DropEdgeExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for DropEdgeExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for DropEdgeExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for DropEdgeExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("DropEdge");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for DropEdgeExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DropEdgeExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DropEdgeExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetEdgeExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::GetEdgeResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::GetEdgeError> for GetEdgeExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::GetEdgeError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::GetEdgeError::ApplicationException(aexn) => GetEdgeExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::GetEdgeError::ThriftError(err) => GetEdgeExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for GetEdgeExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for GetEdgeExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for GetEdgeExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for GetEdgeExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for GetEdgeExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetEdge");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for GetEdgeExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetEdgeExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetEdgeExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListEdgesExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::ListEdgesResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::ListEdgesError> for ListEdgesExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::ListEdgesError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::ListEdgesError::ApplicationException(aexn) => ListEdgesExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::ListEdgesError::ThriftError(err) => ListEdgesExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for ListEdgesExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for ListEdgesExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for ListEdgesExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for ListEdgesExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for ListEdgesExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("ListEdges");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for ListEdgesExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListEdgesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListEdgesExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum AddHostsExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::ExecResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::AddHostsError> for AddHostsExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::AddHostsError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::AddHostsError::ApplicationException(aexn) => AddHostsExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::AddHostsError::ThriftError(err) => AddHostsExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for AddHostsExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for AddHostsExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for AddHostsExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for AddHostsExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for AddHostsExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("AddHosts");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for AddHostsExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "AddHostsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "AddHostsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum AddHostsIntoZoneExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::ExecResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::AddHostsIntoZoneError> for AddHostsIntoZoneExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::AddHostsIntoZoneError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::AddHostsIntoZoneError::ApplicationException(aexn) => AddHostsIntoZoneExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::AddHostsIntoZoneError::ThriftError(err) => AddHostsIntoZoneExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for AddHostsIntoZoneExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for AddHostsIntoZoneExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for AddHostsIntoZoneExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for AddHostsIntoZoneExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for AddHostsIntoZoneExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("AddHostsIntoZone");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for AddHostsIntoZoneExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "AddHostsIntoZoneExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "AddHostsIntoZoneExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DropHostsExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::ExecResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::DropHostsError> for DropHostsExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::DropHostsError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::DropHostsError::ApplicationException(aexn) => DropHostsExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::DropHostsError::ThriftError(err) => DropHostsExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for DropHostsExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for DropHostsExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for DropHostsExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for DropHostsExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for DropHostsExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("DropHosts");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for DropHostsExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DropHostsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DropHostsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListHostsExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::ListHostsResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::ListHostsError> for ListHostsExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::ListHostsError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::ListHostsError::ApplicationException(aexn) => ListHostsExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::ListHostsError::ThriftError(err) => ListHostsExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for ListHostsExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for ListHostsExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for ListHostsExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for ListHostsExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for ListHostsExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("ListHosts");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for ListHostsExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListHostsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListHostsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetPartsAllocExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::GetPartsAllocResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::GetPartsAllocError> for GetPartsAllocExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::GetPartsAllocError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::GetPartsAllocError::ApplicationException(aexn) => GetPartsAllocExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::GetPartsAllocError::ThriftError(err) => GetPartsAllocExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for GetPartsAllocExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for GetPartsAllocExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for GetPartsAllocExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for GetPartsAllocExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for GetPartsAllocExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetPartsAlloc");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for GetPartsAllocExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetPartsAllocExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetPartsAllocExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListPartsExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::ListPartsResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::ListPartsError> for ListPartsExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::ListPartsError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::ListPartsError::ApplicationException(aexn) => ListPartsExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::ListPartsError::ThriftError(err) => ListPartsExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for ListPartsExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for ListPartsExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for ListPartsExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for ListPartsExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for ListPartsExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("ListParts");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for ListPartsExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListPartsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListPartsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetWorkerIdExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::GetWorkerIdResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::GetWorkerIdError> for GetWorkerIdExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::GetWorkerIdError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::GetWorkerIdError::ApplicationException(aexn) => GetWorkerIdExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::GetWorkerIdError::ThriftError(err) => GetWorkerIdExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for GetWorkerIdExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for GetWorkerIdExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for GetWorkerIdExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for GetWorkerIdExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for GetWorkerIdExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetWorkerId");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for GetWorkerIdExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetWorkerIdExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetWorkerIdExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum CreateTagIndexExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::ExecResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::CreateTagIndexError> for CreateTagIndexExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::CreateTagIndexError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::CreateTagIndexError::ApplicationException(aexn) => CreateTagIndexExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::CreateTagIndexError::ThriftError(err) => CreateTagIndexExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for CreateTagIndexExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for CreateTagIndexExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for CreateTagIndexExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for CreateTagIndexExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for CreateTagIndexExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("CreateTagIndex");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for CreateTagIndexExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "CreateTagIndexExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "CreateTagIndexExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DropTagIndexExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::ExecResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::DropTagIndexError> for DropTagIndexExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::DropTagIndexError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::DropTagIndexError::ApplicationException(aexn) => DropTagIndexExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::DropTagIndexError::ThriftError(err) => DropTagIndexExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for DropTagIndexExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for DropTagIndexExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for DropTagIndexExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for DropTagIndexExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for DropTagIndexExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("DropTagIndex");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for DropTagIndexExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DropTagIndexExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DropTagIndexExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetTagIndexExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::GetTagIndexResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::GetTagIndexError> for GetTagIndexExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::GetTagIndexError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::GetTagIndexError::ApplicationException(aexn) => GetTagIndexExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::GetTagIndexError::ThriftError(err) => GetTagIndexExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for GetTagIndexExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for GetTagIndexExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for GetTagIndexExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for GetTagIndexExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for GetTagIndexExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetTagIndex");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for GetTagIndexExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetTagIndexExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetTagIndexExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListTagIndexesExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::ListTagIndexesResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::ListTagIndexesError> for ListTagIndexesExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::ListTagIndexesError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::ListTagIndexesError::ApplicationException(aexn) => ListTagIndexesExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::ListTagIndexesError::ThriftError(err) => ListTagIndexesExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for ListTagIndexesExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for ListTagIndexesExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for ListTagIndexesExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for ListTagIndexesExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for ListTagIndexesExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("ListTagIndexes");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for ListTagIndexesExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListTagIndexesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListTagIndexesExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum RebuildTagIndexExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::ExecResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::RebuildTagIndexError> for RebuildTagIndexExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::RebuildTagIndexError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::RebuildTagIndexError::ApplicationException(aexn) => RebuildTagIndexExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::RebuildTagIndexError::ThriftError(err) => RebuildTagIndexExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for RebuildTagIndexExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for RebuildTagIndexExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for RebuildTagIndexExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for RebuildTagIndexExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for RebuildTagIndexExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("RebuildTagIndex");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for RebuildTagIndexExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "RebuildTagIndexExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "RebuildTagIndexExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListTagIndexStatusExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::ListIndexStatusResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::ListTagIndexStatusError> for ListTagIndexStatusExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::ListTagIndexStatusError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::ListTagIndexStatusError::ApplicationException(aexn) => ListTagIndexStatusExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::ListTagIndexStatusError::ThriftError(err) => ListTagIndexStatusExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for ListTagIndexStatusExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for ListTagIndexStatusExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for ListTagIndexStatusExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for ListTagIndexStatusExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for ListTagIndexStatusExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("ListTagIndexStatus");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for ListTagIndexStatusExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListTagIndexStatusExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListTagIndexStatusExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum CreateEdgeIndexExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::ExecResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::CreateEdgeIndexError> for CreateEdgeIndexExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::CreateEdgeIndexError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::CreateEdgeIndexError::ApplicationException(aexn) => CreateEdgeIndexExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::CreateEdgeIndexError::ThriftError(err) => CreateEdgeIndexExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for CreateEdgeIndexExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for CreateEdgeIndexExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for CreateEdgeIndexExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for CreateEdgeIndexExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for CreateEdgeIndexExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("CreateEdgeIndex");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for CreateEdgeIndexExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "CreateEdgeIndexExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "CreateEdgeIndexExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DropEdgeIndexExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::ExecResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::DropEdgeIndexError> for DropEdgeIndexExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::DropEdgeIndexError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::DropEdgeIndexError::ApplicationException(aexn) => DropEdgeIndexExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::DropEdgeIndexError::ThriftError(err) => DropEdgeIndexExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for DropEdgeIndexExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for DropEdgeIndexExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for DropEdgeIndexExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for DropEdgeIndexExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for DropEdgeIndexExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("DropEdgeIndex");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for DropEdgeIndexExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DropEdgeIndexExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DropEdgeIndexExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetEdgeIndexExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::GetEdgeIndexResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::GetEdgeIndexError> for GetEdgeIndexExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::GetEdgeIndexError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::GetEdgeIndexError::ApplicationException(aexn) => GetEdgeIndexExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::GetEdgeIndexError::ThriftError(err) => GetEdgeIndexExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for GetEdgeIndexExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for GetEdgeIndexExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for GetEdgeIndexExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for GetEdgeIndexExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for GetEdgeIndexExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetEdgeIndex");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for GetEdgeIndexExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetEdgeIndexExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetEdgeIndexExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListEdgeIndexesExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::ListEdgeIndexesResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::ListEdgeIndexesError> for ListEdgeIndexesExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::ListEdgeIndexesError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::ListEdgeIndexesError::ApplicationException(aexn) => ListEdgeIndexesExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::ListEdgeIndexesError::ThriftError(err) => ListEdgeIndexesExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for ListEdgeIndexesExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for ListEdgeIndexesExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for ListEdgeIndexesExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for ListEdgeIndexesExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for ListEdgeIndexesExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("ListEdgeIndexes");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for ListEdgeIndexesExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListEdgeIndexesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListEdgeIndexesExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum RebuildEdgeIndexExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::ExecResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::RebuildEdgeIndexError> for RebuildEdgeIndexExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::RebuildEdgeIndexError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::RebuildEdgeIndexError::ApplicationException(aexn) => RebuildEdgeIndexExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::RebuildEdgeIndexError::ThriftError(err) => RebuildEdgeIndexExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for RebuildEdgeIndexExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for RebuildEdgeIndexExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for RebuildEdgeIndexExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for RebuildEdgeIndexExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for RebuildEdgeIndexExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("RebuildEdgeIndex");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for RebuildEdgeIndexExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "RebuildEdgeIndexExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "RebuildEdgeIndexExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListEdgeIndexStatusExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::ListIndexStatusResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::ListEdgeIndexStatusError> for ListEdgeIndexStatusExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::ListEdgeIndexStatusError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::ListEdgeIndexStatusError::ApplicationException(aexn) => ListEdgeIndexStatusExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::ListEdgeIndexStatusError::ThriftError(err) => ListEdgeIndexStatusExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for ListEdgeIndexStatusExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for ListEdgeIndexStatusExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for ListEdgeIndexStatusExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for ListEdgeIndexStatusExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for ListEdgeIndexStatusExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("ListEdgeIndexStatus");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for ListEdgeIndexStatusExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListEdgeIndexStatusExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListEdgeIndexStatusExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum CreateUserExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::ExecResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::CreateUserError> for CreateUserExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::CreateUserError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::CreateUserError::ApplicationException(aexn) => CreateUserExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::CreateUserError::ThriftError(err) => CreateUserExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for CreateUserExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for CreateUserExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for CreateUserExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for CreateUserExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for CreateUserExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("CreateUser");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for CreateUserExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "CreateUserExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "CreateUserExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DropUserExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::ExecResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::DropUserError> for DropUserExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::DropUserError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::DropUserError::ApplicationException(aexn) => DropUserExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::DropUserError::ThriftError(err) => DropUserExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for DropUserExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for DropUserExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for DropUserExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for DropUserExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for DropUserExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("DropUser");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for DropUserExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DropUserExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DropUserExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum AlterUserExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::ExecResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::AlterUserError> for AlterUserExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::AlterUserError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::AlterUserError::ApplicationException(aexn) => AlterUserExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::AlterUserError::ThriftError(err) => AlterUserExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for AlterUserExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for AlterUserExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for AlterUserExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for AlterUserExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for AlterUserExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("AlterUser");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for AlterUserExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "AlterUserExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "AlterUserExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GrantRoleExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::ExecResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::GrantRoleError> for GrantRoleExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::GrantRoleError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::GrantRoleError::ApplicationException(aexn) => GrantRoleExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::GrantRoleError::ThriftError(err) => GrantRoleExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for GrantRoleExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for GrantRoleExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for GrantRoleExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for GrantRoleExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for GrantRoleExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GrantRole");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for GrantRoleExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GrantRoleExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GrantRoleExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum RevokeRoleExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::ExecResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::RevokeRoleError> for RevokeRoleExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::RevokeRoleError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::RevokeRoleError::ApplicationException(aexn) => RevokeRoleExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::RevokeRoleError::ThriftError(err) => RevokeRoleExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for RevokeRoleExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for RevokeRoleExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for RevokeRoleExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for RevokeRoleExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for RevokeRoleExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("RevokeRole");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for RevokeRoleExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "RevokeRoleExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "RevokeRoleExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListUsersExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::ListUsersResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::ListUsersError> for ListUsersExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::ListUsersError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::ListUsersError::ApplicationException(aexn) => ListUsersExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::ListUsersError::ThriftError(err) => ListUsersExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for ListUsersExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for ListUsersExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for ListUsersExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for ListUsersExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for ListUsersExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("ListUsers");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for ListUsersExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListUsersExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListUsersExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListRolesExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::ListRolesResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::ListRolesError> for ListRolesExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::ListRolesError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::ListRolesError::ApplicationException(aexn) => ListRolesExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::ListRolesError::ThriftError(err) => ListRolesExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for ListRolesExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for ListRolesExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for ListRolesExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for ListRolesExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for ListRolesExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("ListRoles");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for ListRolesExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListRolesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListRolesExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetUserRolesExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::ListRolesResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::GetUserRolesError> for GetUserRolesExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::GetUserRolesError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::GetUserRolesError::ApplicationException(aexn) => GetUserRolesExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::GetUserRolesError::ThriftError(err) => GetUserRolesExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for GetUserRolesExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for GetUserRolesExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for GetUserRolesExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for GetUserRolesExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for GetUserRolesExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetUserRoles");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for GetUserRolesExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetUserRolesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetUserRolesExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ChangePasswordExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::ExecResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::ChangePasswordError> for ChangePasswordExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::ChangePasswordError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::ChangePasswordError::ApplicationException(aexn) => ChangePasswordExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::ChangePasswordError::ThriftError(err) => ChangePasswordExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for ChangePasswordExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for ChangePasswordExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for ChangePasswordExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for ChangePasswordExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for ChangePasswordExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("ChangePassword");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for ChangePasswordExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ChangePasswordExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ChangePasswordExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum HeartBeatExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::HBResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::HeartBeatError> for HeartBeatExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::HeartBeatError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::HeartBeatError::ApplicationException(aexn) => HeartBeatExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::HeartBeatError::ThriftError(err) => HeartBeatExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for HeartBeatExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for HeartBeatExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for HeartBeatExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for HeartBeatExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for HeartBeatExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("HeartBeat");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for HeartBeatExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "HeartBeatExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "HeartBeatExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum AgentHeartbeatExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::AgentHBResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::AgentHeartbeatError> for AgentHeartbeatExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::AgentHeartbeatError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::AgentHeartbeatError::ApplicationException(aexn) => AgentHeartbeatExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::AgentHeartbeatError::ThriftError(err) => AgentHeartbeatExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for AgentHeartbeatExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for AgentHeartbeatExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for AgentHeartbeatExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for AgentHeartbeatExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for AgentHeartbeatExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("AgentHeartbeat");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for AgentHeartbeatExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "AgentHeartbeatExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "AgentHeartbeatExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum RegConfigExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::ExecResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::RegConfigError> for RegConfigExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::RegConfigError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::RegConfigError::ApplicationException(aexn) => RegConfigExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::RegConfigError::ThriftError(err) => RegConfigExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for RegConfigExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for RegConfigExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for RegConfigExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for RegConfigExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for RegConfigExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("RegConfig");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for RegConfigExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "RegConfigExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "RegConfigExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetConfigExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::GetConfigResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::GetConfigError> for GetConfigExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::GetConfigError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::GetConfigError::ApplicationException(aexn) => GetConfigExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::GetConfigError::ThriftError(err) => GetConfigExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for GetConfigExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for GetConfigExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for GetConfigExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for GetConfigExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for GetConfigExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetConfig");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for GetConfigExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetConfigExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetConfigExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum SetConfigExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::ExecResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::SetConfigError> for SetConfigExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::SetConfigError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::SetConfigError::ApplicationException(aexn) => SetConfigExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::SetConfigError::ThriftError(err) => SetConfigExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for SetConfigExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for SetConfigExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for SetConfigExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for SetConfigExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for SetConfigExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("SetConfig");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for SetConfigExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "SetConfigExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "SetConfigExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListConfigsExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::ListConfigsResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::ListConfigsError> for ListConfigsExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::ListConfigsError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::ListConfigsError::ApplicationException(aexn) => ListConfigsExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::ListConfigsError::ThriftError(err) => ListConfigsExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for ListConfigsExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for ListConfigsExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for ListConfigsExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for ListConfigsExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for ListConfigsExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("ListConfigs");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for ListConfigsExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListConfigsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListConfigsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum CreateSnapshotExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::ExecResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::CreateSnapshotError> for CreateSnapshotExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::CreateSnapshotError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::CreateSnapshotError::ApplicationException(aexn) => CreateSnapshotExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::CreateSnapshotError::ThriftError(err) => CreateSnapshotExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for CreateSnapshotExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for CreateSnapshotExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for CreateSnapshotExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for CreateSnapshotExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for CreateSnapshotExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("CreateSnapshot");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for CreateSnapshotExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "CreateSnapshotExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "CreateSnapshotExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DropSnapshotExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::ExecResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::DropSnapshotError> for DropSnapshotExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::DropSnapshotError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::DropSnapshotError::ApplicationException(aexn) => DropSnapshotExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::DropSnapshotError::ThriftError(err) => DropSnapshotExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for DropSnapshotExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for DropSnapshotExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for DropSnapshotExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for DropSnapshotExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for DropSnapshotExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("DropSnapshot");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for DropSnapshotExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DropSnapshotExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DropSnapshotExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListSnapshotsExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::ListSnapshotsResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::ListSnapshotsError> for ListSnapshotsExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::ListSnapshotsError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::ListSnapshotsError::ApplicationException(aexn) => ListSnapshotsExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::ListSnapshotsError::ThriftError(err) => ListSnapshotsExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for ListSnapshotsExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for ListSnapshotsExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for ListSnapshotsExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for ListSnapshotsExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for ListSnapshotsExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("ListSnapshots");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for ListSnapshotsExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListSnapshotsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListSnapshotsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum RunAdminJobExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::AdminJobResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::RunAdminJobError> for RunAdminJobExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::RunAdminJobError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::RunAdminJobError::ApplicationException(aexn) => RunAdminJobExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::RunAdminJobError::ThriftError(err) => RunAdminJobExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for RunAdminJobExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for RunAdminJobExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for RunAdminJobExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for RunAdminJobExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for RunAdminJobExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("RunAdminJob");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for RunAdminJobExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "RunAdminJobExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "RunAdminJobExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum MergeZoneExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::ExecResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::MergeZoneError> for MergeZoneExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::MergeZoneError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::MergeZoneError::ApplicationException(aexn) => MergeZoneExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::MergeZoneError::ThriftError(err) => MergeZoneExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for MergeZoneExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for MergeZoneExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for MergeZoneExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for MergeZoneExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for MergeZoneExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("MergeZone");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for MergeZoneExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "MergeZoneExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "MergeZoneExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DropZoneExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::ExecResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::DropZoneError> for DropZoneExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::DropZoneError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::DropZoneError::ApplicationException(aexn) => DropZoneExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::DropZoneError::ThriftError(err) => DropZoneExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for DropZoneExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for DropZoneExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for DropZoneExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for DropZoneExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for DropZoneExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("DropZone");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for DropZoneExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DropZoneExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DropZoneExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DivideZoneExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::ExecResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::DivideZoneError> for DivideZoneExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::DivideZoneError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::DivideZoneError::ApplicationException(aexn) => DivideZoneExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::DivideZoneError::ThriftError(err) => DivideZoneExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for DivideZoneExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for DivideZoneExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for DivideZoneExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for DivideZoneExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for DivideZoneExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("DivideZone");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for DivideZoneExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DivideZoneExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DivideZoneExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum RenameZoneExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::ExecResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::RenameZoneError> for RenameZoneExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::RenameZoneError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::RenameZoneError::ApplicationException(aexn) => RenameZoneExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::RenameZoneError::ThriftError(err) => RenameZoneExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for RenameZoneExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for RenameZoneExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for RenameZoneExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for RenameZoneExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for RenameZoneExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("RenameZone");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for RenameZoneExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "RenameZoneExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "RenameZoneExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetZoneExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::GetZoneResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::GetZoneError> for GetZoneExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::GetZoneError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::GetZoneError::ApplicationException(aexn) => GetZoneExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::GetZoneError::ThriftError(err) => GetZoneExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for GetZoneExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for GetZoneExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for GetZoneExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for GetZoneExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for GetZoneExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetZone");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for GetZoneExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetZoneExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetZoneExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListZonesExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::ListZonesResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::ListZonesError> for ListZonesExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::ListZonesError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::ListZonesError::ApplicationException(aexn) => ListZonesExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::ListZonesError::ThriftError(err) => ListZonesExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for ListZonesExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for ListZonesExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for ListZonesExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for ListZonesExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for ListZonesExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("ListZones");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for ListZonesExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListZonesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListZonesExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum AddListenerExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::ExecResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::AddListenerError> for AddListenerExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::AddListenerError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::AddListenerError::ApplicationException(aexn) => AddListenerExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::AddListenerError::ThriftError(err) => AddListenerExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for AddListenerExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for AddListenerExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for AddListenerExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for AddListenerExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for AddListenerExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("AddListener");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for AddListenerExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "AddListenerExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "AddListenerExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum RemoveListenerExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::ExecResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::RemoveListenerError> for RemoveListenerExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::RemoveListenerError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::RemoveListenerError::ApplicationException(aexn) => RemoveListenerExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::RemoveListenerError::ThriftError(err) => RemoveListenerExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for RemoveListenerExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for RemoveListenerExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for RemoveListenerExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for RemoveListenerExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for RemoveListenerExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("RemoveListener");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for RemoveListenerExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "RemoveListenerExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "RemoveListenerExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListListenerExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::ListListenerResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::ListListenerError> for ListListenerExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::ListListenerError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::ListListenerError::ApplicationException(aexn) => ListListenerExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::ListListenerError::ThriftError(err) => ListListenerExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for ListListenerExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for ListListenerExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for ListListenerExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for ListListenerExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for ListListenerExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("ListListener");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for ListListenerExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListListenerExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListListenerExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetStatsExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::GetStatsResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::GetStatsError> for GetStatsExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::GetStatsError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::GetStatsError::ApplicationException(aexn) => GetStatsExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::GetStatsError::ThriftError(err) => GetStatsExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for GetStatsExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for GetStatsExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for GetStatsExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for GetStatsExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for GetStatsExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetStats");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for GetStatsExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetStatsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetStatsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum SignInServiceExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::ExecResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::SignInServiceError> for SignInServiceExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::SignInServiceError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::SignInServiceError::ApplicationException(aexn) => SignInServiceExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::SignInServiceError::ThriftError(err) => SignInServiceExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for SignInServiceExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for SignInServiceExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for SignInServiceExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for SignInServiceExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for SignInServiceExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("SignInService");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for SignInServiceExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "SignInServiceExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "SignInServiceExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum SignOutServiceExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::ExecResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::SignOutServiceError> for SignOutServiceExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::SignOutServiceError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::SignOutServiceError::ApplicationException(aexn) => SignOutServiceExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::SignOutServiceError::ThriftError(err) => SignOutServiceExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for SignOutServiceExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for SignOutServiceExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for SignOutServiceExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for SignOutServiceExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for SignOutServiceExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("SignOutService");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for SignOutServiceExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "SignOutServiceExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "SignOutServiceExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListServiceClientsExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::ListServiceClientsResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::ListServiceClientsError> for ListServiceClientsExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::ListServiceClientsError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::ListServiceClientsError::ApplicationException(aexn) => ListServiceClientsExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::ListServiceClientsError::ThriftError(err) => ListServiceClientsExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for ListServiceClientsExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for ListServiceClientsExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for ListServiceClientsExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for ListServiceClientsExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for ListServiceClientsExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("ListServiceClients");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for ListServiceClientsExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListServiceClientsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListServiceClientsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum CreateFTIndexExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::ExecResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::CreateFTIndexError> for CreateFTIndexExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::CreateFTIndexError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::CreateFTIndexError::ApplicationException(aexn) => CreateFTIndexExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::CreateFTIndexError::ThriftError(err) => CreateFTIndexExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for CreateFTIndexExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for CreateFTIndexExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for CreateFTIndexExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for CreateFTIndexExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for CreateFTIndexExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("CreateFTIndex");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for CreateFTIndexExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "CreateFTIndexExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "CreateFTIndexExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DropFTIndexExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::ExecResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::DropFTIndexError> for DropFTIndexExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::DropFTIndexError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::DropFTIndexError::ApplicationException(aexn) => DropFTIndexExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::DropFTIndexError::ThriftError(err) => DropFTIndexExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for DropFTIndexExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for DropFTIndexExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for DropFTIndexExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for DropFTIndexExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for DropFTIndexExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("DropFTIndex");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for DropFTIndexExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DropFTIndexExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DropFTIndexExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListFTIndexesExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::ListFTIndexesResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::ListFTIndexesError> for ListFTIndexesExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::ListFTIndexesError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::ListFTIndexesError::ApplicationException(aexn) => ListFTIndexesExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::ListFTIndexesError::ThriftError(err) => ListFTIndexesExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for ListFTIndexesExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for ListFTIndexesExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for ListFTIndexesExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for ListFTIndexesExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for ListFTIndexesExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("ListFTIndexes");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for ListFTIndexesExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListFTIndexesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListFTIndexesExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum CreateSessionExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::CreateSessionResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::CreateSessionError> for CreateSessionExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::CreateSessionError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::CreateSessionError::ApplicationException(aexn) => CreateSessionExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::CreateSessionError::ThriftError(err) => CreateSessionExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for CreateSessionExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for CreateSessionExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for CreateSessionExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for CreateSessionExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for CreateSessionExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("CreateSession");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for CreateSessionExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "CreateSessionExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "CreateSessionExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum UpdateSessionsExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::UpdateSessionsResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::UpdateSessionsError> for UpdateSessionsExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::UpdateSessionsError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::UpdateSessionsError::ApplicationException(aexn) => UpdateSessionsExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::UpdateSessionsError::ThriftError(err) => UpdateSessionsExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for UpdateSessionsExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for UpdateSessionsExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for UpdateSessionsExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for UpdateSessionsExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for UpdateSessionsExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("UpdateSessions");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for UpdateSessionsExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "UpdateSessionsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "UpdateSessionsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListSessionsExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::ListSessionsResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::ListSessionsError> for ListSessionsExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::ListSessionsError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::ListSessionsError::ApplicationException(aexn) => ListSessionsExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::ListSessionsError::ThriftError(err) => ListSessionsExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for ListSessionsExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for ListSessionsExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for ListSessionsExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for ListSessionsExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for ListSessionsExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("ListSessions");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for ListSessionsExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListSessionsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListSessionsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetSessionExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::GetSessionResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::GetSessionError> for GetSessionExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::GetSessionError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::GetSessionError::ApplicationException(aexn) => GetSessionExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::GetSessionError::ThriftError(err) => GetSessionExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for GetSessionExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for GetSessionExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for GetSessionExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for GetSessionExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for GetSessionExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetSession");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for GetSessionExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetSessionExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetSessionExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum RemoveSessionExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::ExecResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::RemoveSessionError> for RemoveSessionExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::RemoveSessionError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::RemoveSessionError::ApplicationException(aexn) => RemoveSessionExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::RemoveSessionError::ThriftError(err) => RemoveSessionExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for RemoveSessionExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for RemoveSessionExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for RemoveSessionExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for RemoveSessionExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for RemoveSessionExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("RemoveSession");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for RemoveSessionExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "RemoveSessionExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "RemoveSessionExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum KillQueryExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::ExecResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::KillQueryError> for KillQueryExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::KillQueryError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::KillQueryError::ApplicationException(aexn) => KillQueryExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::KillQueryError::ThriftError(err) => KillQueryExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for KillQueryExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for KillQueryExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for KillQueryExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for KillQueryExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for KillQueryExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("KillQuery");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for KillQueryExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "KillQueryExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "KillQueryExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ReportTaskFinishExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::ExecResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::ReportTaskFinishError> for ReportTaskFinishExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::ReportTaskFinishError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::ReportTaskFinishError::ApplicationException(aexn) => ReportTaskFinishExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::ReportTaskFinishError::ThriftError(err) => ReportTaskFinishExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for ReportTaskFinishExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for ReportTaskFinishExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for ReportTaskFinishExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for ReportTaskFinishExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for ReportTaskFinishExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("ReportTaskFinish");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for ReportTaskFinishExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ReportTaskFinishExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ReportTaskFinishExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum CreateBackupExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::CreateBackupResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::CreateBackupError> for CreateBackupExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::CreateBackupError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::CreateBackupError::ApplicationException(aexn) => CreateBackupExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::CreateBackupError::ThriftError(err) => CreateBackupExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for CreateBackupExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for CreateBackupExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for CreateBackupExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for CreateBackupExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for CreateBackupExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("CreateBackup");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for CreateBackupExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "CreateBackupExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "CreateBackupExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum RestoreMetaExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::RestoreMetaResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::RestoreMetaError> for RestoreMetaExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::RestoreMetaError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::RestoreMetaError::ApplicationException(aexn) => RestoreMetaExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::RestoreMetaError::ThriftError(err) => RestoreMetaExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for RestoreMetaExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for RestoreMetaExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for RestoreMetaExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for RestoreMetaExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for RestoreMetaExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("RestoreMeta");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for RestoreMetaExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "RestoreMetaExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "RestoreMetaExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ListClusterExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::ListClusterInfoResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::ListClusterError> for ListClusterExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::ListClusterError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::ListClusterError::ApplicationException(aexn) => ListClusterExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::ListClusterError::ThriftError(err) => ListClusterExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for ListClusterExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for ListClusterExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for ListClusterExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for ListClusterExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for ListClusterExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("ListCluster");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for ListClusterExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListClusterExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListClusterExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetMetaDirInfoExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::GetMetaDirInfoResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::GetMetaDirInfoError> for GetMetaDirInfoExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::GetMetaDirInfoError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::GetMetaDirInfoError::ApplicationException(aexn) => GetMetaDirInfoExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::GetMetaDirInfoError::ThriftError(err) => GetMetaDirInfoExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for GetMetaDirInfoExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for GetMetaDirInfoExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for GetMetaDirInfoExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for GetMetaDirInfoExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for GetMetaDirInfoExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetMetaDirInfo");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for GetMetaDirInfoExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetMetaDirInfoExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetMetaDirInfoExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum VerifyClientVersionExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::VerifyClientVersionResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::VerifyClientVersionError> for VerifyClientVersionExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::VerifyClientVersionError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::VerifyClientVersionError::ApplicationException(aexn) => VerifyClientVersionExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::VerifyClientVersionError::ThriftError(err) => VerifyClientVersionExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for VerifyClientVersionExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for VerifyClientVersionExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for VerifyClientVersionExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for VerifyClientVersionExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for VerifyClientVersionExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("VerifyClientVersion");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for VerifyClientVersionExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "VerifyClientVersionExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "VerifyClientVersionExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum SaveGraphVersionExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::SaveGraphVersionResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::SaveGraphVersionError> for SaveGraphVersionExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::SaveGraphVersionError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::SaveGraphVersionError::ApplicationException(aexn) => SaveGraphVersionExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::SaveGraphVersionError::ThriftError(err) => SaveGraphVersionExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for SaveGraphVersionExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for SaveGraphVersionExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for SaveGraphVersionExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for SaveGraphVersionExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for SaveGraphVersionExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("SaveGraphVersion");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for SaveGraphVersionExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "SaveGraphVersionExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "SaveGraphVersionExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetSegmentIdExn {
            #[doc(hidden)]
            Success(crate::fbthrift_protocol::meta::types::GetSegmentIdResp),
            ApplicationException(crate::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::fbthrift_protocol::meta::errors::meta_service::GetSegmentIdError> for GetSegmentIdExn {
            fn from(err: crate::fbthrift_protocol::meta::errors::meta_service::GetSegmentIdError) -> Self {
                match err {
                    crate::fbthrift_protocol::meta::errors::meta_service::GetSegmentIdError::ApplicationException(aexn) => GetSegmentIdExn::ApplicationException(aexn),
                    crate::fbthrift_protocol::meta::errors::meta_service::GetSegmentIdError::ThriftError(err) => GetSegmentIdExn::ApplicationException(crate::fbthrift::ApplicationException {
                        message: err.to_string(),
                        type_: crate::fbthrift::ApplicationExceptionErrorCode::InternalError,
                    }),
                }
            }
        }

        impl ::std::convert::From<crate::fbthrift::ApplicationException> for GetSegmentIdExn {
            fn from(exn: crate::fbthrift::ApplicationException) -> Self {
                Self::ApplicationException(exn)
            }
        }

        impl crate::fbthrift::ExceptionInfo for GetSegmentIdExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    Self::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl crate::fbthrift::ResultInfo for GetSegmentIdExn {
            fn result_type(&self) -> crate::fbthrift::ResultType {
                match self {
                    Self::Success(_) => crate::fbthrift::ResultType::Return,
                    Self::ApplicationException(_aexn) => crate::fbthrift::ResultType::Exception,
                }
            }
        }

        impl crate::fbthrift::GetTType for GetSegmentIdExn {
            const TTYPE: crate::fbthrift::TType = crate::fbthrift::TType::Struct;
        }

        impl<P> crate::fbthrift::Serialize<P> for GetSegmentIdExn
        where
            P: crate::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let Self::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetSegmentId");
                match self {
                    Self::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            crate::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    Self::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> crate::fbthrift::Deserialize<P> for GetSegmentIdExn
        where
            P: crate::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[crate::fbthrift::Field] = &[
                    crate::fbthrift::Field::new("Success", crate::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((crate::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((crate::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(Self::Success(crate::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            crate::fbthrift::ApplicationException::new(
                                crate::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetSegmentIdExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    crate::fbthrift::ApplicationException::new(
                        crate::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetSegmentIdExn"),
                    )
                    .into(),
                )
            }
        }
    }
}

/// Client implementation for each service in `meta`.
pub mod client {

    pub struct MetaServiceImpl<P, T, S = crate::fbthrift::NoopSpawner> {
        transport: T,
        _phantom: ::std::marker::PhantomData<fn() -> (P, S)>,
    }

    impl<P, T, S> MetaServiceImpl<P, T, S>
    where
        P: crate::fbthrift::Protocol,
        T: crate::fbthrift::Transport,
        P::Frame: crate::fbthrift::Framing<DecBuf = crate::fbthrift::FramingDecoded<T>>,
        crate::fbthrift::ProtocolEncoded<P>: crate::fbthrift::BufMutExt<Final = crate::fbthrift::FramingEncodedFinal<T>>,
        P::Deserializer: ::std::marker::Send,
        S: crate::fbthrift::help::Spawner,
    {
        pub fn new(
            transport: T,
        ) -> Self {
            Self {
                transport,
                _phantom: ::std::marker::PhantomData,
            }
        }

        pub fn transport(&self) -> &T {
            &self.transport
        }


        fn _createSpace_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateSpaceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateSpaceError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createSpace";
            }
            let args = self::Args_MetaService_createSpace {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("createSpace", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.createSpace"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::CreateSpaceExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::CreateSpaceError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.createSpace"))
            .boxed()
        }

        fn _dropSpace_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropSpaceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropSpaceError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropSpace";
            }
            let args = self::Args_MetaService_dropSpace {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("dropSpace", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.dropSpace"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::DropSpaceExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::DropSpaceError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.dropSpace"))
            .boxed()
        }

        fn _clearSpace_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ClearSpaceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::ClearSpaceError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.clearSpace";
            }
            let args = self::Args_MetaService_clearSpace {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("clearSpace", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.clearSpace"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::ClearSpaceExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::ClearSpaceError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.clearSpace"))
            .boxed()
        }

        fn _getSpace_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetSpaceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetSpaceResp, crate::fbthrift_protocol::meta::errors::meta_service::GetSpaceError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getSpace";
            }
            let args = self::Args_MetaService_getSpace {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("getSpace", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.getSpace"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::GetSpaceExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::GetSpaceError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.getSpace"))
            .boxed()
        }

        fn _listSpaces_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListSpacesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListSpacesResp, crate::fbthrift_protocol::meta::errors::meta_service::ListSpacesError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listSpaces";
            }
            let args = self::Args_MetaService_listSpaces {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("listSpaces", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.listSpaces"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::ListSpacesExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::ListSpacesError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.listSpaces"))
            .boxed()
        }

        fn _alterSpace_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::AlterSpaceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::AlterSpaceError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.alterSpace";
            }
            let args = self::Args_MetaService_alterSpace {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("alterSpace", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.alterSpace"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::AlterSpaceExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::AlterSpaceError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.alterSpace"))
            .boxed()
        }

        fn _createSpaceAs_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateSpaceAsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateSpaceAsError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createSpaceAs";
            }
            let args = self::Args_MetaService_createSpaceAs {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("createSpaceAs", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.createSpaceAs"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::CreateSpaceAsExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::CreateSpaceAsError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.createSpaceAs"))
            .boxed()
        }

        fn _createTag_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateTagReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateTagError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createTag";
            }
            let args = self::Args_MetaService_createTag {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("createTag", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.createTag"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::CreateTagExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::CreateTagError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.createTag"))
            .boxed()
        }

        fn _alterTag_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::AlterTagReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::AlterTagError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.alterTag";
            }
            let args = self::Args_MetaService_alterTag {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("alterTag", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.alterTag"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::AlterTagExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::AlterTagError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.alterTag"))
            .boxed()
        }

        fn _dropTag_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropTagReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropTagError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropTag";
            }
            let args = self::Args_MetaService_dropTag {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("dropTag", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.dropTag"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::DropTagExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::DropTagError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.dropTag"))
            .boxed()
        }

        fn _getTag_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetTagReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetTagResp, crate::fbthrift_protocol::meta::errors::meta_service::GetTagError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getTag";
            }
            let args = self::Args_MetaService_getTag {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("getTag", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.getTag"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::GetTagExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::GetTagError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.getTag"))
            .boxed()
        }

        fn _listTags_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListTagsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListTagsResp, crate::fbthrift_protocol::meta::errors::meta_service::ListTagsError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listTags";
            }
            let args = self::Args_MetaService_listTags {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("listTags", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.listTags"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::ListTagsExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::ListTagsError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.listTags"))
            .boxed()
        }

        fn _createEdge_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateEdgeReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateEdgeError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createEdge";
            }
            let args = self::Args_MetaService_createEdge {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("createEdge", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.createEdge"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::CreateEdgeExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::CreateEdgeError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.createEdge"))
            .boxed()
        }

        fn _alterEdge_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::AlterEdgeReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::AlterEdgeError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.alterEdge";
            }
            let args = self::Args_MetaService_alterEdge {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("alterEdge", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.alterEdge"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::AlterEdgeExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::AlterEdgeError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.alterEdge"))
            .boxed()
        }

        fn _dropEdge_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropEdgeReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropEdgeError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropEdge";
            }
            let args = self::Args_MetaService_dropEdge {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("dropEdge", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.dropEdge"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::DropEdgeExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::DropEdgeError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.dropEdge"))
            .boxed()
        }

        fn _getEdge_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetEdgeReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetEdgeResp, crate::fbthrift_protocol::meta::errors::meta_service::GetEdgeError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getEdge";
            }
            let args = self::Args_MetaService_getEdge {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("getEdge", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.getEdge"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::GetEdgeExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::GetEdgeError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.getEdge"))
            .boxed()
        }

        fn _listEdges_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListEdgesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListEdgesResp, crate::fbthrift_protocol::meta::errors::meta_service::ListEdgesError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listEdges";
            }
            let args = self::Args_MetaService_listEdges {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("listEdges", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.listEdges"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::ListEdgesExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::ListEdgesError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.listEdges"))
            .boxed()
        }

        fn _addHosts_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::AddHostsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::AddHostsError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.addHosts";
            }
            let args = self::Args_MetaService_addHosts {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("addHosts", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.addHosts"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::AddHostsExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::AddHostsError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.addHosts"))
            .boxed()
        }

        fn _addHostsIntoZone_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::AddHostsIntoZoneReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::AddHostsIntoZoneError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.addHostsIntoZone";
            }
            let args = self::Args_MetaService_addHostsIntoZone {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("addHostsIntoZone", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.addHostsIntoZone"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::AddHostsIntoZoneExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::AddHostsIntoZoneError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.addHostsIntoZone"))
            .boxed()
        }

        fn _dropHosts_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropHostsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropHostsError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropHosts";
            }
            let args = self::Args_MetaService_dropHosts {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("dropHosts", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.dropHosts"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::DropHostsExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::DropHostsError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.dropHosts"))
            .boxed()
        }

        fn _listHosts_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListHostsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListHostsResp, crate::fbthrift_protocol::meta::errors::meta_service::ListHostsError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listHosts";
            }
            let args = self::Args_MetaService_listHosts {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("listHosts", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.listHosts"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::ListHostsExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::ListHostsError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.listHosts"))
            .boxed()
        }

        fn _getPartsAlloc_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetPartsAllocReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetPartsAllocResp, crate::fbthrift_protocol::meta::errors::meta_service::GetPartsAllocError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getPartsAlloc";
            }
            let args = self::Args_MetaService_getPartsAlloc {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("getPartsAlloc", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.getPartsAlloc"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::GetPartsAllocExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::GetPartsAllocError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.getPartsAlloc"))
            .boxed()
        }

        fn _listParts_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListPartsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListPartsResp, crate::fbthrift_protocol::meta::errors::meta_service::ListPartsError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listParts";
            }
            let args = self::Args_MetaService_listParts {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("listParts", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.listParts"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::ListPartsExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::ListPartsError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.listParts"))
            .boxed()
        }

        fn _getWorkerId_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetWorkerIdReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetWorkerIdResp, crate::fbthrift_protocol::meta::errors::meta_service::GetWorkerIdError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getWorkerId";
            }
            let args = self::Args_MetaService_getWorkerId {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("getWorkerId", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.getWorkerId"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::GetWorkerIdExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::GetWorkerIdError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.getWorkerId"))
            .boxed()
        }

        fn _createTagIndex_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateTagIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateTagIndexError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createTagIndex";
            }
            let args = self::Args_MetaService_createTagIndex {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("createTagIndex", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.createTagIndex"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::CreateTagIndexExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::CreateTagIndexError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.createTagIndex"))
            .boxed()
        }

        fn _dropTagIndex_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropTagIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropTagIndexError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropTagIndex";
            }
            let args = self::Args_MetaService_dropTagIndex {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("dropTagIndex", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.dropTagIndex"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::DropTagIndexExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::DropTagIndexError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.dropTagIndex"))
            .boxed()
        }

        fn _getTagIndex_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetTagIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetTagIndexResp, crate::fbthrift_protocol::meta::errors::meta_service::GetTagIndexError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getTagIndex";
            }
            let args = self::Args_MetaService_getTagIndex {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("getTagIndex", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.getTagIndex"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::GetTagIndexExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::GetTagIndexError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.getTagIndex"))
            .boxed()
        }

        fn _listTagIndexes_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListTagIndexesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListTagIndexesResp, crate::fbthrift_protocol::meta::errors::meta_service::ListTagIndexesError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listTagIndexes";
            }
            let args = self::Args_MetaService_listTagIndexes {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("listTagIndexes", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.listTagIndexes"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::ListTagIndexesExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::ListTagIndexesError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.listTagIndexes"))
            .boxed()
        }

        fn _rebuildTagIndex_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::RebuildIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::RebuildTagIndexError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.rebuildTagIndex";
            }
            let args = self::Args_MetaService_rebuildTagIndex {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("rebuildTagIndex", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.rebuildTagIndex"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::RebuildTagIndexExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::RebuildTagIndexError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.rebuildTagIndex"))
            .boxed()
        }

        fn _listTagIndexStatus_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListIndexStatusReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListIndexStatusResp, crate::fbthrift_protocol::meta::errors::meta_service::ListTagIndexStatusError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listTagIndexStatus";
            }
            let args = self::Args_MetaService_listTagIndexStatus {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("listTagIndexStatus", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.listTagIndexStatus"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::ListTagIndexStatusExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::ListTagIndexStatusError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.listTagIndexStatus"))
            .boxed()
        }

        fn _createEdgeIndex_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateEdgeIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateEdgeIndexError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createEdgeIndex";
            }
            let args = self::Args_MetaService_createEdgeIndex {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("createEdgeIndex", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.createEdgeIndex"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::CreateEdgeIndexExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::CreateEdgeIndexError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.createEdgeIndex"))
            .boxed()
        }

        fn _dropEdgeIndex_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropEdgeIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropEdgeIndexError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropEdgeIndex";
            }
            let args = self::Args_MetaService_dropEdgeIndex {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("dropEdgeIndex", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.dropEdgeIndex"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::DropEdgeIndexExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::DropEdgeIndexError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.dropEdgeIndex"))
            .boxed()
        }

        fn _getEdgeIndex_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetEdgeIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetEdgeIndexResp, crate::fbthrift_protocol::meta::errors::meta_service::GetEdgeIndexError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getEdgeIndex";
            }
            let args = self::Args_MetaService_getEdgeIndex {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("getEdgeIndex", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.getEdgeIndex"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::GetEdgeIndexExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::GetEdgeIndexError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.getEdgeIndex"))
            .boxed()
        }

        fn _listEdgeIndexes_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListEdgeIndexesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListEdgeIndexesResp, crate::fbthrift_protocol::meta::errors::meta_service::ListEdgeIndexesError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listEdgeIndexes";
            }
            let args = self::Args_MetaService_listEdgeIndexes {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("listEdgeIndexes", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.listEdgeIndexes"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::ListEdgeIndexesExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::ListEdgeIndexesError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.listEdgeIndexes"))
            .boxed()
        }

        fn _rebuildEdgeIndex_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::RebuildIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::RebuildEdgeIndexError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.rebuildEdgeIndex";
            }
            let args = self::Args_MetaService_rebuildEdgeIndex {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("rebuildEdgeIndex", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.rebuildEdgeIndex"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::RebuildEdgeIndexExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::RebuildEdgeIndexError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.rebuildEdgeIndex"))
            .boxed()
        }

        fn _listEdgeIndexStatus_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListIndexStatusReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListIndexStatusResp, crate::fbthrift_protocol::meta::errors::meta_service::ListEdgeIndexStatusError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listEdgeIndexStatus";
            }
            let args = self::Args_MetaService_listEdgeIndexStatus {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("listEdgeIndexStatus", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.listEdgeIndexStatus"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::ListEdgeIndexStatusExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::ListEdgeIndexStatusError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.listEdgeIndexStatus"))
            .boxed()
        }

        fn _createUser_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateUserReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateUserError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createUser";
            }
            let args = self::Args_MetaService_createUser {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("createUser", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.createUser"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::CreateUserExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::CreateUserError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.createUser"))
            .boxed()
        }

        fn _dropUser_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropUserReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropUserError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropUser";
            }
            let args = self::Args_MetaService_dropUser {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("dropUser", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.dropUser"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::DropUserExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::DropUserError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.dropUser"))
            .boxed()
        }

        fn _alterUser_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::AlterUserReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::AlterUserError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.alterUser";
            }
            let args = self::Args_MetaService_alterUser {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("alterUser", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.alterUser"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::AlterUserExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::AlterUserError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.alterUser"))
            .boxed()
        }

        fn _grantRole_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GrantRoleReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::GrantRoleError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.grantRole";
            }
            let args = self::Args_MetaService_grantRole {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("grantRole", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.grantRole"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::GrantRoleExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::GrantRoleError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.grantRole"))
            .boxed()
        }

        fn _revokeRole_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::RevokeRoleReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::RevokeRoleError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.revokeRole";
            }
            let args = self::Args_MetaService_revokeRole {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("revokeRole", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.revokeRole"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::RevokeRoleExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::RevokeRoleError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.revokeRole"))
            .boxed()
        }

        fn _listUsers_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListUsersReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListUsersResp, crate::fbthrift_protocol::meta::errors::meta_service::ListUsersError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listUsers";
            }
            let args = self::Args_MetaService_listUsers {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("listUsers", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.listUsers"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::ListUsersExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::ListUsersError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.listUsers"))
            .boxed()
        }

        fn _listRoles_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListRolesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListRolesResp, crate::fbthrift_protocol::meta::errors::meta_service::ListRolesError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listRoles";
            }
            let args = self::Args_MetaService_listRoles {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("listRoles", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.listRoles"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::ListRolesExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::ListRolesError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.listRoles"))
            .boxed()
        }

        fn _getUserRoles_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetUserRolesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListRolesResp, crate::fbthrift_protocol::meta::errors::meta_service::GetUserRolesError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getUserRoles";
            }
            let args = self::Args_MetaService_getUserRoles {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("getUserRoles", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.getUserRoles"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::GetUserRolesExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::GetUserRolesError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.getUserRoles"))
            .boxed()
        }

        fn _changePassword_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ChangePasswordReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::ChangePasswordError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.changePassword";
            }
            let args = self::Args_MetaService_changePassword {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("changePassword", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.changePassword"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::ChangePasswordExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::ChangePasswordError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.changePassword"))
            .boxed()
        }

        fn _heartBeat_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::HBReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::HBResp, crate::fbthrift_protocol::meta::errors::meta_service::HeartBeatError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.heartBeat";
            }
            let args = self::Args_MetaService_heartBeat {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("heartBeat", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.heartBeat"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::HeartBeatExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::HeartBeatError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.heartBeat"))
            .boxed()
        }

        fn _agentHeartbeat_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::AgentHBReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::AgentHBResp, crate::fbthrift_protocol::meta::errors::meta_service::AgentHeartbeatError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.agentHeartbeat";
            }
            let args = self::Args_MetaService_agentHeartbeat {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("agentHeartbeat", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.agentHeartbeat"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::AgentHeartbeatExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::AgentHeartbeatError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.agentHeartbeat"))
            .boxed()
        }

        fn _regConfig_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::RegConfigReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::RegConfigError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.regConfig";
            }
            let args = self::Args_MetaService_regConfig {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("regConfig", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.regConfig"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::RegConfigExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::RegConfigError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.regConfig"))
            .boxed()
        }

        fn _getConfig_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetConfigReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetConfigResp, crate::fbthrift_protocol::meta::errors::meta_service::GetConfigError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getConfig";
            }
            let args = self::Args_MetaService_getConfig {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("getConfig", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.getConfig"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::GetConfigExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::GetConfigError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.getConfig"))
            .boxed()
        }

        fn _setConfig_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::SetConfigReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::SetConfigError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.setConfig";
            }
            let args = self::Args_MetaService_setConfig {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("setConfig", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.setConfig"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::SetConfigExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::SetConfigError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.setConfig"))
            .boxed()
        }

        fn _listConfigs_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListConfigsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListConfigsResp, crate::fbthrift_protocol::meta::errors::meta_service::ListConfigsError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listConfigs";
            }
            let args = self::Args_MetaService_listConfigs {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("listConfigs", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.listConfigs"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::ListConfigsExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::ListConfigsError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.listConfigs"))
            .boxed()
        }

        fn _createSnapshot_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateSnapshotReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateSnapshotError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createSnapshot";
            }
            let args = self::Args_MetaService_createSnapshot {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("createSnapshot", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.createSnapshot"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::CreateSnapshotExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::CreateSnapshotError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.createSnapshot"))
            .boxed()
        }

        fn _dropSnapshot_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropSnapshotReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropSnapshotError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropSnapshot";
            }
            let args = self::Args_MetaService_dropSnapshot {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("dropSnapshot", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.dropSnapshot"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::DropSnapshotExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::DropSnapshotError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.dropSnapshot"))
            .boxed()
        }

        fn _listSnapshots_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListSnapshotsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListSnapshotsResp, crate::fbthrift_protocol::meta::errors::meta_service::ListSnapshotsError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listSnapshots";
            }
            let args = self::Args_MetaService_listSnapshots {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("listSnapshots", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.listSnapshots"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::ListSnapshotsExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::ListSnapshotsError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.listSnapshots"))
            .boxed()
        }

        fn _runAdminJob_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::AdminJobReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::AdminJobResp, crate::fbthrift_protocol::meta::errors::meta_service::RunAdminJobError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.runAdminJob";
            }
            let args = self::Args_MetaService_runAdminJob {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("runAdminJob", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.runAdminJob"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::RunAdminJobExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::RunAdminJobError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.runAdminJob"))
            .boxed()
        }

        fn _mergeZone_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::MergeZoneReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::MergeZoneError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.mergeZone";
            }
            let args = self::Args_MetaService_mergeZone {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("mergeZone", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.mergeZone"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::MergeZoneExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::MergeZoneError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.mergeZone"))
            .boxed()
        }

        fn _dropZone_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropZoneReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropZoneError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropZone";
            }
            let args = self::Args_MetaService_dropZone {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("dropZone", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.dropZone"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::DropZoneExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::DropZoneError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.dropZone"))
            .boxed()
        }

        fn _divideZone_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DivideZoneReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DivideZoneError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.divideZone";
            }
            let args = self::Args_MetaService_divideZone {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("divideZone", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.divideZone"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::DivideZoneExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::DivideZoneError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.divideZone"))
            .boxed()
        }

        fn _renameZone_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::RenameZoneReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::RenameZoneError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.renameZone";
            }
            let args = self::Args_MetaService_renameZone {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("renameZone", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.renameZone"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::RenameZoneExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::RenameZoneError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.renameZone"))
            .boxed()
        }

        fn _getZone_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetZoneReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetZoneResp, crate::fbthrift_protocol::meta::errors::meta_service::GetZoneError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getZone";
            }
            let args = self::Args_MetaService_getZone {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("getZone", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.getZone"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::GetZoneExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::GetZoneError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.getZone"))
            .boxed()
        }

        fn _listZones_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListZonesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListZonesResp, crate::fbthrift_protocol::meta::errors::meta_service::ListZonesError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listZones";
            }
            let args = self::Args_MetaService_listZones {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("listZones", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.listZones"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::ListZonesExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::ListZonesError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.listZones"))
            .boxed()
        }

        fn _addListener_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::AddListenerReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::AddListenerError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.addListener";
            }
            let args = self::Args_MetaService_addListener {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("addListener", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.addListener"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::AddListenerExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::AddListenerError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.addListener"))
            .boxed()
        }

        fn _removeListener_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::RemoveListenerReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::RemoveListenerError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.removeListener";
            }
            let args = self::Args_MetaService_removeListener {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("removeListener", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.removeListener"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::RemoveListenerExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::RemoveListenerError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.removeListener"))
            .boxed()
        }

        fn _listListener_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListListenerReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListListenerResp, crate::fbthrift_protocol::meta::errors::meta_service::ListListenerError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listListener";
            }
            let args = self::Args_MetaService_listListener {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("listListener", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.listListener"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::ListListenerExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::ListListenerError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.listListener"))
            .boxed()
        }

        fn _getStats_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetStatsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetStatsResp, crate::fbthrift_protocol::meta::errors::meta_service::GetStatsError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getStats";
            }
            let args = self::Args_MetaService_getStats {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("getStats", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.getStats"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::GetStatsExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::GetStatsError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.getStats"))
            .boxed()
        }

        fn _signInService_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::SignInServiceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::SignInServiceError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.signInService";
            }
            let args = self::Args_MetaService_signInService {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("signInService", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.signInService"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::SignInServiceExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::SignInServiceError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.signInService"))
            .boxed()
        }

        fn _signOutService_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::SignOutServiceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::SignOutServiceError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.signOutService";
            }
            let args = self::Args_MetaService_signOutService {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("signOutService", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.signOutService"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::SignOutServiceExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::SignOutServiceError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.signOutService"))
            .boxed()
        }

        fn _listServiceClients_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListServiceClientsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListServiceClientsResp, crate::fbthrift_protocol::meta::errors::meta_service::ListServiceClientsError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listServiceClients";
            }
            let args = self::Args_MetaService_listServiceClients {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("listServiceClients", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.listServiceClients"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::ListServiceClientsExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::ListServiceClientsError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.listServiceClients"))
            .boxed()
        }

        fn _createFTIndex_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateFTIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateFTIndexError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createFTIndex";
            }
            let args = self::Args_MetaService_createFTIndex {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("createFTIndex", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.createFTIndex"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::CreateFTIndexExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::CreateFTIndexError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.createFTIndex"))
            .boxed()
        }

        fn _dropFTIndex_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropFTIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropFTIndexError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropFTIndex";
            }
            let args = self::Args_MetaService_dropFTIndex {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("dropFTIndex", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.dropFTIndex"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::DropFTIndexExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::DropFTIndexError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.dropFTIndex"))
            .boxed()
        }

        fn _listFTIndexes_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListFTIndexesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListFTIndexesResp, crate::fbthrift_protocol::meta::errors::meta_service::ListFTIndexesError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listFTIndexes";
            }
            let args = self::Args_MetaService_listFTIndexes {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("listFTIndexes", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.listFTIndexes"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::ListFTIndexesExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::ListFTIndexesError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.listFTIndexes"))
            .boxed()
        }

        fn _createSession_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateSessionReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::CreateSessionResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateSessionError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createSession";
            }
            let args = self::Args_MetaService_createSession {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("createSession", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.createSession"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::CreateSessionExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::CreateSessionError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.createSession"))
            .boxed()
        }

        fn _updateSessions_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::UpdateSessionsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::UpdateSessionsResp, crate::fbthrift_protocol::meta::errors::meta_service::UpdateSessionsError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.updateSessions";
            }
            let args = self::Args_MetaService_updateSessions {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("updateSessions", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.updateSessions"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::UpdateSessionsExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::UpdateSessionsError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.updateSessions"))
            .boxed()
        }

        fn _listSessions_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListSessionsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListSessionsResp, crate::fbthrift_protocol::meta::errors::meta_service::ListSessionsError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listSessions";
            }
            let args = self::Args_MetaService_listSessions {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("listSessions", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.listSessions"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::ListSessionsExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::ListSessionsError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.listSessions"))
            .boxed()
        }

        fn _getSession_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetSessionReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetSessionResp, crate::fbthrift_protocol::meta::errors::meta_service::GetSessionError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getSession";
            }
            let args = self::Args_MetaService_getSession {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("getSession", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.getSession"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::GetSessionExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::GetSessionError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.getSession"))
            .boxed()
        }

        fn _removeSession_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::RemoveSessionReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::RemoveSessionError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.removeSession";
            }
            let args = self::Args_MetaService_removeSession {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("removeSession", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.removeSession"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::RemoveSessionExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::RemoveSessionError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.removeSession"))
            .boxed()
        }

        fn _killQuery_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::KillQueryReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::KillQueryError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.killQuery";
            }
            let args = self::Args_MetaService_killQuery {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("killQuery", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.killQuery"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::KillQueryExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::KillQueryError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.killQuery"))
            .boxed()
        }

        fn _reportTaskFinish_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ReportTaskReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::ReportTaskFinishError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.reportTaskFinish";
            }
            let args = self::Args_MetaService_reportTaskFinish {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("reportTaskFinish", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.reportTaskFinish"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::ReportTaskFinishExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::ReportTaskFinishError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.reportTaskFinish"))
            .boxed()
        }

        fn _createBackup_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateBackupReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::CreateBackupResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateBackupError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createBackup";
            }
            let args = self::Args_MetaService_createBackup {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("createBackup", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.createBackup"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::CreateBackupExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::CreateBackupError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.createBackup"))
            .boxed()
        }

        fn _restoreMeta_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::RestoreMetaReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::RestoreMetaResp, crate::fbthrift_protocol::meta::errors::meta_service::RestoreMetaError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.restoreMeta";
            }
            let args = self::Args_MetaService_restoreMeta {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("restoreMeta", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.restoreMeta"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::RestoreMetaExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::RestoreMetaError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.restoreMeta"))
            .boxed()
        }

        fn _listCluster_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListClusterInfoReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListClusterInfoResp, crate::fbthrift_protocol::meta::errors::meta_service::ListClusterError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listCluster";
            }
            let args = self::Args_MetaService_listCluster {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("listCluster", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.listCluster"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::ListClusterExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::ListClusterError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.listCluster"))
            .boxed()
        }

        fn _getMetaDirInfo_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetMetaDirInfoReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetMetaDirInfoResp, crate::fbthrift_protocol::meta::errors::meta_service::GetMetaDirInfoError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getMetaDirInfo";
            }
            let args = self::Args_MetaService_getMetaDirInfo {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("getMetaDirInfo", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.getMetaDirInfo"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::GetMetaDirInfoExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::GetMetaDirInfoError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.getMetaDirInfo"))
            .boxed()
        }

        fn _verifyClientVersion_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::VerifyClientVersionReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::VerifyClientVersionResp, crate::fbthrift_protocol::meta::errors::meta_service::VerifyClientVersionError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.verifyClientVersion";
            }
            let args = self::Args_MetaService_verifyClientVersion {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("verifyClientVersion", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.verifyClientVersion"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::VerifyClientVersionExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::VerifyClientVersionError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.verifyClientVersion"))
            .boxed()
        }

        fn _saveGraphVersion_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::SaveGraphVersionReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::SaveGraphVersionResp, crate::fbthrift_protocol::meta::errors::meta_service::SaveGraphVersionError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.saveGraphVersion";
            }
            let args = self::Args_MetaService_saveGraphVersion {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("saveGraphVersion", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.saveGraphVersion"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::SaveGraphVersionExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::SaveGraphVersionError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.saveGraphVersion"))
            .boxed()
        }

        fn _getSegmentId_impl(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetSegmentIdReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetSegmentIdResp, crate::fbthrift_protocol::meta::errors::meta_service::GetSegmentIdError>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getSegmentId";
            }
            let args = self::Args_MetaService_getSegmentId {
                req: arg_req,
                _phantom: ::std::marker::PhantomData,
            };

            let transport = self.transport();

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match crate::fbthrift::help::serialize_request_envelope::<P, _>("getSegmentId", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = transport
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env, rpc_options)
                .instrument(::tracing::trace_span!("call", function = "MetaService.getSegmentId"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::fbthrift_protocol::meta::services::meta_service::GetSegmentIdExn, _>, _) =
                    crate::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                let res = match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::fbthrift_protocol::meta::errors::meta_service::GetSegmentIdError::ApplicationException(aexn))
                };
                res
            }
            .instrument(::tracing::info_span!("MetaService.getSegmentId"))
            .boxed()
        }
    }

    pub trait MetaService: ::std::marker::Send {
        fn createSpace(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateSpaceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateSpaceError>>;

        fn dropSpace(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropSpaceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropSpaceError>>;

        fn clearSpace(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ClearSpaceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::ClearSpaceError>>;

        fn getSpace(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetSpaceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetSpaceResp, crate::fbthrift_protocol::meta::errors::meta_service::GetSpaceError>>;

        fn listSpaces(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListSpacesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListSpacesResp, crate::fbthrift_protocol::meta::errors::meta_service::ListSpacesError>>;

        fn alterSpace(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::AlterSpaceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::AlterSpaceError>>;

        fn createSpaceAs(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateSpaceAsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateSpaceAsError>>;

        fn createTag(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateTagReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateTagError>>;

        fn alterTag(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::AlterTagReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::AlterTagError>>;

        fn dropTag(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropTagReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropTagError>>;

        fn getTag(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetTagReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetTagResp, crate::fbthrift_protocol::meta::errors::meta_service::GetTagError>>;

        fn listTags(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListTagsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListTagsResp, crate::fbthrift_protocol::meta::errors::meta_service::ListTagsError>>;

        fn createEdge(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateEdgeReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateEdgeError>>;

        fn alterEdge(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::AlterEdgeReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::AlterEdgeError>>;

        fn dropEdge(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropEdgeReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropEdgeError>>;

        fn getEdge(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetEdgeReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetEdgeResp, crate::fbthrift_protocol::meta::errors::meta_service::GetEdgeError>>;

        fn listEdges(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListEdgesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListEdgesResp, crate::fbthrift_protocol::meta::errors::meta_service::ListEdgesError>>;

        fn addHosts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::AddHostsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::AddHostsError>>;

        fn addHostsIntoZone(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::AddHostsIntoZoneReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::AddHostsIntoZoneError>>;

        fn dropHosts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropHostsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropHostsError>>;

        fn listHosts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListHostsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListHostsResp, crate::fbthrift_protocol::meta::errors::meta_service::ListHostsError>>;

        fn getPartsAlloc(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetPartsAllocReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetPartsAllocResp, crate::fbthrift_protocol::meta::errors::meta_service::GetPartsAllocError>>;

        fn listParts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListPartsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListPartsResp, crate::fbthrift_protocol::meta::errors::meta_service::ListPartsError>>;

        fn getWorkerId(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetWorkerIdReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetWorkerIdResp, crate::fbthrift_protocol::meta::errors::meta_service::GetWorkerIdError>>;

        fn createTagIndex(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateTagIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateTagIndexError>>;

        fn dropTagIndex(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropTagIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropTagIndexError>>;

        fn getTagIndex(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetTagIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetTagIndexResp, crate::fbthrift_protocol::meta::errors::meta_service::GetTagIndexError>>;

        fn listTagIndexes(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListTagIndexesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListTagIndexesResp, crate::fbthrift_protocol::meta::errors::meta_service::ListTagIndexesError>>;

        fn rebuildTagIndex(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::RebuildIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::RebuildTagIndexError>>;

        fn listTagIndexStatus(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListIndexStatusReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListIndexStatusResp, crate::fbthrift_protocol::meta::errors::meta_service::ListTagIndexStatusError>>;

        fn createEdgeIndex(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateEdgeIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateEdgeIndexError>>;

        fn dropEdgeIndex(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropEdgeIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropEdgeIndexError>>;

        fn getEdgeIndex(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetEdgeIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetEdgeIndexResp, crate::fbthrift_protocol::meta::errors::meta_service::GetEdgeIndexError>>;

        fn listEdgeIndexes(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListEdgeIndexesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListEdgeIndexesResp, crate::fbthrift_protocol::meta::errors::meta_service::ListEdgeIndexesError>>;

        fn rebuildEdgeIndex(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::RebuildIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::RebuildEdgeIndexError>>;

        fn listEdgeIndexStatus(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListIndexStatusReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListIndexStatusResp, crate::fbthrift_protocol::meta::errors::meta_service::ListEdgeIndexStatusError>>;

        fn createUser(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateUserReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateUserError>>;

        fn dropUser(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropUserReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropUserError>>;

        fn alterUser(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::AlterUserReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::AlterUserError>>;

        fn grantRole(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GrantRoleReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::GrantRoleError>>;

        fn revokeRole(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::RevokeRoleReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::RevokeRoleError>>;

        fn listUsers(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListUsersReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListUsersResp, crate::fbthrift_protocol::meta::errors::meta_service::ListUsersError>>;

        fn listRoles(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListRolesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListRolesResp, crate::fbthrift_protocol::meta::errors::meta_service::ListRolesError>>;

        fn getUserRoles(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetUserRolesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListRolesResp, crate::fbthrift_protocol::meta::errors::meta_service::GetUserRolesError>>;

        fn changePassword(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ChangePasswordReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::ChangePasswordError>>;

        fn heartBeat(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::HBReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::HBResp, crate::fbthrift_protocol::meta::errors::meta_service::HeartBeatError>>;

        fn agentHeartbeat(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::AgentHBReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::AgentHBResp, crate::fbthrift_protocol::meta::errors::meta_service::AgentHeartbeatError>>;

        fn regConfig(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::RegConfigReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::RegConfigError>>;

        fn getConfig(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetConfigReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetConfigResp, crate::fbthrift_protocol::meta::errors::meta_service::GetConfigError>>;

        fn setConfig(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::SetConfigReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::SetConfigError>>;

        fn listConfigs(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListConfigsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListConfigsResp, crate::fbthrift_protocol::meta::errors::meta_service::ListConfigsError>>;

        fn createSnapshot(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateSnapshotReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateSnapshotError>>;

        fn dropSnapshot(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropSnapshotReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropSnapshotError>>;

        fn listSnapshots(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListSnapshotsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListSnapshotsResp, crate::fbthrift_protocol::meta::errors::meta_service::ListSnapshotsError>>;

        fn runAdminJob(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::AdminJobReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::AdminJobResp, crate::fbthrift_protocol::meta::errors::meta_service::RunAdminJobError>>;

        fn mergeZone(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::MergeZoneReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::MergeZoneError>>;

        fn dropZone(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropZoneReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropZoneError>>;

        fn divideZone(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DivideZoneReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DivideZoneError>>;

        fn renameZone(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::RenameZoneReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::RenameZoneError>>;

        fn getZone(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetZoneReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetZoneResp, crate::fbthrift_protocol::meta::errors::meta_service::GetZoneError>>;

        fn listZones(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListZonesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListZonesResp, crate::fbthrift_protocol::meta::errors::meta_service::ListZonesError>>;

        fn addListener(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::AddListenerReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::AddListenerError>>;

        fn removeListener(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::RemoveListenerReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::RemoveListenerError>>;

        fn listListener(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListListenerReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListListenerResp, crate::fbthrift_protocol::meta::errors::meta_service::ListListenerError>>;

        fn getStats(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetStatsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetStatsResp, crate::fbthrift_protocol::meta::errors::meta_service::GetStatsError>>;

        fn signInService(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::SignInServiceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::SignInServiceError>>;

        fn signOutService(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::SignOutServiceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::SignOutServiceError>>;

        fn listServiceClients(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListServiceClientsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListServiceClientsResp, crate::fbthrift_protocol::meta::errors::meta_service::ListServiceClientsError>>;

        fn createFTIndex(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateFTIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateFTIndexError>>;

        fn dropFTIndex(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropFTIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropFTIndexError>>;

        fn listFTIndexes(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListFTIndexesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListFTIndexesResp, crate::fbthrift_protocol::meta::errors::meta_service::ListFTIndexesError>>;

        fn createSession(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateSessionReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::CreateSessionResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateSessionError>>;

        fn updateSessions(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::UpdateSessionsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::UpdateSessionsResp, crate::fbthrift_protocol::meta::errors::meta_service::UpdateSessionsError>>;

        fn listSessions(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListSessionsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListSessionsResp, crate::fbthrift_protocol::meta::errors::meta_service::ListSessionsError>>;

        fn getSession(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetSessionReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetSessionResp, crate::fbthrift_protocol::meta::errors::meta_service::GetSessionError>>;

        fn removeSession(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::RemoveSessionReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::RemoveSessionError>>;

        fn killQuery(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::KillQueryReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::KillQueryError>>;

        fn reportTaskFinish(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ReportTaskReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::ReportTaskFinishError>>;

        fn createBackup(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateBackupReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::CreateBackupResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateBackupError>>;

        fn restoreMeta(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::RestoreMetaReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::RestoreMetaResp, crate::fbthrift_protocol::meta::errors::meta_service::RestoreMetaError>>;

        fn listCluster(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListClusterInfoReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListClusterInfoResp, crate::fbthrift_protocol::meta::errors::meta_service::ListClusterError>>;

        fn getMetaDirInfo(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetMetaDirInfoReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetMetaDirInfoResp, crate::fbthrift_protocol::meta::errors::meta_service::GetMetaDirInfoError>>;

        fn verifyClientVersion(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::VerifyClientVersionReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::VerifyClientVersionResp, crate::fbthrift_protocol::meta::errors::meta_service::VerifyClientVersionError>>;

        fn saveGraphVersion(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::SaveGraphVersionReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::SaveGraphVersionResp, crate::fbthrift_protocol::meta::errors::meta_service::SaveGraphVersionError>>;

        fn getSegmentId(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetSegmentIdReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetSegmentIdResp, crate::fbthrift_protocol::meta::errors::meta_service::GetSegmentIdError>>;
    }

    pub trait MetaServiceExt<T>: MetaService
    where
        T: crate::fbthrift::Transport,
    {
        fn createSpace_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateSpaceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateSpaceError>>;
        fn dropSpace_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropSpaceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropSpaceError>>;
        fn clearSpace_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ClearSpaceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::ClearSpaceError>>;
        fn getSpace_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetSpaceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetSpaceResp, crate::fbthrift_protocol::meta::errors::meta_service::GetSpaceError>>;
        fn listSpaces_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListSpacesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListSpacesResp, crate::fbthrift_protocol::meta::errors::meta_service::ListSpacesError>>;
        fn alterSpace_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::AlterSpaceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::AlterSpaceError>>;
        fn createSpaceAs_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateSpaceAsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateSpaceAsError>>;
        fn createTag_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateTagReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateTagError>>;
        fn alterTag_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::AlterTagReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::AlterTagError>>;
        fn dropTag_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropTagReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropTagError>>;
        fn getTag_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetTagReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetTagResp, crate::fbthrift_protocol::meta::errors::meta_service::GetTagError>>;
        fn listTags_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListTagsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListTagsResp, crate::fbthrift_protocol::meta::errors::meta_service::ListTagsError>>;
        fn createEdge_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateEdgeReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateEdgeError>>;
        fn alterEdge_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::AlterEdgeReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::AlterEdgeError>>;
        fn dropEdge_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropEdgeReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropEdgeError>>;
        fn getEdge_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetEdgeReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetEdgeResp, crate::fbthrift_protocol::meta::errors::meta_service::GetEdgeError>>;
        fn listEdges_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListEdgesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListEdgesResp, crate::fbthrift_protocol::meta::errors::meta_service::ListEdgesError>>;
        fn addHosts_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::AddHostsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::AddHostsError>>;
        fn addHostsIntoZone_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::AddHostsIntoZoneReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::AddHostsIntoZoneError>>;
        fn dropHosts_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropHostsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropHostsError>>;
        fn listHosts_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListHostsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListHostsResp, crate::fbthrift_protocol::meta::errors::meta_service::ListHostsError>>;
        fn getPartsAlloc_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetPartsAllocReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetPartsAllocResp, crate::fbthrift_protocol::meta::errors::meta_service::GetPartsAllocError>>;
        fn listParts_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListPartsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListPartsResp, crate::fbthrift_protocol::meta::errors::meta_service::ListPartsError>>;
        fn getWorkerId_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetWorkerIdReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetWorkerIdResp, crate::fbthrift_protocol::meta::errors::meta_service::GetWorkerIdError>>;
        fn createTagIndex_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateTagIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateTagIndexError>>;
        fn dropTagIndex_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropTagIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropTagIndexError>>;
        fn getTagIndex_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetTagIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetTagIndexResp, crate::fbthrift_protocol::meta::errors::meta_service::GetTagIndexError>>;
        fn listTagIndexes_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListTagIndexesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListTagIndexesResp, crate::fbthrift_protocol::meta::errors::meta_service::ListTagIndexesError>>;
        fn rebuildTagIndex_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::RebuildIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::RebuildTagIndexError>>;
        fn listTagIndexStatus_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListIndexStatusReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListIndexStatusResp, crate::fbthrift_protocol::meta::errors::meta_service::ListTagIndexStatusError>>;
        fn createEdgeIndex_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateEdgeIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateEdgeIndexError>>;
        fn dropEdgeIndex_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropEdgeIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropEdgeIndexError>>;
        fn getEdgeIndex_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetEdgeIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetEdgeIndexResp, crate::fbthrift_protocol::meta::errors::meta_service::GetEdgeIndexError>>;
        fn listEdgeIndexes_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListEdgeIndexesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListEdgeIndexesResp, crate::fbthrift_protocol::meta::errors::meta_service::ListEdgeIndexesError>>;
        fn rebuildEdgeIndex_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::RebuildIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::RebuildEdgeIndexError>>;
        fn listEdgeIndexStatus_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListIndexStatusReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListIndexStatusResp, crate::fbthrift_protocol::meta::errors::meta_service::ListEdgeIndexStatusError>>;
        fn createUser_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateUserReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateUserError>>;
        fn dropUser_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropUserReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropUserError>>;
        fn alterUser_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::AlterUserReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::AlterUserError>>;
        fn grantRole_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GrantRoleReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::GrantRoleError>>;
        fn revokeRole_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::RevokeRoleReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::RevokeRoleError>>;
        fn listUsers_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListUsersReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListUsersResp, crate::fbthrift_protocol::meta::errors::meta_service::ListUsersError>>;
        fn listRoles_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListRolesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListRolesResp, crate::fbthrift_protocol::meta::errors::meta_service::ListRolesError>>;
        fn getUserRoles_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetUserRolesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListRolesResp, crate::fbthrift_protocol::meta::errors::meta_service::GetUserRolesError>>;
        fn changePassword_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ChangePasswordReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::ChangePasswordError>>;
        fn heartBeat_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::HBReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::HBResp, crate::fbthrift_protocol::meta::errors::meta_service::HeartBeatError>>;
        fn agentHeartbeat_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::AgentHBReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::AgentHBResp, crate::fbthrift_protocol::meta::errors::meta_service::AgentHeartbeatError>>;
        fn regConfig_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::RegConfigReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::RegConfigError>>;
        fn getConfig_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetConfigReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetConfigResp, crate::fbthrift_protocol::meta::errors::meta_service::GetConfigError>>;
        fn setConfig_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::SetConfigReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::SetConfigError>>;
        fn listConfigs_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListConfigsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListConfigsResp, crate::fbthrift_protocol::meta::errors::meta_service::ListConfigsError>>;
        fn createSnapshot_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateSnapshotReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateSnapshotError>>;
        fn dropSnapshot_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropSnapshotReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropSnapshotError>>;
        fn listSnapshots_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListSnapshotsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListSnapshotsResp, crate::fbthrift_protocol::meta::errors::meta_service::ListSnapshotsError>>;
        fn runAdminJob_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::AdminJobReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::AdminJobResp, crate::fbthrift_protocol::meta::errors::meta_service::RunAdminJobError>>;
        fn mergeZone_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::MergeZoneReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::MergeZoneError>>;
        fn dropZone_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropZoneReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropZoneError>>;
        fn divideZone_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DivideZoneReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DivideZoneError>>;
        fn renameZone_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::RenameZoneReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::RenameZoneError>>;
        fn getZone_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetZoneReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetZoneResp, crate::fbthrift_protocol::meta::errors::meta_service::GetZoneError>>;
        fn listZones_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListZonesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListZonesResp, crate::fbthrift_protocol::meta::errors::meta_service::ListZonesError>>;
        fn addListener_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::AddListenerReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::AddListenerError>>;
        fn removeListener_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::RemoveListenerReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::RemoveListenerError>>;
        fn listListener_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListListenerReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListListenerResp, crate::fbthrift_protocol::meta::errors::meta_service::ListListenerError>>;
        fn getStats_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetStatsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetStatsResp, crate::fbthrift_protocol::meta::errors::meta_service::GetStatsError>>;
        fn signInService_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::SignInServiceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::SignInServiceError>>;
        fn signOutService_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::SignOutServiceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::SignOutServiceError>>;
        fn listServiceClients_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListServiceClientsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListServiceClientsResp, crate::fbthrift_protocol::meta::errors::meta_service::ListServiceClientsError>>;
        fn createFTIndex_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateFTIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateFTIndexError>>;
        fn dropFTIndex_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropFTIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropFTIndexError>>;
        fn listFTIndexes_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListFTIndexesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListFTIndexesResp, crate::fbthrift_protocol::meta::errors::meta_service::ListFTIndexesError>>;
        fn createSession_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateSessionReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::CreateSessionResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateSessionError>>;
        fn updateSessions_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::UpdateSessionsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::UpdateSessionsResp, crate::fbthrift_protocol::meta::errors::meta_service::UpdateSessionsError>>;
        fn listSessions_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListSessionsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListSessionsResp, crate::fbthrift_protocol::meta::errors::meta_service::ListSessionsError>>;
        fn getSession_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetSessionReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetSessionResp, crate::fbthrift_protocol::meta::errors::meta_service::GetSessionError>>;
        fn removeSession_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::RemoveSessionReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::RemoveSessionError>>;
        fn killQuery_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::KillQueryReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::KillQueryError>>;
        fn reportTaskFinish_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ReportTaskReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::ReportTaskFinishError>>;
        fn createBackup_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateBackupReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::CreateBackupResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateBackupError>>;
        fn restoreMeta_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::RestoreMetaReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::RestoreMetaResp, crate::fbthrift_protocol::meta::errors::meta_service::RestoreMetaError>>;
        fn listCluster_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListClusterInfoReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListClusterInfoResp, crate::fbthrift_protocol::meta::errors::meta_service::ListClusterError>>;
        fn getMetaDirInfo_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetMetaDirInfoReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetMetaDirInfoResp, crate::fbthrift_protocol::meta::errors::meta_service::GetMetaDirInfoError>>;
        fn verifyClientVersion_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::VerifyClientVersionReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::VerifyClientVersionResp, crate::fbthrift_protocol::meta::errors::meta_service::VerifyClientVersionError>>;
        fn saveGraphVersion_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::SaveGraphVersionReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::SaveGraphVersionResp, crate::fbthrift_protocol::meta::errors::meta_service::SaveGraphVersionError>>;
        fn getSegmentId_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetSegmentIdReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetSegmentIdResp, crate::fbthrift_protocol::meta::errors::meta_service::GetSegmentIdError>>;
    }

    struct Args_MetaService_createSpace<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::CreateSpaceReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_createSpace<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.createSpace"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_dropSpace<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::DropSpaceReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_dropSpace<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.dropSpace"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_clearSpace<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::ClearSpaceReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_clearSpace<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.clearSpace"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_getSpace<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::GetSpaceReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_getSpace<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.getSpace"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_listSpaces<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::ListSpacesReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_listSpaces<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.listSpaces"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_alterSpace<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::AlterSpaceReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_alterSpace<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.alterSpace"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_createSpaceAs<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::CreateSpaceAsReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_createSpaceAs<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.createSpaceAs"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_createTag<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::CreateTagReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_createTag<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.createTag"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_alterTag<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::AlterTagReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_alterTag<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.alterTag"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_dropTag<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::DropTagReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_dropTag<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.dropTag"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_getTag<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::GetTagReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_getTag<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.getTag"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_listTags<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::ListTagsReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_listTags<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.listTags"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_createEdge<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::CreateEdgeReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_createEdge<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.createEdge"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_alterEdge<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::AlterEdgeReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_alterEdge<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.alterEdge"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_dropEdge<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::DropEdgeReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_dropEdge<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.dropEdge"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_getEdge<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::GetEdgeReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_getEdge<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.getEdge"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_listEdges<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::ListEdgesReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_listEdges<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.listEdges"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_addHosts<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::AddHostsReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_addHosts<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.addHosts"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_addHostsIntoZone<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::AddHostsIntoZoneReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_addHostsIntoZone<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.addHostsIntoZone"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_dropHosts<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::DropHostsReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_dropHosts<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.dropHosts"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_listHosts<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::ListHostsReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_listHosts<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.listHosts"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_getPartsAlloc<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::GetPartsAllocReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_getPartsAlloc<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.getPartsAlloc"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_listParts<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::ListPartsReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_listParts<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.listParts"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_getWorkerId<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::GetWorkerIdReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_getWorkerId<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.getWorkerId"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_createTagIndex<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::CreateTagIndexReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_createTagIndex<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.createTagIndex"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_dropTagIndex<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::DropTagIndexReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_dropTagIndex<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.dropTagIndex"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_getTagIndex<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::GetTagIndexReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_getTagIndex<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.getTagIndex"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_listTagIndexes<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::ListTagIndexesReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_listTagIndexes<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.listTagIndexes"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_rebuildTagIndex<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::RebuildIndexReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_rebuildTagIndex<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.rebuildTagIndex"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_listTagIndexStatus<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::ListIndexStatusReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_listTagIndexStatus<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.listTagIndexStatus"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_createEdgeIndex<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::CreateEdgeIndexReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_createEdgeIndex<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.createEdgeIndex"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_dropEdgeIndex<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::DropEdgeIndexReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_dropEdgeIndex<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.dropEdgeIndex"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_getEdgeIndex<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::GetEdgeIndexReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_getEdgeIndex<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.getEdgeIndex"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_listEdgeIndexes<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::ListEdgeIndexesReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_listEdgeIndexes<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.listEdgeIndexes"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_rebuildEdgeIndex<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::RebuildIndexReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_rebuildEdgeIndex<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.rebuildEdgeIndex"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_listEdgeIndexStatus<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::ListIndexStatusReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_listEdgeIndexStatus<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.listEdgeIndexStatus"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_createUser<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::CreateUserReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_createUser<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.createUser"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_dropUser<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::DropUserReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_dropUser<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.dropUser"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_alterUser<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::AlterUserReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_alterUser<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.alterUser"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_grantRole<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::GrantRoleReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_grantRole<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.grantRole"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_revokeRole<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::RevokeRoleReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_revokeRole<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.revokeRole"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_listUsers<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::ListUsersReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_listUsers<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.listUsers"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_listRoles<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::ListRolesReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_listRoles<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.listRoles"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_getUserRoles<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::GetUserRolesReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_getUserRoles<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.getUserRoles"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_changePassword<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::ChangePasswordReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_changePassword<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.changePassword"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_heartBeat<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::HBReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_heartBeat<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.heartBeat"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_agentHeartbeat<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::AgentHBReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_agentHeartbeat<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.agentHeartbeat"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_regConfig<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::RegConfigReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_regConfig<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.regConfig"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_getConfig<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::GetConfigReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_getConfig<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.getConfig"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_setConfig<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::SetConfigReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_setConfig<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.setConfig"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_listConfigs<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::ListConfigsReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_listConfigs<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.listConfigs"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_createSnapshot<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::CreateSnapshotReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_createSnapshot<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.createSnapshot"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_dropSnapshot<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::DropSnapshotReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_dropSnapshot<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.dropSnapshot"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_listSnapshots<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::ListSnapshotsReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_listSnapshots<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.listSnapshots"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_runAdminJob<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::AdminJobReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_runAdminJob<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.runAdminJob"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_mergeZone<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::MergeZoneReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_mergeZone<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.mergeZone"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_dropZone<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::DropZoneReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_dropZone<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.dropZone"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_divideZone<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::DivideZoneReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_divideZone<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.divideZone"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_renameZone<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::RenameZoneReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_renameZone<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.renameZone"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_getZone<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::GetZoneReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_getZone<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.getZone"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_listZones<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::ListZonesReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_listZones<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.listZones"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_addListener<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::AddListenerReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_addListener<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.addListener"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_removeListener<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::RemoveListenerReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_removeListener<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.removeListener"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_listListener<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::ListListenerReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_listListener<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.listListener"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_getStats<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::GetStatsReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_getStats<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.getStats"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_signInService<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::SignInServiceReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_signInService<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.signInService"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_signOutService<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::SignOutServiceReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_signOutService<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.signOutService"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_listServiceClients<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::ListServiceClientsReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_listServiceClients<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.listServiceClients"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_createFTIndex<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::CreateFTIndexReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_createFTIndex<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.createFTIndex"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_dropFTIndex<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::DropFTIndexReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_dropFTIndex<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.dropFTIndex"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_listFTIndexes<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::ListFTIndexesReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_listFTIndexes<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.listFTIndexes"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_createSession<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::CreateSessionReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_createSession<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.createSession"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_updateSessions<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::UpdateSessionsReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_updateSessions<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.updateSessions"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_listSessions<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::ListSessionsReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_listSessions<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.listSessions"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_getSession<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::GetSessionReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_getSession<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.getSession"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_removeSession<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::RemoveSessionReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_removeSession<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.removeSession"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_killQuery<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::KillQueryReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_killQuery<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.killQuery"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_reportTaskFinish<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::ReportTaskReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_reportTaskFinish<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.reportTaskFinish"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_createBackup<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::CreateBackupReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_createBackup<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.createBackup"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_restoreMeta<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::RestoreMetaReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_restoreMeta<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.restoreMeta"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_listCluster<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::ListClusterInfoReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_listCluster<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.listCluster"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_getMetaDirInfo<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::GetMetaDirInfoReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_getMetaDirInfo<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.getMetaDirInfo"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_verifyClientVersion<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::VerifyClientVersionReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_verifyClientVersion<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.verifyClientVersion"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_saveGraphVersion<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::SaveGraphVersionReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_saveGraphVersion<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.saveGraphVersion"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_MetaService_getSegmentId<'a> {
        req: &'a crate::fbthrift_protocol::meta::types::GetSegmentIdReq,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: crate::fbthrift::ProtocolWriter> crate::fbthrift::Serialize<P> for self::Args_MetaService_getSegmentId<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "MetaService.getSegmentId"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("req", crate::fbthrift::TType::Struct, 1i16);
            crate::fbthrift::Serialize::write(&self.req, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P, T, S> MetaService for MetaServiceImpl<P, T, S>
    where
        P: crate::fbthrift::Protocol,
        T: crate::fbthrift::Transport,
        P::Frame: crate::fbthrift::Framing<DecBuf = crate::fbthrift::FramingDecoded<T>>,
        crate::fbthrift::ProtocolEncoded<P>: crate::fbthrift::BufMutExt<Final = crate::fbthrift::FramingEncodedFinal<T>>,
        P::Deserializer: ::std::marker::Send,
        S: crate::fbthrift::help::Spawner,
    {
        fn createSpace(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateSpaceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateSpaceError>> {
            let rpc_options = T::RpcOptions::default();
            self._createSpace_impl(
                arg_req,
                rpc_options,
            )
        }
        fn dropSpace(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropSpaceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropSpaceError>> {
            let rpc_options = T::RpcOptions::default();
            self._dropSpace_impl(
                arg_req,
                rpc_options,
            )
        }
        fn clearSpace(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ClearSpaceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::ClearSpaceError>> {
            let rpc_options = T::RpcOptions::default();
            self._clearSpace_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getSpace(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetSpaceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetSpaceResp, crate::fbthrift_protocol::meta::errors::meta_service::GetSpaceError>> {
            let rpc_options = T::RpcOptions::default();
            self._getSpace_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listSpaces(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListSpacesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListSpacesResp, crate::fbthrift_protocol::meta::errors::meta_service::ListSpacesError>> {
            let rpc_options = T::RpcOptions::default();
            self._listSpaces_impl(
                arg_req,
                rpc_options,
            )
        }
        fn alterSpace(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::AlterSpaceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::AlterSpaceError>> {
            let rpc_options = T::RpcOptions::default();
            self._alterSpace_impl(
                arg_req,
                rpc_options,
            )
        }
        fn createSpaceAs(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateSpaceAsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateSpaceAsError>> {
            let rpc_options = T::RpcOptions::default();
            self._createSpaceAs_impl(
                arg_req,
                rpc_options,
            )
        }
        fn createTag(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateTagReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateTagError>> {
            let rpc_options = T::RpcOptions::default();
            self._createTag_impl(
                arg_req,
                rpc_options,
            )
        }
        fn alterTag(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::AlterTagReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::AlterTagError>> {
            let rpc_options = T::RpcOptions::default();
            self._alterTag_impl(
                arg_req,
                rpc_options,
            )
        }
        fn dropTag(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropTagReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropTagError>> {
            let rpc_options = T::RpcOptions::default();
            self._dropTag_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getTag(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetTagReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetTagResp, crate::fbthrift_protocol::meta::errors::meta_service::GetTagError>> {
            let rpc_options = T::RpcOptions::default();
            self._getTag_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listTags(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListTagsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListTagsResp, crate::fbthrift_protocol::meta::errors::meta_service::ListTagsError>> {
            let rpc_options = T::RpcOptions::default();
            self._listTags_impl(
                arg_req,
                rpc_options,
            )
        }
        fn createEdge(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateEdgeReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateEdgeError>> {
            let rpc_options = T::RpcOptions::default();
            self._createEdge_impl(
                arg_req,
                rpc_options,
            )
        }
        fn alterEdge(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::AlterEdgeReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::AlterEdgeError>> {
            let rpc_options = T::RpcOptions::default();
            self._alterEdge_impl(
                arg_req,
                rpc_options,
            )
        }
        fn dropEdge(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropEdgeReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropEdgeError>> {
            let rpc_options = T::RpcOptions::default();
            self._dropEdge_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getEdge(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetEdgeReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetEdgeResp, crate::fbthrift_protocol::meta::errors::meta_service::GetEdgeError>> {
            let rpc_options = T::RpcOptions::default();
            self._getEdge_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listEdges(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListEdgesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListEdgesResp, crate::fbthrift_protocol::meta::errors::meta_service::ListEdgesError>> {
            let rpc_options = T::RpcOptions::default();
            self._listEdges_impl(
                arg_req,
                rpc_options,
            )
        }
        fn addHosts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::AddHostsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::AddHostsError>> {
            let rpc_options = T::RpcOptions::default();
            self._addHosts_impl(
                arg_req,
                rpc_options,
            )
        }
        fn addHostsIntoZone(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::AddHostsIntoZoneReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::AddHostsIntoZoneError>> {
            let rpc_options = T::RpcOptions::default();
            self._addHostsIntoZone_impl(
                arg_req,
                rpc_options,
            )
        }
        fn dropHosts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropHostsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropHostsError>> {
            let rpc_options = T::RpcOptions::default();
            self._dropHosts_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listHosts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListHostsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListHostsResp, crate::fbthrift_protocol::meta::errors::meta_service::ListHostsError>> {
            let rpc_options = T::RpcOptions::default();
            self._listHosts_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getPartsAlloc(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetPartsAllocReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetPartsAllocResp, crate::fbthrift_protocol::meta::errors::meta_service::GetPartsAllocError>> {
            let rpc_options = T::RpcOptions::default();
            self._getPartsAlloc_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listParts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListPartsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListPartsResp, crate::fbthrift_protocol::meta::errors::meta_service::ListPartsError>> {
            let rpc_options = T::RpcOptions::default();
            self._listParts_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getWorkerId(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetWorkerIdReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetWorkerIdResp, crate::fbthrift_protocol::meta::errors::meta_service::GetWorkerIdError>> {
            let rpc_options = T::RpcOptions::default();
            self._getWorkerId_impl(
                arg_req,
                rpc_options,
            )
        }
        fn createTagIndex(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateTagIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateTagIndexError>> {
            let rpc_options = T::RpcOptions::default();
            self._createTagIndex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn dropTagIndex(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropTagIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropTagIndexError>> {
            let rpc_options = T::RpcOptions::default();
            self._dropTagIndex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getTagIndex(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetTagIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetTagIndexResp, crate::fbthrift_protocol::meta::errors::meta_service::GetTagIndexError>> {
            let rpc_options = T::RpcOptions::default();
            self._getTagIndex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listTagIndexes(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListTagIndexesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListTagIndexesResp, crate::fbthrift_protocol::meta::errors::meta_service::ListTagIndexesError>> {
            let rpc_options = T::RpcOptions::default();
            self._listTagIndexes_impl(
                arg_req,
                rpc_options,
            )
        }
        fn rebuildTagIndex(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::RebuildIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::RebuildTagIndexError>> {
            let rpc_options = T::RpcOptions::default();
            self._rebuildTagIndex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listTagIndexStatus(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListIndexStatusReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListIndexStatusResp, crate::fbthrift_protocol::meta::errors::meta_service::ListTagIndexStatusError>> {
            let rpc_options = T::RpcOptions::default();
            self._listTagIndexStatus_impl(
                arg_req,
                rpc_options,
            )
        }
        fn createEdgeIndex(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateEdgeIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateEdgeIndexError>> {
            let rpc_options = T::RpcOptions::default();
            self._createEdgeIndex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn dropEdgeIndex(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropEdgeIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropEdgeIndexError>> {
            let rpc_options = T::RpcOptions::default();
            self._dropEdgeIndex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getEdgeIndex(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetEdgeIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetEdgeIndexResp, crate::fbthrift_protocol::meta::errors::meta_service::GetEdgeIndexError>> {
            let rpc_options = T::RpcOptions::default();
            self._getEdgeIndex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listEdgeIndexes(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListEdgeIndexesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListEdgeIndexesResp, crate::fbthrift_protocol::meta::errors::meta_service::ListEdgeIndexesError>> {
            let rpc_options = T::RpcOptions::default();
            self._listEdgeIndexes_impl(
                arg_req,
                rpc_options,
            )
        }
        fn rebuildEdgeIndex(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::RebuildIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::RebuildEdgeIndexError>> {
            let rpc_options = T::RpcOptions::default();
            self._rebuildEdgeIndex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listEdgeIndexStatus(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListIndexStatusReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListIndexStatusResp, crate::fbthrift_protocol::meta::errors::meta_service::ListEdgeIndexStatusError>> {
            let rpc_options = T::RpcOptions::default();
            self._listEdgeIndexStatus_impl(
                arg_req,
                rpc_options,
            )
        }
        fn createUser(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateUserReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateUserError>> {
            let rpc_options = T::RpcOptions::default();
            self._createUser_impl(
                arg_req,
                rpc_options,
            )
        }
        fn dropUser(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropUserReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropUserError>> {
            let rpc_options = T::RpcOptions::default();
            self._dropUser_impl(
                arg_req,
                rpc_options,
            )
        }
        fn alterUser(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::AlterUserReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::AlterUserError>> {
            let rpc_options = T::RpcOptions::default();
            self._alterUser_impl(
                arg_req,
                rpc_options,
            )
        }
        fn grantRole(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GrantRoleReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::GrantRoleError>> {
            let rpc_options = T::RpcOptions::default();
            self._grantRole_impl(
                arg_req,
                rpc_options,
            )
        }
        fn revokeRole(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::RevokeRoleReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::RevokeRoleError>> {
            let rpc_options = T::RpcOptions::default();
            self._revokeRole_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listUsers(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListUsersReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListUsersResp, crate::fbthrift_protocol::meta::errors::meta_service::ListUsersError>> {
            let rpc_options = T::RpcOptions::default();
            self._listUsers_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listRoles(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListRolesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListRolesResp, crate::fbthrift_protocol::meta::errors::meta_service::ListRolesError>> {
            let rpc_options = T::RpcOptions::default();
            self._listRoles_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getUserRoles(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetUserRolesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListRolesResp, crate::fbthrift_protocol::meta::errors::meta_service::GetUserRolesError>> {
            let rpc_options = T::RpcOptions::default();
            self._getUserRoles_impl(
                arg_req,
                rpc_options,
            )
        }
        fn changePassword(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ChangePasswordReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::ChangePasswordError>> {
            let rpc_options = T::RpcOptions::default();
            self._changePassword_impl(
                arg_req,
                rpc_options,
            )
        }
        fn heartBeat(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::HBReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::HBResp, crate::fbthrift_protocol::meta::errors::meta_service::HeartBeatError>> {
            let rpc_options = T::RpcOptions::default();
            self._heartBeat_impl(
                arg_req,
                rpc_options,
            )
        }
        fn agentHeartbeat(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::AgentHBReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::AgentHBResp, crate::fbthrift_protocol::meta::errors::meta_service::AgentHeartbeatError>> {
            let rpc_options = T::RpcOptions::default();
            self._agentHeartbeat_impl(
                arg_req,
                rpc_options,
            )
        }
        fn regConfig(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::RegConfigReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::RegConfigError>> {
            let rpc_options = T::RpcOptions::default();
            self._regConfig_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getConfig(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetConfigReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetConfigResp, crate::fbthrift_protocol::meta::errors::meta_service::GetConfigError>> {
            let rpc_options = T::RpcOptions::default();
            self._getConfig_impl(
                arg_req,
                rpc_options,
            )
        }
        fn setConfig(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::SetConfigReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::SetConfigError>> {
            let rpc_options = T::RpcOptions::default();
            self._setConfig_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listConfigs(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListConfigsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListConfigsResp, crate::fbthrift_protocol::meta::errors::meta_service::ListConfigsError>> {
            let rpc_options = T::RpcOptions::default();
            self._listConfigs_impl(
                arg_req,
                rpc_options,
            )
        }
        fn createSnapshot(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateSnapshotReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateSnapshotError>> {
            let rpc_options = T::RpcOptions::default();
            self._createSnapshot_impl(
                arg_req,
                rpc_options,
            )
        }
        fn dropSnapshot(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropSnapshotReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropSnapshotError>> {
            let rpc_options = T::RpcOptions::default();
            self._dropSnapshot_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listSnapshots(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListSnapshotsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListSnapshotsResp, crate::fbthrift_protocol::meta::errors::meta_service::ListSnapshotsError>> {
            let rpc_options = T::RpcOptions::default();
            self._listSnapshots_impl(
                arg_req,
                rpc_options,
            )
        }
        fn runAdminJob(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::AdminJobReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::AdminJobResp, crate::fbthrift_protocol::meta::errors::meta_service::RunAdminJobError>> {
            let rpc_options = T::RpcOptions::default();
            self._runAdminJob_impl(
                arg_req,
                rpc_options,
            )
        }
        fn mergeZone(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::MergeZoneReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::MergeZoneError>> {
            let rpc_options = T::RpcOptions::default();
            self._mergeZone_impl(
                arg_req,
                rpc_options,
            )
        }
        fn dropZone(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropZoneReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropZoneError>> {
            let rpc_options = T::RpcOptions::default();
            self._dropZone_impl(
                arg_req,
                rpc_options,
            )
        }
        fn divideZone(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DivideZoneReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DivideZoneError>> {
            let rpc_options = T::RpcOptions::default();
            self._divideZone_impl(
                arg_req,
                rpc_options,
            )
        }
        fn renameZone(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::RenameZoneReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::RenameZoneError>> {
            let rpc_options = T::RpcOptions::default();
            self._renameZone_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getZone(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetZoneReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetZoneResp, crate::fbthrift_protocol::meta::errors::meta_service::GetZoneError>> {
            let rpc_options = T::RpcOptions::default();
            self._getZone_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listZones(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListZonesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListZonesResp, crate::fbthrift_protocol::meta::errors::meta_service::ListZonesError>> {
            let rpc_options = T::RpcOptions::default();
            self._listZones_impl(
                arg_req,
                rpc_options,
            )
        }
        fn addListener(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::AddListenerReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::AddListenerError>> {
            let rpc_options = T::RpcOptions::default();
            self._addListener_impl(
                arg_req,
                rpc_options,
            )
        }
        fn removeListener(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::RemoveListenerReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::RemoveListenerError>> {
            let rpc_options = T::RpcOptions::default();
            self._removeListener_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listListener(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListListenerReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListListenerResp, crate::fbthrift_protocol::meta::errors::meta_service::ListListenerError>> {
            let rpc_options = T::RpcOptions::default();
            self._listListener_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getStats(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetStatsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetStatsResp, crate::fbthrift_protocol::meta::errors::meta_service::GetStatsError>> {
            let rpc_options = T::RpcOptions::default();
            self._getStats_impl(
                arg_req,
                rpc_options,
            )
        }
        fn signInService(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::SignInServiceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::SignInServiceError>> {
            let rpc_options = T::RpcOptions::default();
            self._signInService_impl(
                arg_req,
                rpc_options,
            )
        }
        fn signOutService(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::SignOutServiceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::SignOutServiceError>> {
            let rpc_options = T::RpcOptions::default();
            self._signOutService_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listServiceClients(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListServiceClientsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListServiceClientsResp, crate::fbthrift_protocol::meta::errors::meta_service::ListServiceClientsError>> {
            let rpc_options = T::RpcOptions::default();
            self._listServiceClients_impl(
                arg_req,
                rpc_options,
            )
        }
        fn createFTIndex(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateFTIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateFTIndexError>> {
            let rpc_options = T::RpcOptions::default();
            self._createFTIndex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn dropFTIndex(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropFTIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropFTIndexError>> {
            let rpc_options = T::RpcOptions::default();
            self._dropFTIndex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listFTIndexes(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListFTIndexesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListFTIndexesResp, crate::fbthrift_protocol::meta::errors::meta_service::ListFTIndexesError>> {
            let rpc_options = T::RpcOptions::default();
            self._listFTIndexes_impl(
                arg_req,
                rpc_options,
            )
        }
        fn createSession(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateSessionReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::CreateSessionResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateSessionError>> {
            let rpc_options = T::RpcOptions::default();
            self._createSession_impl(
                arg_req,
                rpc_options,
            )
        }
        fn updateSessions(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::UpdateSessionsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::UpdateSessionsResp, crate::fbthrift_protocol::meta::errors::meta_service::UpdateSessionsError>> {
            let rpc_options = T::RpcOptions::default();
            self._updateSessions_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listSessions(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListSessionsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListSessionsResp, crate::fbthrift_protocol::meta::errors::meta_service::ListSessionsError>> {
            let rpc_options = T::RpcOptions::default();
            self._listSessions_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getSession(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetSessionReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetSessionResp, crate::fbthrift_protocol::meta::errors::meta_service::GetSessionError>> {
            let rpc_options = T::RpcOptions::default();
            self._getSession_impl(
                arg_req,
                rpc_options,
            )
        }
        fn removeSession(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::RemoveSessionReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::RemoveSessionError>> {
            let rpc_options = T::RpcOptions::default();
            self._removeSession_impl(
                arg_req,
                rpc_options,
            )
        }
        fn killQuery(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::KillQueryReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::KillQueryError>> {
            let rpc_options = T::RpcOptions::default();
            self._killQuery_impl(
                arg_req,
                rpc_options,
            )
        }
        fn reportTaskFinish(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ReportTaskReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::ReportTaskFinishError>> {
            let rpc_options = T::RpcOptions::default();
            self._reportTaskFinish_impl(
                arg_req,
                rpc_options,
            )
        }
        fn createBackup(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateBackupReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::CreateBackupResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateBackupError>> {
            let rpc_options = T::RpcOptions::default();
            self._createBackup_impl(
                arg_req,
                rpc_options,
            )
        }
        fn restoreMeta(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::RestoreMetaReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::RestoreMetaResp, crate::fbthrift_protocol::meta::errors::meta_service::RestoreMetaError>> {
            let rpc_options = T::RpcOptions::default();
            self._restoreMeta_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listCluster(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListClusterInfoReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListClusterInfoResp, crate::fbthrift_protocol::meta::errors::meta_service::ListClusterError>> {
            let rpc_options = T::RpcOptions::default();
            self._listCluster_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getMetaDirInfo(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetMetaDirInfoReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetMetaDirInfoResp, crate::fbthrift_protocol::meta::errors::meta_service::GetMetaDirInfoError>> {
            let rpc_options = T::RpcOptions::default();
            self._getMetaDirInfo_impl(
                arg_req,
                rpc_options,
            )
        }
        fn verifyClientVersion(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::VerifyClientVersionReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::VerifyClientVersionResp, crate::fbthrift_protocol::meta::errors::meta_service::VerifyClientVersionError>> {
            let rpc_options = T::RpcOptions::default();
            self._verifyClientVersion_impl(
                arg_req,
                rpc_options,
            )
        }
        fn saveGraphVersion(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::SaveGraphVersionReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::SaveGraphVersionResp, crate::fbthrift_protocol::meta::errors::meta_service::SaveGraphVersionError>> {
            let rpc_options = T::RpcOptions::default();
            self._saveGraphVersion_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getSegmentId(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetSegmentIdReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetSegmentIdResp, crate::fbthrift_protocol::meta::errors::meta_service::GetSegmentIdError>> {
            let rpc_options = T::RpcOptions::default();
            self._getSegmentId_impl(
                arg_req,
                rpc_options,
            )
        }
    }

    impl<P, T, S> MetaServiceExt<T> for MetaServiceImpl<P, T, S>
    where
        P: crate::fbthrift::Protocol,
        T: crate::fbthrift::Transport,
        P::Frame: crate::fbthrift::Framing<DecBuf = crate::fbthrift::FramingDecoded<T>>,
        crate::fbthrift::ProtocolEncoded<P>: crate::fbthrift::BufMutExt<Final = crate::fbthrift::FramingEncodedFinal<T>>,
        P::Deserializer: ::std::marker::Send,
        S: crate::fbthrift::help::Spawner,
    {
        fn createSpace_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateSpaceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateSpaceError>> {
            self._createSpace_impl(
                arg_req,
                rpc_options,
            )
        }
        fn dropSpace_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropSpaceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropSpaceError>> {
            self._dropSpace_impl(
                arg_req,
                rpc_options,
            )
        }
        fn clearSpace_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ClearSpaceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::ClearSpaceError>> {
            self._clearSpace_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getSpace_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetSpaceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetSpaceResp, crate::fbthrift_protocol::meta::errors::meta_service::GetSpaceError>> {
            self._getSpace_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listSpaces_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListSpacesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListSpacesResp, crate::fbthrift_protocol::meta::errors::meta_service::ListSpacesError>> {
            self._listSpaces_impl(
                arg_req,
                rpc_options,
            )
        }
        fn alterSpace_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::AlterSpaceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::AlterSpaceError>> {
            self._alterSpace_impl(
                arg_req,
                rpc_options,
            )
        }
        fn createSpaceAs_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateSpaceAsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateSpaceAsError>> {
            self._createSpaceAs_impl(
                arg_req,
                rpc_options,
            )
        }
        fn createTag_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateTagReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateTagError>> {
            self._createTag_impl(
                arg_req,
                rpc_options,
            )
        }
        fn alterTag_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::AlterTagReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::AlterTagError>> {
            self._alterTag_impl(
                arg_req,
                rpc_options,
            )
        }
        fn dropTag_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropTagReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropTagError>> {
            self._dropTag_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getTag_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetTagReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetTagResp, crate::fbthrift_protocol::meta::errors::meta_service::GetTagError>> {
            self._getTag_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listTags_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListTagsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListTagsResp, crate::fbthrift_protocol::meta::errors::meta_service::ListTagsError>> {
            self._listTags_impl(
                arg_req,
                rpc_options,
            )
        }
        fn createEdge_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateEdgeReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateEdgeError>> {
            self._createEdge_impl(
                arg_req,
                rpc_options,
            )
        }
        fn alterEdge_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::AlterEdgeReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::AlterEdgeError>> {
            self._alterEdge_impl(
                arg_req,
                rpc_options,
            )
        }
        fn dropEdge_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropEdgeReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropEdgeError>> {
            self._dropEdge_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getEdge_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetEdgeReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetEdgeResp, crate::fbthrift_protocol::meta::errors::meta_service::GetEdgeError>> {
            self._getEdge_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listEdges_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListEdgesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListEdgesResp, crate::fbthrift_protocol::meta::errors::meta_service::ListEdgesError>> {
            self._listEdges_impl(
                arg_req,
                rpc_options,
            )
        }
        fn addHosts_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::AddHostsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::AddHostsError>> {
            self._addHosts_impl(
                arg_req,
                rpc_options,
            )
        }
        fn addHostsIntoZone_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::AddHostsIntoZoneReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::AddHostsIntoZoneError>> {
            self._addHostsIntoZone_impl(
                arg_req,
                rpc_options,
            )
        }
        fn dropHosts_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropHostsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropHostsError>> {
            self._dropHosts_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listHosts_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListHostsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListHostsResp, crate::fbthrift_protocol::meta::errors::meta_service::ListHostsError>> {
            self._listHosts_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getPartsAlloc_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetPartsAllocReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetPartsAllocResp, crate::fbthrift_protocol::meta::errors::meta_service::GetPartsAllocError>> {
            self._getPartsAlloc_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listParts_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListPartsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListPartsResp, crate::fbthrift_protocol::meta::errors::meta_service::ListPartsError>> {
            self._listParts_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getWorkerId_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetWorkerIdReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetWorkerIdResp, crate::fbthrift_protocol::meta::errors::meta_service::GetWorkerIdError>> {
            self._getWorkerId_impl(
                arg_req,
                rpc_options,
            )
        }
        fn createTagIndex_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateTagIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateTagIndexError>> {
            self._createTagIndex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn dropTagIndex_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropTagIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropTagIndexError>> {
            self._dropTagIndex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getTagIndex_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetTagIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetTagIndexResp, crate::fbthrift_protocol::meta::errors::meta_service::GetTagIndexError>> {
            self._getTagIndex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listTagIndexes_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListTagIndexesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListTagIndexesResp, crate::fbthrift_protocol::meta::errors::meta_service::ListTagIndexesError>> {
            self._listTagIndexes_impl(
                arg_req,
                rpc_options,
            )
        }
        fn rebuildTagIndex_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::RebuildIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::RebuildTagIndexError>> {
            self._rebuildTagIndex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listTagIndexStatus_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListIndexStatusReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListIndexStatusResp, crate::fbthrift_protocol::meta::errors::meta_service::ListTagIndexStatusError>> {
            self._listTagIndexStatus_impl(
                arg_req,
                rpc_options,
            )
        }
        fn createEdgeIndex_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateEdgeIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateEdgeIndexError>> {
            self._createEdgeIndex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn dropEdgeIndex_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropEdgeIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropEdgeIndexError>> {
            self._dropEdgeIndex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getEdgeIndex_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetEdgeIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetEdgeIndexResp, crate::fbthrift_protocol::meta::errors::meta_service::GetEdgeIndexError>> {
            self._getEdgeIndex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listEdgeIndexes_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListEdgeIndexesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListEdgeIndexesResp, crate::fbthrift_protocol::meta::errors::meta_service::ListEdgeIndexesError>> {
            self._listEdgeIndexes_impl(
                arg_req,
                rpc_options,
            )
        }
        fn rebuildEdgeIndex_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::RebuildIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::RebuildEdgeIndexError>> {
            self._rebuildEdgeIndex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listEdgeIndexStatus_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListIndexStatusReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListIndexStatusResp, crate::fbthrift_protocol::meta::errors::meta_service::ListEdgeIndexStatusError>> {
            self._listEdgeIndexStatus_impl(
                arg_req,
                rpc_options,
            )
        }
        fn createUser_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateUserReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateUserError>> {
            self._createUser_impl(
                arg_req,
                rpc_options,
            )
        }
        fn dropUser_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropUserReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropUserError>> {
            self._dropUser_impl(
                arg_req,
                rpc_options,
            )
        }
        fn alterUser_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::AlterUserReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::AlterUserError>> {
            self._alterUser_impl(
                arg_req,
                rpc_options,
            )
        }
        fn grantRole_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GrantRoleReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::GrantRoleError>> {
            self._grantRole_impl(
                arg_req,
                rpc_options,
            )
        }
        fn revokeRole_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::RevokeRoleReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::RevokeRoleError>> {
            self._revokeRole_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listUsers_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListUsersReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListUsersResp, crate::fbthrift_protocol::meta::errors::meta_service::ListUsersError>> {
            self._listUsers_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listRoles_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListRolesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListRolesResp, crate::fbthrift_protocol::meta::errors::meta_service::ListRolesError>> {
            self._listRoles_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getUserRoles_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetUserRolesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListRolesResp, crate::fbthrift_protocol::meta::errors::meta_service::GetUserRolesError>> {
            self._getUserRoles_impl(
                arg_req,
                rpc_options,
            )
        }
        fn changePassword_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ChangePasswordReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::ChangePasswordError>> {
            self._changePassword_impl(
                arg_req,
                rpc_options,
            )
        }
        fn heartBeat_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::HBReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::HBResp, crate::fbthrift_protocol::meta::errors::meta_service::HeartBeatError>> {
            self._heartBeat_impl(
                arg_req,
                rpc_options,
            )
        }
        fn agentHeartbeat_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::AgentHBReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::AgentHBResp, crate::fbthrift_protocol::meta::errors::meta_service::AgentHeartbeatError>> {
            self._agentHeartbeat_impl(
                arg_req,
                rpc_options,
            )
        }
        fn regConfig_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::RegConfigReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::RegConfigError>> {
            self._regConfig_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getConfig_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetConfigReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetConfigResp, crate::fbthrift_protocol::meta::errors::meta_service::GetConfigError>> {
            self._getConfig_impl(
                arg_req,
                rpc_options,
            )
        }
        fn setConfig_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::SetConfigReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::SetConfigError>> {
            self._setConfig_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listConfigs_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListConfigsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListConfigsResp, crate::fbthrift_protocol::meta::errors::meta_service::ListConfigsError>> {
            self._listConfigs_impl(
                arg_req,
                rpc_options,
            )
        }
        fn createSnapshot_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateSnapshotReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateSnapshotError>> {
            self._createSnapshot_impl(
                arg_req,
                rpc_options,
            )
        }
        fn dropSnapshot_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropSnapshotReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropSnapshotError>> {
            self._dropSnapshot_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listSnapshots_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListSnapshotsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListSnapshotsResp, crate::fbthrift_protocol::meta::errors::meta_service::ListSnapshotsError>> {
            self._listSnapshots_impl(
                arg_req,
                rpc_options,
            )
        }
        fn runAdminJob_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::AdminJobReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::AdminJobResp, crate::fbthrift_protocol::meta::errors::meta_service::RunAdminJobError>> {
            self._runAdminJob_impl(
                arg_req,
                rpc_options,
            )
        }
        fn mergeZone_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::MergeZoneReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::MergeZoneError>> {
            self._mergeZone_impl(
                arg_req,
                rpc_options,
            )
        }
        fn dropZone_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropZoneReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropZoneError>> {
            self._dropZone_impl(
                arg_req,
                rpc_options,
            )
        }
        fn divideZone_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DivideZoneReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DivideZoneError>> {
            self._divideZone_impl(
                arg_req,
                rpc_options,
            )
        }
        fn renameZone_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::RenameZoneReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::RenameZoneError>> {
            self._renameZone_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getZone_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetZoneReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetZoneResp, crate::fbthrift_protocol::meta::errors::meta_service::GetZoneError>> {
            self._getZone_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listZones_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListZonesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListZonesResp, crate::fbthrift_protocol::meta::errors::meta_service::ListZonesError>> {
            self._listZones_impl(
                arg_req,
                rpc_options,
            )
        }
        fn addListener_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::AddListenerReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::AddListenerError>> {
            self._addListener_impl(
                arg_req,
                rpc_options,
            )
        }
        fn removeListener_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::RemoveListenerReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::RemoveListenerError>> {
            self._removeListener_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listListener_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListListenerReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListListenerResp, crate::fbthrift_protocol::meta::errors::meta_service::ListListenerError>> {
            self._listListener_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getStats_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetStatsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetStatsResp, crate::fbthrift_protocol::meta::errors::meta_service::GetStatsError>> {
            self._getStats_impl(
                arg_req,
                rpc_options,
            )
        }
        fn signInService_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::SignInServiceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::SignInServiceError>> {
            self._signInService_impl(
                arg_req,
                rpc_options,
            )
        }
        fn signOutService_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::SignOutServiceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::SignOutServiceError>> {
            self._signOutService_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listServiceClients_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListServiceClientsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListServiceClientsResp, crate::fbthrift_protocol::meta::errors::meta_service::ListServiceClientsError>> {
            self._listServiceClients_impl(
                arg_req,
                rpc_options,
            )
        }
        fn createFTIndex_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateFTIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateFTIndexError>> {
            self._createFTIndex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn dropFTIndex_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropFTIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropFTIndexError>> {
            self._dropFTIndex_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listFTIndexes_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListFTIndexesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListFTIndexesResp, crate::fbthrift_protocol::meta::errors::meta_service::ListFTIndexesError>> {
            self._listFTIndexes_impl(
                arg_req,
                rpc_options,
            )
        }
        fn createSession_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateSessionReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::CreateSessionResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateSessionError>> {
            self._createSession_impl(
                arg_req,
                rpc_options,
            )
        }
        fn updateSessions_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::UpdateSessionsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::UpdateSessionsResp, crate::fbthrift_protocol::meta::errors::meta_service::UpdateSessionsError>> {
            self._updateSessions_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listSessions_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListSessionsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListSessionsResp, crate::fbthrift_protocol::meta::errors::meta_service::ListSessionsError>> {
            self._listSessions_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getSession_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetSessionReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetSessionResp, crate::fbthrift_protocol::meta::errors::meta_service::GetSessionError>> {
            self._getSession_impl(
                arg_req,
                rpc_options,
            )
        }
        fn removeSession_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::RemoveSessionReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::RemoveSessionError>> {
            self._removeSession_impl(
                arg_req,
                rpc_options,
            )
        }
        fn killQuery_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::KillQueryReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::KillQueryError>> {
            self._killQuery_impl(
                arg_req,
                rpc_options,
            )
        }
        fn reportTaskFinish_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ReportTaskReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::ReportTaskFinishError>> {
            self._reportTaskFinish_impl(
                arg_req,
                rpc_options,
            )
        }
        fn createBackup_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateBackupReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::CreateBackupResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateBackupError>> {
            self._createBackup_impl(
                arg_req,
                rpc_options,
            )
        }
        fn restoreMeta_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::RestoreMetaReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::RestoreMetaResp, crate::fbthrift_protocol::meta::errors::meta_service::RestoreMetaError>> {
            self._restoreMeta_impl(
                arg_req,
                rpc_options,
            )
        }
        fn listCluster_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListClusterInfoReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListClusterInfoResp, crate::fbthrift_protocol::meta::errors::meta_service::ListClusterError>> {
            self._listCluster_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getMetaDirInfo_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetMetaDirInfoReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetMetaDirInfoResp, crate::fbthrift_protocol::meta::errors::meta_service::GetMetaDirInfoError>> {
            self._getMetaDirInfo_impl(
                arg_req,
                rpc_options,
            )
        }
        fn verifyClientVersion_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::VerifyClientVersionReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::VerifyClientVersionResp, crate::fbthrift_protocol::meta::errors::meta_service::VerifyClientVersionError>> {
            self._verifyClientVersion_impl(
                arg_req,
                rpc_options,
            )
        }
        fn saveGraphVersion_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::SaveGraphVersionReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::SaveGraphVersionResp, crate::fbthrift_protocol::meta::errors::meta_service::SaveGraphVersionError>> {
            self._saveGraphVersion_impl(
                arg_req,
                rpc_options,
            )
        }
        fn getSegmentId_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetSegmentIdReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetSegmentIdResp, crate::fbthrift_protocol::meta::errors::meta_service::GetSegmentIdError>> {
            self._getSegmentId_impl(
                arg_req,
                rpc_options,
            )
        }
    }

    impl<'a, S> MetaService for S
    where
        S: ::std::convert::AsRef<dyn MetaService + 'a>,
        S: ::std::marker::Send,
    {
        fn createSpace(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateSpaceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateSpaceError>> {
            self.as_ref().createSpace(
                arg_req,
            )
        }
        fn dropSpace(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropSpaceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropSpaceError>> {
            self.as_ref().dropSpace(
                arg_req,
            )
        }
        fn clearSpace(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ClearSpaceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::ClearSpaceError>> {
            self.as_ref().clearSpace(
                arg_req,
            )
        }
        fn getSpace(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetSpaceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetSpaceResp, crate::fbthrift_protocol::meta::errors::meta_service::GetSpaceError>> {
            self.as_ref().getSpace(
                arg_req,
            )
        }
        fn listSpaces(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListSpacesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListSpacesResp, crate::fbthrift_protocol::meta::errors::meta_service::ListSpacesError>> {
            self.as_ref().listSpaces(
                arg_req,
            )
        }
        fn alterSpace(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::AlterSpaceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::AlterSpaceError>> {
            self.as_ref().alterSpace(
                arg_req,
            )
        }
        fn createSpaceAs(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateSpaceAsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateSpaceAsError>> {
            self.as_ref().createSpaceAs(
                arg_req,
            )
        }
        fn createTag(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateTagReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateTagError>> {
            self.as_ref().createTag(
                arg_req,
            )
        }
        fn alterTag(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::AlterTagReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::AlterTagError>> {
            self.as_ref().alterTag(
                arg_req,
            )
        }
        fn dropTag(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropTagReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropTagError>> {
            self.as_ref().dropTag(
                arg_req,
            )
        }
        fn getTag(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetTagReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetTagResp, crate::fbthrift_protocol::meta::errors::meta_service::GetTagError>> {
            self.as_ref().getTag(
                arg_req,
            )
        }
        fn listTags(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListTagsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListTagsResp, crate::fbthrift_protocol::meta::errors::meta_service::ListTagsError>> {
            self.as_ref().listTags(
                arg_req,
            )
        }
        fn createEdge(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateEdgeReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateEdgeError>> {
            self.as_ref().createEdge(
                arg_req,
            )
        }
        fn alterEdge(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::AlterEdgeReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::AlterEdgeError>> {
            self.as_ref().alterEdge(
                arg_req,
            )
        }
        fn dropEdge(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropEdgeReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropEdgeError>> {
            self.as_ref().dropEdge(
                arg_req,
            )
        }
        fn getEdge(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetEdgeReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetEdgeResp, crate::fbthrift_protocol::meta::errors::meta_service::GetEdgeError>> {
            self.as_ref().getEdge(
                arg_req,
            )
        }
        fn listEdges(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListEdgesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListEdgesResp, crate::fbthrift_protocol::meta::errors::meta_service::ListEdgesError>> {
            self.as_ref().listEdges(
                arg_req,
            )
        }
        fn addHosts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::AddHostsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::AddHostsError>> {
            self.as_ref().addHosts(
                arg_req,
            )
        }
        fn addHostsIntoZone(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::AddHostsIntoZoneReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::AddHostsIntoZoneError>> {
            self.as_ref().addHostsIntoZone(
                arg_req,
            )
        }
        fn dropHosts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropHostsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropHostsError>> {
            self.as_ref().dropHosts(
                arg_req,
            )
        }
        fn listHosts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListHostsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListHostsResp, crate::fbthrift_protocol::meta::errors::meta_service::ListHostsError>> {
            self.as_ref().listHosts(
                arg_req,
            )
        }
        fn getPartsAlloc(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetPartsAllocReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetPartsAllocResp, crate::fbthrift_protocol::meta::errors::meta_service::GetPartsAllocError>> {
            self.as_ref().getPartsAlloc(
                arg_req,
            )
        }
        fn listParts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListPartsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListPartsResp, crate::fbthrift_protocol::meta::errors::meta_service::ListPartsError>> {
            self.as_ref().listParts(
                arg_req,
            )
        }
        fn getWorkerId(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetWorkerIdReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetWorkerIdResp, crate::fbthrift_protocol::meta::errors::meta_service::GetWorkerIdError>> {
            self.as_ref().getWorkerId(
                arg_req,
            )
        }
        fn createTagIndex(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateTagIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateTagIndexError>> {
            self.as_ref().createTagIndex(
                arg_req,
            )
        }
        fn dropTagIndex(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropTagIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropTagIndexError>> {
            self.as_ref().dropTagIndex(
                arg_req,
            )
        }
        fn getTagIndex(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetTagIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetTagIndexResp, crate::fbthrift_protocol::meta::errors::meta_service::GetTagIndexError>> {
            self.as_ref().getTagIndex(
                arg_req,
            )
        }
        fn listTagIndexes(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListTagIndexesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListTagIndexesResp, crate::fbthrift_protocol::meta::errors::meta_service::ListTagIndexesError>> {
            self.as_ref().listTagIndexes(
                arg_req,
            )
        }
        fn rebuildTagIndex(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::RebuildIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::RebuildTagIndexError>> {
            self.as_ref().rebuildTagIndex(
                arg_req,
            )
        }
        fn listTagIndexStatus(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListIndexStatusReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListIndexStatusResp, crate::fbthrift_protocol::meta::errors::meta_service::ListTagIndexStatusError>> {
            self.as_ref().listTagIndexStatus(
                arg_req,
            )
        }
        fn createEdgeIndex(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateEdgeIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateEdgeIndexError>> {
            self.as_ref().createEdgeIndex(
                arg_req,
            )
        }
        fn dropEdgeIndex(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropEdgeIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropEdgeIndexError>> {
            self.as_ref().dropEdgeIndex(
                arg_req,
            )
        }
        fn getEdgeIndex(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetEdgeIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetEdgeIndexResp, crate::fbthrift_protocol::meta::errors::meta_service::GetEdgeIndexError>> {
            self.as_ref().getEdgeIndex(
                arg_req,
            )
        }
        fn listEdgeIndexes(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListEdgeIndexesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListEdgeIndexesResp, crate::fbthrift_protocol::meta::errors::meta_service::ListEdgeIndexesError>> {
            self.as_ref().listEdgeIndexes(
                arg_req,
            )
        }
        fn rebuildEdgeIndex(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::RebuildIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::RebuildEdgeIndexError>> {
            self.as_ref().rebuildEdgeIndex(
                arg_req,
            )
        }
        fn listEdgeIndexStatus(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListIndexStatusReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListIndexStatusResp, crate::fbthrift_protocol::meta::errors::meta_service::ListEdgeIndexStatusError>> {
            self.as_ref().listEdgeIndexStatus(
                arg_req,
            )
        }
        fn createUser(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateUserReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateUserError>> {
            self.as_ref().createUser(
                arg_req,
            )
        }
        fn dropUser(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropUserReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropUserError>> {
            self.as_ref().dropUser(
                arg_req,
            )
        }
        fn alterUser(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::AlterUserReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::AlterUserError>> {
            self.as_ref().alterUser(
                arg_req,
            )
        }
        fn grantRole(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GrantRoleReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::GrantRoleError>> {
            self.as_ref().grantRole(
                arg_req,
            )
        }
        fn revokeRole(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::RevokeRoleReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::RevokeRoleError>> {
            self.as_ref().revokeRole(
                arg_req,
            )
        }
        fn listUsers(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListUsersReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListUsersResp, crate::fbthrift_protocol::meta::errors::meta_service::ListUsersError>> {
            self.as_ref().listUsers(
                arg_req,
            )
        }
        fn listRoles(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListRolesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListRolesResp, crate::fbthrift_protocol::meta::errors::meta_service::ListRolesError>> {
            self.as_ref().listRoles(
                arg_req,
            )
        }
        fn getUserRoles(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetUserRolesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListRolesResp, crate::fbthrift_protocol::meta::errors::meta_service::GetUserRolesError>> {
            self.as_ref().getUserRoles(
                arg_req,
            )
        }
        fn changePassword(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ChangePasswordReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::ChangePasswordError>> {
            self.as_ref().changePassword(
                arg_req,
            )
        }
        fn heartBeat(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::HBReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::HBResp, crate::fbthrift_protocol::meta::errors::meta_service::HeartBeatError>> {
            self.as_ref().heartBeat(
                arg_req,
            )
        }
        fn agentHeartbeat(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::AgentHBReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::AgentHBResp, crate::fbthrift_protocol::meta::errors::meta_service::AgentHeartbeatError>> {
            self.as_ref().agentHeartbeat(
                arg_req,
            )
        }
        fn regConfig(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::RegConfigReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::RegConfigError>> {
            self.as_ref().regConfig(
                arg_req,
            )
        }
        fn getConfig(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetConfigReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetConfigResp, crate::fbthrift_protocol::meta::errors::meta_service::GetConfigError>> {
            self.as_ref().getConfig(
                arg_req,
            )
        }
        fn setConfig(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::SetConfigReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::SetConfigError>> {
            self.as_ref().setConfig(
                arg_req,
            )
        }
        fn listConfigs(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListConfigsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListConfigsResp, crate::fbthrift_protocol::meta::errors::meta_service::ListConfigsError>> {
            self.as_ref().listConfigs(
                arg_req,
            )
        }
        fn createSnapshot(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateSnapshotReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateSnapshotError>> {
            self.as_ref().createSnapshot(
                arg_req,
            )
        }
        fn dropSnapshot(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropSnapshotReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropSnapshotError>> {
            self.as_ref().dropSnapshot(
                arg_req,
            )
        }
        fn listSnapshots(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListSnapshotsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListSnapshotsResp, crate::fbthrift_protocol::meta::errors::meta_service::ListSnapshotsError>> {
            self.as_ref().listSnapshots(
                arg_req,
            )
        }
        fn runAdminJob(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::AdminJobReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::AdminJobResp, crate::fbthrift_protocol::meta::errors::meta_service::RunAdminJobError>> {
            self.as_ref().runAdminJob(
                arg_req,
            )
        }
        fn mergeZone(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::MergeZoneReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::MergeZoneError>> {
            self.as_ref().mergeZone(
                arg_req,
            )
        }
        fn dropZone(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropZoneReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropZoneError>> {
            self.as_ref().dropZone(
                arg_req,
            )
        }
        fn divideZone(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DivideZoneReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DivideZoneError>> {
            self.as_ref().divideZone(
                arg_req,
            )
        }
        fn renameZone(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::RenameZoneReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::RenameZoneError>> {
            self.as_ref().renameZone(
                arg_req,
            )
        }
        fn getZone(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetZoneReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetZoneResp, crate::fbthrift_protocol::meta::errors::meta_service::GetZoneError>> {
            self.as_ref().getZone(
                arg_req,
            )
        }
        fn listZones(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListZonesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListZonesResp, crate::fbthrift_protocol::meta::errors::meta_service::ListZonesError>> {
            self.as_ref().listZones(
                arg_req,
            )
        }
        fn addListener(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::AddListenerReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::AddListenerError>> {
            self.as_ref().addListener(
                arg_req,
            )
        }
        fn removeListener(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::RemoveListenerReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::RemoveListenerError>> {
            self.as_ref().removeListener(
                arg_req,
            )
        }
        fn listListener(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListListenerReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListListenerResp, crate::fbthrift_protocol::meta::errors::meta_service::ListListenerError>> {
            self.as_ref().listListener(
                arg_req,
            )
        }
        fn getStats(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetStatsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetStatsResp, crate::fbthrift_protocol::meta::errors::meta_service::GetStatsError>> {
            self.as_ref().getStats(
                arg_req,
            )
        }
        fn signInService(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::SignInServiceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::SignInServiceError>> {
            self.as_ref().signInService(
                arg_req,
            )
        }
        fn signOutService(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::SignOutServiceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::SignOutServiceError>> {
            self.as_ref().signOutService(
                arg_req,
            )
        }
        fn listServiceClients(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListServiceClientsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListServiceClientsResp, crate::fbthrift_protocol::meta::errors::meta_service::ListServiceClientsError>> {
            self.as_ref().listServiceClients(
                arg_req,
            )
        }
        fn createFTIndex(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateFTIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateFTIndexError>> {
            self.as_ref().createFTIndex(
                arg_req,
            )
        }
        fn dropFTIndex(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropFTIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropFTIndexError>> {
            self.as_ref().dropFTIndex(
                arg_req,
            )
        }
        fn listFTIndexes(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListFTIndexesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListFTIndexesResp, crate::fbthrift_protocol::meta::errors::meta_service::ListFTIndexesError>> {
            self.as_ref().listFTIndexes(
                arg_req,
            )
        }
        fn createSession(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateSessionReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::CreateSessionResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateSessionError>> {
            self.as_ref().createSession(
                arg_req,
            )
        }
        fn updateSessions(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::UpdateSessionsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::UpdateSessionsResp, crate::fbthrift_protocol::meta::errors::meta_service::UpdateSessionsError>> {
            self.as_ref().updateSessions(
                arg_req,
            )
        }
        fn listSessions(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListSessionsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListSessionsResp, crate::fbthrift_protocol::meta::errors::meta_service::ListSessionsError>> {
            self.as_ref().listSessions(
                arg_req,
            )
        }
        fn getSession(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetSessionReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetSessionResp, crate::fbthrift_protocol::meta::errors::meta_service::GetSessionError>> {
            self.as_ref().getSession(
                arg_req,
            )
        }
        fn removeSession(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::RemoveSessionReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::RemoveSessionError>> {
            self.as_ref().removeSession(
                arg_req,
            )
        }
        fn killQuery(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::KillQueryReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::KillQueryError>> {
            self.as_ref().killQuery(
                arg_req,
            )
        }
        fn reportTaskFinish(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ReportTaskReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::ReportTaskFinishError>> {
            self.as_ref().reportTaskFinish(
                arg_req,
            )
        }
        fn createBackup(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateBackupReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::CreateBackupResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateBackupError>> {
            self.as_ref().createBackup(
                arg_req,
            )
        }
        fn restoreMeta(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::RestoreMetaReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::RestoreMetaResp, crate::fbthrift_protocol::meta::errors::meta_service::RestoreMetaError>> {
            self.as_ref().restoreMeta(
                arg_req,
            )
        }
        fn listCluster(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListClusterInfoReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListClusterInfoResp, crate::fbthrift_protocol::meta::errors::meta_service::ListClusterError>> {
            self.as_ref().listCluster(
                arg_req,
            )
        }
        fn getMetaDirInfo(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetMetaDirInfoReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetMetaDirInfoResp, crate::fbthrift_protocol::meta::errors::meta_service::GetMetaDirInfoError>> {
            self.as_ref().getMetaDirInfo(
                arg_req,
            )
        }
        fn verifyClientVersion(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::VerifyClientVersionReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::VerifyClientVersionResp, crate::fbthrift_protocol::meta::errors::meta_service::VerifyClientVersionError>> {
            self.as_ref().verifyClientVersion(
                arg_req,
            )
        }
        fn saveGraphVersion(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::SaveGraphVersionReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::SaveGraphVersionResp, crate::fbthrift_protocol::meta::errors::meta_service::SaveGraphVersionError>> {
            self.as_ref().saveGraphVersion(
                arg_req,
            )
        }
        fn getSegmentId(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetSegmentIdReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetSegmentIdResp, crate::fbthrift_protocol::meta::errors::meta_service::GetSegmentIdError>> {
            self.as_ref().getSegmentId(
                arg_req,
            )
        }
    }

    impl<'a, S, T> MetaServiceExt<T> for S
    where
        S: ::std::convert::AsRef<dyn MetaService + 'a>,
        S: ::std::convert::AsRef<dyn MetaServiceExt<T> + 'a>,
        S: ::std::marker::Send,
        T: crate::fbthrift::Transport,
    {
        fn createSpace_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateSpaceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateSpaceError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).createSpace_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn dropSpace_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropSpaceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropSpaceError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).dropSpace_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn clearSpace_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ClearSpaceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::ClearSpaceError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).clearSpace_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn getSpace_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetSpaceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetSpaceResp, crate::fbthrift_protocol::meta::errors::meta_service::GetSpaceError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).getSpace_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn listSpaces_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListSpacesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListSpacesResp, crate::fbthrift_protocol::meta::errors::meta_service::ListSpacesError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).listSpaces_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn alterSpace_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::AlterSpaceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::AlterSpaceError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).alterSpace_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn createSpaceAs_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateSpaceAsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateSpaceAsError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).createSpaceAs_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn createTag_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateTagReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateTagError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).createTag_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn alterTag_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::AlterTagReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::AlterTagError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).alterTag_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn dropTag_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropTagReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropTagError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).dropTag_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn getTag_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetTagReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetTagResp, crate::fbthrift_protocol::meta::errors::meta_service::GetTagError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).getTag_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn listTags_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListTagsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListTagsResp, crate::fbthrift_protocol::meta::errors::meta_service::ListTagsError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).listTags_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn createEdge_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateEdgeReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateEdgeError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).createEdge_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn alterEdge_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::AlterEdgeReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::AlterEdgeError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).alterEdge_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn dropEdge_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropEdgeReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropEdgeError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).dropEdge_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn getEdge_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetEdgeReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetEdgeResp, crate::fbthrift_protocol::meta::errors::meta_service::GetEdgeError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).getEdge_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn listEdges_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListEdgesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListEdgesResp, crate::fbthrift_protocol::meta::errors::meta_service::ListEdgesError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).listEdges_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn addHosts_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::AddHostsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::AddHostsError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).addHosts_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn addHostsIntoZone_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::AddHostsIntoZoneReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::AddHostsIntoZoneError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).addHostsIntoZone_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn dropHosts_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropHostsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropHostsError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).dropHosts_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn listHosts_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListHostsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListHostsResp, crate::fbthrift_protocol::meta::errors::meta_service::ListHostsError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).listHosts_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn getPartsAlloc_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetPartsAllocReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetPartsAllocResp, crate::fbthrift_protocol::meta::errors::meta_service::GetPartsAllocError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).getPartsAlloc_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn listParts_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListPartsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListPartsResp, crate::fbthrift_protocol::meta::errors::meta_service::ListPartsError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).listParts_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn getWorkerId_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetWorkerIdReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetWorkerIdResp, crate::fbthrift_protocol::meta::errors::meta_service::GetWorkerIdError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).getWorkerId_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn createTagIndex_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateTagIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateTagIndexError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).createTagIndex_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn dropTagIndex_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropTagIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropTagIndexError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).dropTagIndex_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn getTagIndex_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetTagIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetTagIndexResp, crate::fbthrift_protocol::meta::errors::meta_service::GetTagIndexError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).getTagIndex_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn listTagIndexes_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListTagIndexesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListTagIndexesResp, crate::fbthrift_protocol::meta::errors::meta_service::ListTagIndexesError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).listTagIndexes_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn rebuildTagIndex_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::RebuildIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::RebuildTagIndexError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).rebuildTagIndex_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn listTagIndexStatus_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListIndexStatusReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListIndexStatusResp, crate::fbthrift_protocol::meta::errors::meta_service::ListTagIndexStatusError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).listTagIndexStatus_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn createEdgeIndex_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateEdgeIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateEdgeIndexError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).createEdgeIndex_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn dropEdgeIndex_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropEdgeIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropEdgeIndexError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).dropEdgeIndex_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn getEdgeIndex_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetEdgeIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetEdgeIndexResp, crate::fbthrift_protocol::meta::errors::meta_service::GetEdgeIndexError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).getEdgeIndex_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn listEdgeIndexes_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListEdgeIndexesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListEdgeIndexesResp, crate::fbthrift_protocol::meta::errors::meta_service::ListEdgeIndexesError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).listEdgeIndexes_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn rebuildEdgeIndex_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::RebuildIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::RebuildEdgeIndexError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).rebuildEdgeIndex_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn listEdgeIndexStatus_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListIndexStatusReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListIndexStatusResp, crate::fbthrift_protocol::meta::errors::meta_service::ListEdgeIndexStatusError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).listEdgeIndexStatus_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn createUser_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateUserReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateUserError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).createUser_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn dropUser_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropUserReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropUserError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).dropUser_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn alterUser_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::AlterUserReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::AlterUserError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).alterUser_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn grantRole_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GrantRoleReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::GrantRoleError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).grantRole_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn revokeRole_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::RevokeRoleReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::RevokeRoleError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).revokeRole_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn listUsers_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListUsersReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListUsersResp, crate::fbthrift_protocol::meta::errors::meta_service::ListUsersError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).listUsers_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn listRoles_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListRolesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListRolesResp, crate::fbthrift_protocol::meta::errors::meta_service::ListRolesError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).listRoles_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn getUserRoles_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetUserRolesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListRolesResp, crate::fbthrift_protocol::meta::errors::meta_service::GetUserRolesError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).getUserRoles_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn changePassword_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ChangePasswordReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::ChangePasswordError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).changePassword_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn heartBeat_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::HBReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::HBResp, crate::fbthrift_protocol::meta::errors::meta_service::HeartBeatError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).heartBeat_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn agentHeartbeat_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::AgentHBReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::AgentHBResp, crate::fbthrift_protocol::meta::errors::meta_service::AgentHeartbeatError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).agentHeartbeat_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn regConfig_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::RegConfigReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::RegConfigError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).regConfig_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn getConfig_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetConfigReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetConfigResp, crate::fbthrift_protocol::meta::errors::meta_service::GetConfigError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).getConfig_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn setConfig_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::SetConfigReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::SetConfigError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).setConfig_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn listConfigs_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListConfigsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListConfigsResp, crate::fbthrift_protocol::meta::errors::meta_service::ListConfigsError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).listConfigs_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn createSnapshot_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateSnapshotReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateSnapshotError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).createSnapshot_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn dropSnapshot_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropSnapshotReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropSnapshotError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).dropSnapshot_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn listSnapshots_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListSnapshotsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListSnapshotsResp, crate::fbthrift_protocol::meta::errors::meta_service::ListSnapshotsError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).listSnapshots_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn runAdminJob_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::AdminJobReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::AdminJobResp, crate::fbthrift_protocol::meta::errors::meta_service::RunAdminJobError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).runAdminJob_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn mergeZone_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::MergeZoneReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::MergeZoneError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).mergeZone_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn dropZone_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropZoneReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropZoneError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).dropZone_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn divideZone_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DivideZoneReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DivideZoneError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).divideZone_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn renameZone_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::RenameZoneReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::RenameZoneError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).renameZone_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn getZone_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetZoneReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetZoneResp, crate::fbthrift_protocol::meta::errors::meta_service::GetZoneError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).getZone_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn listZones_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListZonesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListZonesResp, crate::fbthrift_protocol::meta::errors::meta_service::ListZonesError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).listZones_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn addListener_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::AddListenerReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::AddListenerError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).addListener_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn removeListener_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::RemoveListenerReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::RemoveListenerError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).removeListener_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn listListener_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListListenerReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListListenerResp, crate::fbthrift_protocol::meta::errors::meta_service::ListListenerError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).listListener_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn getStats_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetStatsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetStatsResp, crate::fbthrift_protocol::meta::errors::meta_service::GetStatsError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).getStats_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn signInService_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::SignInServiceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::SignInServiceError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).signInService_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn signOutService_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::SignOutServiceReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::SignOutServiceError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).signOutService_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn listServiceClients_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListServiceClientsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListServiceClientsResp, crate::fbthrift_protocol::meta::errors::meta_service::ListServiceClientsError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).listServiceClients_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn createFTIndex_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateFTIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateFTIndexError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).createFTIndex_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn dropFTIndex_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropFTIndexReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropFTIndexError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).dropFTIndex_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn listFTIndexes_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListFTIndexesReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListFTIndexesResp, crate::fbthrift_protocol::meta::errors::meta_service::ListFTIndexesError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).listFTIndexes_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn createSession_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateSessionReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::CreateSessionResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateSessionError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).createSession_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn updateSessions_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::UpdateSessionsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::UpdateSessionsResp, crate::fbthrift_protocol::meta::errors::meta_service::UpdateSessionsError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).updateSessions_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn listSessions_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListSessionsReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListSessionsResp, crate::fbthrift_protocol::meta::errors::meta_service::ListSessionsError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).listSessions_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn getSession_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetSessionReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetSessionResp, crate::fbthrift_protocol::meta::errors::meta_service::GetSessionError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).getSession_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn removeSession_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::RemoveSessionReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::RemoveSessionError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).removeSession_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn killQuery_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::KillQueryReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::KillQueryError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).killQuery_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn reportTaskFinish_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ReportTaskReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::ReportTaskFinishError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).reportTaskFinish_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn createBackup_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateBackupReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::CreateBackupResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateBackupError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).createBackup_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn restoreMeta_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::RestoreMetaReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::RestoreMetaResp, crate::fbthrift_protocol::meta::errors::meta_service::RestoreMetaError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).restoreMeta_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn listCluster_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListClusterInfoReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListClusterInfoResp, crate::fbthrift_protocol::meta::errors::meta_service::ListClusterError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).listCluster_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn getMetaDirInfo_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetMetaDirInfoReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetMetaDirInfoResp, crate::fbthrift_protocol::meta::errors::meta_service::GetMetaDirInfoError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).getMetaDirInfo_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn verifyClientVersion_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::VerifyClientVersionReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::VerifyClientVersionResp, crate::fbthrift_protocol::meta::errors::meta_service::VerifyClientVersionError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).verifyClientVersion_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn saveGraphVersion_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::SaveGraphVersionReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::SaveGraphVersionResp, crate::fbthrift_protocol::meta::errors::meta_service::SaveGraphVersionError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).saveGraphVersion_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
        fn getSegmentId_with_rpc_opts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetSegmentIdReq,
            rpc_options: T::RpcOptions,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetSegmentIdResp, crate::fbthrift_protocol::meta::errors::meta_service::GetSegmentIdError>> {
            <Self as ::std::convert::AsRef<dyn MetaServiceExt<T>>>::as_ref(self).getSegmentId_with_rpc_opts(
                arg_req,
                rpc_options,
            )
        }
    }

    #[derive(Clone)]
    pub struct make_MetaService;

    /// To be called by user directly setting up a client. Avoids
    /// needing ClientFactory trait in scope, avoids unidiomatic
    /// make_Trait name.
    ///
    /// ```
    /// # const _: &str = stringify! {
    /// use bgs::client::BuckGraphService;
    ///
    /// let protocol = BinaryProtocol::new();
    /// let transport = HttpClient::new();
    /// let client = <dyn BuckGraphService>::new(protocol, transport);
    /// # };
    /// ```
    impl dyn MetaService {
        pub fn new<P, T>(
            protocol: P,
            transport: T,
        ) -> ::std::sync::Arc<impl MetaService + ::std::marker::Send + ::std::marker::Sync + 'static>
        where
            P: crate::fbthrift::Protocol<Frame = T>,
            T: crate::fbthrift::Transport,
            P::Deserializer: ::std::marker::Send,
        {
            let spawner = crate::fbthrift::help::NoopSpawner;
            Self::with_spawner(protocol, transport, spawner)
        }

        pub fn with_spawner<P, T, S>(
            protocol: P,
            transport: T,
            spawner: S,
        ) -> ::std::sync::Arc<impl MetaService + ::std::marker::Send + ::std::marker::Sync + 'static>
        where
            P: crate::fbthrift::Protocol<Frame = T>,
            T: crate::fbthrift::Transport,
            P::Deserializer: ::std::marker::Send,
            S: crate::fbthrift::help::Spawner,
        {
            let _ = protocol;
            let _ = spawner;
            ::std::sync::Arc::new(MetaServiceImpl::<P, T, S>::new(transport))
        }
    }

    impl<T> dyn MetaServiceExt<T>
    where
        T: crate::fbthrift::Transport,
    {
        pub fn new<P>(
            protocol: P,
            transport: T,
        ) -> ::std::sync::Arc<impl MetaServiceExt<T> + ::std::marker::Send + ::std::marker::Sync + 'static>
        where
            P: crate::fbthrift::Protocol<Frame = T>,
            P::Deserializer: ::std::marker::Send,
        {
            let spawner = crate::fbthrift::help::NoopSpawner;
            Self::with_spawner(protocol, transport, spawner)
        }

        pub fn with_spawner<P, S>(
            protocol: P,
            transport: T,
            spawner: S,
        ) -> ::std::sync::Arc<impl MetaServiceExt<T> + ::std::marker::Send + ::std::marker::Sync + 'static>
        where
            P: crate::fbthrift::Protocol<Frame = T>,
            P::Deserializer: ::std::marker::Send,
            S: crate::fbthrift::help::Spawner,
        {
            let _ = protocol;
            let _ = spawner;
            ::std::sync::Arc::new(MetaServiceImpl::<P, T, S>::new(transport))
        }
    }

    pub type MetaServiceDynClient = <make_MetaService as crate::fbthrift::ClientFactory>::Api;
    pub type MetaServiceClient = ::std::sync::Arc<MetaServiceDynClient>;

    /// The same thing, but to be called from generic contexts where we are
    /// working with a type parameter `C: ClientFactory` to produce clients.
    impl crate::fbthrift::ClientFactory for make_MetaService {
        type Api = dyn MetaService + ::std::marker::Send + ::std::marker::Sync + 'static;

        fn with_spawner<P, T, S>(protocol: P, transport: T, spawner: S) -> ::std::sync::Arc<Self::Api>
        where
            P: crate::fbthrift::Protocol<Frame = T>,
            T: crate::fbthrift::Transport,
            P::Deserializer: ::std::marker::Send,
            S: crate::fbthrift::help::Spawner,
        {
            <dyn MetaService>::with_spawner(protocol, transport, spawner)
        }
    }

}

/// Server definitions for `meta`.
pub mod server {
    #[::async_trait::async_trait]
    pub trait MetaService: ::std::marker::Send + ::std::marker::Sync + 'static {
        async fn createSpace(
            &self,
            _req: crate::fbthrift_protocol::meta::types::CreateSpaceReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::CreateSpaceExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::CreateSpaceExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "createSpace",
                ),
            ))
        }
        async fn dropSpace(
            &self,
            _req: crate::fbthrift_protocol::meta::types::DropSpaceReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::DropSpaceExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::DropSpaceExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "dropSpace",
                ),
            ))
        }
        async fn clearSpace(
            &self,
            _req: crate::fbthrift_protocol::meta::types::ClearSpaceReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::ClearSpaceExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::ClearSpaceExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "clearSpace",
                ),
            ))
        }
        async fn getSpace(
            &self,
            _req: crate::fbthrift_protocol::meta::types::GetSpaceReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::GetSpaceResp, crate::fbthrift_protocol::meta::services::meta_service::GetSpaceExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::GetSpaceExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "getSpace",
                ),
            ))
        }
        async fn listSpaces(
            &self,
            _req: crate::fbthrift_protocol::meta::types::ListSpacesReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ListSpacesResp, crate::fbthrift_protocol::meta::services::meta_service::ListSpacesExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::ListSpacesExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listSpaces",
                ),
            ))
        }
        async fn alterSpace(
            &self,
            _req: crate::fbthrift_protocol::meta::types::AlterSpaceReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::AlterSpaceExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::AlterSpaceExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "alterSpace",
                ),
            ))
        }
        async fn createSpaceAs(
            &self,
            _req: crate::fbthrift_protocol::meta::types::CreateSpaceAsReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::CreateSpaceAsExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::CreateSpaceAsExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "createSpaceAs",
                ),
            ))
        }
        async fn createTag(
            &self,
            _req: crate::fbthrift_protocol::meta::types::CreateTagReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::CreateTagExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::CreateTagExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "createTag",
                ),
            ))
        }
        async fn alterTag(
            &self,
            _req: crate::fbthrift_protocol::meta::types::AlterTagReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::AlterTagExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::AlterTagExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "alterTag",
                ),
            ))
        }
        async fn dropTag(
            &self,
            _req: crate::fbthrift_protocol::meta::types::DropTagReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::DropTagExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::DropTagExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "dropTag",
                ),
            ))
        }
        async fn getTag(
            &self,
            _req: crate::fbthrift_protocol::meta::types::GetTagReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::GetTagResp, crate::fbthrift_protocol::meta::services::meta_service::GetTagExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::GetTagExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "getTag",
                ),
            ))
        }
        async fn listTags(
            &self,
            _req: crate::fbthrift_protocol::meta::types::ListTagsReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ListTagsResp, crate::fbthrift_protocol::meta::services::meta_service::ListTagsExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::ListTagsExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listTags",
                ),
            ))
        }
        async fn createEdge(
            &self,
            _req: crate::fbthrift_protocol::meta::types::CreateEdgeReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::CreateEdgeExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::CreateEdgeExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "createEdge",
                ),
            ))
        }
        async fn alterEdge(
            &self,
            _req: crate::fbthrift_protocol::meta::types::AlterEdgeReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::AlterEdgeExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::AlterEdgeExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "alterEdge",
                ),
            ))
        }
        async fn dropEdge(
            &self,
            _req: crate::fbthrift_protocol::meta::types::DropEdgeReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::DropEdgeExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::DropEdgeExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "dropEdge",
                ),
            ))
        }
        async fn getEdge(
            &self,
            _req: crate::fbthrift_protocol::meta::types::GetEdgeReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::GetEdgeResp, crate::fbthrift_protocol::meta::services::meta_service::GetEdgeExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::GetEdgeExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "getEdge",
                ),
            ))
        }
        async fn listEdges(
            &self,
            _req: crate::fbthrift_protocol::meta::types::ListEdgesReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ListEdgesResp, crate::fbthrift_protocol::meta::services::meta_service::ListEdgesExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::ListEdgesExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listEdges",
                ),
            ))
        }
        async fn addHosts(
            &self,
            _req: crate::fbthrift_protocol::meta::types::AddHostsReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::AddHostsExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::AddHostsExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "addHosts",
                ),
            ))
        }
        async fn addHostsIntoZone(
            &self,
            _req: crate::fbthrift_protocol::meta::types::AddHostsIntoZoneReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::AddHostsIntoZoneExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::AddHostsIntoZoneExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "addHostsIntoZone",
                ),
            ))
        }
        async fn dropHosts(
            &self,
            _req: crate::fbthrift_protocol::meta::types::DropHostsReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::DropHostsExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::DropHostsExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "dropHosts",
                ),
            ))
        }
        async fn listHosts(
            &self,
            _req: crate::fbthrift_protocol::meta::types::ListHostsReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ListHostsResp, crate::fbthrift_protocol::meta::services::meta_service::ListHostsExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::ListHostsExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listHosts",
                ),
            ))
        }
        async fn getPartsAlloc(
            &self,
            _req: crate::fbthrift_protocol::meta::types::GetPartsAllocReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::GetPartsAllocResp, crate::fbthrift_protocol::meta::services::meta_service::GetPartsAllocExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::GetPartsAllocExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "getPartsAlloc",
                ),
            ))
        }
        async fn listParts(
            &self,
            _req: crate::fbthrift_protocol::meta::types::ListPartsReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ListPartsResp, crate::fbthrift_protocol::meta::services::meta_service::ListPartsExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::ListPartsExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listParts",
                ),
            ))
        }
        async fn getWorkerId(
            &self,
            _req: crate::fbthrift_protocol::meta::types::GetWorkerIdReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::GetWorkerIdResp, crate::fbthrift_protocol::meta::services::meta_service::GetWorkerIdExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::GetWorkerIdExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "getWorkerId",
                ),
            ))
        }
        async fn createTagIndex(
            &self,
            _req: crate::fbthrift_protocol::meta::types::CreateTagIndexReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::CreateTagIndexExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::CreateTagIndexExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "createTagIndex",
                ),
            ))
        }
        async fn dropTagIndex(
            &self,
            _req: crate::fbthrift_protocol::meta::types::DropTagIndexReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::DropTagIndexExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::DropTagIndexExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "dropTagIndex",
                ),
            ))
        }
        async fn getTagIndex(
            &self,
            _req: crate::fbthrift_protocol::meta::types::GetTagIndexReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::GetTagIndexResp, crate::fbthrift_protocol::meta::services::meta_service::GetTagIndexExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::GetTagIndexExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "getTagIndex",
                ),
            ))
        }
        async fn listTagIndexes(
            &self,
            _req: crate::fbthrift_protocol::meta::types::ListTagIndexesReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ListTagIndexesResp, crate::fbthrift_protocol::meta::services::meta_service::ListTagIndexesExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::ListTagIndexesExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listTagIndexes",
                ),
            ))
        }
        async fn rebuildTagIndex(
            &self,
            _req: crate::fbthrift_protocol::meta::types::RebuildIndexReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::RebuildTagIndexExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::RebuildTagIndexExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "rebuildTagIndex",
                ),
            ))
        }
        async fn listTagIndexStatus(
            &self,
            _req: crate::fbthrift_protocol::meta::types::ListIndexStatusReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ListIndexStatusResp, crate::fbthrift_protocol::meta::services::meta_service::ListTagIndexStatusExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::ListTagIndexStatusExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listTagIndexStatus",
                ),
            ))
        }
        async fn createEdgeIndex(
            &self,
            _req: crate::fbthrift_protocol::meta::types::CreateEdgeIndexReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::CreateEdgeIndexExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::CreateEdgeIndexExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "createEdgeIndex",
                ),
            ))
        }
        async fn dropEdgeIndex(
            &self,
            _req: crate::fbthrift_protocol::meta::types::DropEdgeIndexReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::DropEdgeIndexExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::DropEdgeIndexExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "dropEdgeIndex",
                ),
            ))
        }
        async fn getEdgeIndex(
            &self,
            _req: crate::fbthrift_protocol::meta::types::GetEdgeIndexReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::GetEdgeIndexResp, crate::fbthrift_protocol::meta::services::meta_service::GetEdgeIndexExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::GetEdgeIndexExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "getEdgeIndex",
                ),
            ))
        }
        async fn listEdgeIndexes(
            &self,
            _req: crate::fbthrift_protocol::meta::types::ListEdgeIndexesReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ListEdgeIndexesResp, crate::fbthrift_protocol::meta::services::meta_service::ListEdgeIndexesExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::ListEdgeIndexesExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listEdgeIndexes",
                ),
            ))
        }
        async fn rebuildEdgeIndex(
            &self,
            _req: crate::fbthrift_protocol::meta::types::RebuildIndexReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::RebuildEdgeIndexExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::RebuildEdgeIndexExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "rebuildEdgeIndex",
                ),
            ))
        }
        async fn listEdgeIndexStatus(
            &self,
            _req: crate::fbthrift_protocol::meta::types::ListIndexStatusReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ListIndexStatusResp, crate::fbthrift_protocol::meta::services::meta_service::ListEdgeIndexStatusExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::ListEdgeIndexStatusExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listEdgeIndexStatus",
                ),
            ))
        }
        async fn createUser(
            &self,
            _req: crate::fbthrift_protocol::meta::types::CreateUserReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::CreateUserExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::CreateUserExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "createUser",
                ),
            ))
        }
        async fn dropUser(
            &self,
            _req: crate::fbthrift_protocol::meta::types::DropUserReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::DropUserExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::DropUserExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "dropUser",
                ),
            ))
        }
        async fn alterUser(
            &self,
            _req: crate::fbthrift_protocol::meta::types::AlterUserReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::AlterUserExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::AlterUserExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "alterUser",
                ),
            ))
        }
        async fn grantRole(
            &self,
            _req: crate::fbthrift_protocol::meta::types::GrantRoleReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::GrantRoleExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::GrantRoleExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "grantRole",
                ),
            ))
        }
        async fn revokeRole(
            &self,
            _req: crate::fbthrift_protocol::meta::types::RevokeRoleReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::RevokeRoleExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::RevokeRoleExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "revokeRole",
                ),
            ))
        }
        async fn listUsers(
            &self,
            _req: crate::fbthrift_protocol::meta::types::ListUsersReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ListUsersResp, crate::fbthrift_protocol::meta::services::meta_service::ListUsersExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::ListUsersExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listUsers",
                ),
            ))
        }
        async fn listRoles(
            &self,
            _req: crate::fbthrift_protocol::meta::types::ListRolesReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ListRolesResp, crate::fbthrift_protocol::meta::services::meta_service::ListRolesExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::ListRolesExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listRoles",
                ),
            ))
        }
        async fn getUserRoles(
            &self,
            _req: crate::fbthrift_protocol::meta::types::GetUserRolesReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ListRolesResp, crate::fbthrift_protocol::meta::services::meta_service::GetUserRolesExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::GetUserRolesExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "getUserRoles",
                ),
            ))
        }
        async fn changePassword(
            &self,
            _req: crate::fbthrift_protocol::meta::types::ChangePasswordReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::ChangePasswordExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::ChangePasswordExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "changePassword",
                ),
            ))
        }
        async fn heartBeat(
            &self,
            _req: crate::fbthrift_protocol::meta::types::HBReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::HBResp, crate::fbthrift_protocol::meta::services::meta_service::HeartBeatExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::HeartBeatExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "heartBeat",
                ),
            ))
        }
        async fn agentHeartbeat(
            &self,
            _req: crate::fbthrift_protocol::meta::types::AgentHBReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::AgentHBResp, crate::fbthrift_protocol::meta::services::meta_service::AgentHeartbeatExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::AgentHeartbeatExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "agentHeartbeat",
                ),
            ))
        }
        async fn regConfig(
            &self,
            _req: crate::fbthrift_protocol::meta::types::RegConfigReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::RegConfigExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::RegConfigExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "regConfig",
                ),
            ))
        }
        async fn getConfig(
            &self,
            _req: crate::fbthrift_protocol::meta::types::GetConfigReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::GetConfigResp, crate::fbthrift_protocol::meta::services::meta_service::GetConfigExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::GetConfigExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "getConfig",
                ),
            ))
        }
        async fn setConfig(
            &self,
            _req: crate::fbthrift_protocol::meta::types::SetConfigReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::SetConfigExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::SetConfigExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "setConfig",
                ),
            ))
        }
        async fn listConfigs(
            &self,
            _req: crate::fbthrift_protocol::meta::types::ListConfigsReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ListConfigsResp, crate::fbthrift_protocol::meta::services::meta_service::ListConfigsExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::ListConfigsExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listConfigs",
                ),
            ))
        }
        async fn createSnapshot(
            &self,
            _req: crate::fbthrift_protocol::meta::types::CreateSnapshotReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::CreateSnapshotExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::CreateSnapshotExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "createSnapshot",
                ),
            ))
        }
        async fn dropSnapshot(
            &self,
            _req: crate::fbthrift_protocol::meta::types::DropSnapshotReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::DropSnapshotExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::DropSnapshotExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "dropSnapshot",
                ),
            ))
        }
        async fn listSnapshots(
            &self,
            _req: crate::fbthrift_protocol::meta::types::ListSnapshotsReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ListSnapshotsResp, crate::fbthrift_protocol::meta::services::meta_service::ListSnapshotsExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::ListSnapshotsExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listSnapshots",
                ),
            ))
        }
        async fn runAdminJob(
            &self,
            _req: crate::fbthrift_protocol::meta::types::AdminJobReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::AdminJobResp, crate::fbthrift_protocol::meta::services::meta_service::RunAdminJobExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::RunAdminJobExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "runAdminJob",
                ),
            ))
        }
        async fn mergeZone(
            &self,
            _req: crate::fbthrift_protocol::meta::types::MergeZoneReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::MergeZoneExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::MergeZoneExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "mergeZone",
                ),
            ))
        }
        async fn dropZone(
            &self,
            _req: crate::fbthrift_protocol::meta::types::DropZoneReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::DropZoneExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::DropZoneExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "dropZone",
                ),
            ))
        }
        async fn divideZone(
            &self,
            _req: crate::fbthrift_protocol::meta::types::DivideZoneReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::DivideZoneExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::DivideZoneExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "divideZone",
                ),
            ))
        }
        async fn renameZone(
            &self,
            _req: crate::fbthrift_protocol::meta::types::RenameZoneReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::RenameZoneExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::RenameZoneExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "renameZone",
                ),
            ))
        }
        async fn getZone(
            &self,
            _req: crate::fbthrift_protocol::meta::types::GetZoneReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::GetZoneResp, crate::fbthrift_protocol::meta::services::meta_service::GetZoneExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::GetZoneExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "getZone",
                ),
            ))
        }
        async fn listZones(
            &self,
            _req: crate::fbthrift_protocol::meta::types::ListZonesReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ListZonesResp, crate::fbthrift_protocol::meta::services::meta_service::ListZonesExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::ListZonesExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listZones",
                ),
            ))
        }
        async fn addListener(
            &self,
            _req: crate::fbthrift_protocol::meta::types::AddListenerReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::AddListenerExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::AddListenerExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "addListener",
                ),
            ))
        }
        async fn removeListener(
            &self,
            _req: crate::fbthrift_protocol::meta::types::RemoveListenerReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::RemoveListenerExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::RemoveListenerExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "removeListener",
                ),
            ))
        }
        async fn listListener(
            &self,
            _req: crate::fbthrift_protocol::meta::types::ListListenerReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ListListenerResp, crate::fbthrift_protocol::meta::services::meta_service::ListListenerExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::ListListenerExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listListener",
                ),
            ))
        }
        async fn getStats(
            &self,
            _req: crate::fbthrift_protocol::meta::types::GetStatsReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::GetStatsResp, crate::fbthrift_protocol::meta::services::meta_service::GetStatsExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::GetStatsExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "getStats",
                ),
            ))
        }
        async fn signInService(
            &self,
            _req: crate::fbthrift_protocol::meta::types::SignInServiceReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::SignInServiceExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::SignInServiceExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "signInService",
                ),
            ))
        }
        async fn signOutService(
            &self,
            _req: crate::fbthrift_protocol::meta::types::SignOutServiceReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::SignOutServiceExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::SignOutServiceExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "signOutService",
                ),
            ))
        }
        async fn listServiceClients(
            &self,
            _req: crate::fbthrift_protocol::meta::types::ListServiceClientsReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ListServiceClientsResp, crate::fbthrift_protocol::meta::services::meta_service::ListServiceClientsExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::ListServiceClientsExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listServiceClients",
                ),
            ))
        }
        async fn createFTIndex(
            &self,
            _req: crate::fbthrift_protocol::meta::types::CreateFTIndexReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::CreateFTIndexExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::CreateFTIndexExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "createFTIndex",
                ),
            ))
        }
        async fn dropFTIndex(
            &self,
            _req: crate::fbthrift_protocol::meta::types::DropFTIndexReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::DropFTIndexExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::DropFTIndexExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "dropFTIndex",
                ),
            ))
        }
        async fn listFTIndexes(
            &self,
            _req: crate::fbthrift_protocol::meta::types::ListFTIndexesReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ListFTIndexesResp, crate::fbthrift_protocol::meta::services::meta_service::ListFTIndexesExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::ListFTIndexesExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listFTIndexes",
                ),
            ))
        }
        async fn createSession(
            &self,
            _req: crate::fbthrift_protocol::meta::types::CreateSessionReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::CreateSessionResp, crate::fbthrift_protocol::meta::services::meta_service::CreateSessionExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::CreateSessionExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "createSession",
                ),
            ))
        }
        async fn updateSessions(
            &self,
            _req: crate::fbthrift_protocol::meta::types::UpdateSessionsReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::UpdateSessionsResp, crate::fbthrift_protocol::meta::services::meta_service::UpdateSessionsExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::UpdateSessionsExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "updateSessions",
                ),
            ))
        }
        async fn listSessions(
            &self,
            _req: crate::fbthrift_protocol::meta::types::ListSessionsReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ListSessionsResp, crate::fbthrift_protocol::meta::services::meta_service::ListSessionsExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::ListSessionsExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listSessions",
                ),
            ))
        }
        async fn getSession(
            &self,
            _req: crate::fbthrift_protocol::meta::types::GetSessionReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::GetSessionResp, crate::fbthrift_protocol::meta::services::meta_service::GetSessionExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::GetSessionExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "getSession",
                ),
            ))
        }
        async fn removeSession(
            &self,
            _req: crate::fbthrift_protocol::meta::types::RemoveSessionReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::RemoveSessionExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::RemoveSessionExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "removeSession",
                ),
            ))
        }
        async fn killQuery(
            &self,
            _req: crate::fbthrift_protocol::meta::types::KillQueryReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::KillQueryExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::KillQueryExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "killQuery",
                ),
            ))
        }
        async fn reportTaskFinish(
            &self,
            _req: crate::fbthrift_protocol::meta::types::ReportTaskReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::ReportTaskFinishExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::ReportTaskFinishExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "reportTaskFinish",
                ),
            ))
        }
        async fn createBackup(
            &self,
            _req: crate::fbthrift_protocol::meta::types::CreateBackupReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::CreateBackupResp, crate::fbthrift_protocol::meta::services::meta_service::CreateBackupExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::CreateBackupExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "createBackup",
                ),
            ))
        }
        async fn restoreMeta(
            &self,
            _req: crate::fbthrift_protocol::meta::types::RestoreMetaReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::RestoreMetaResp, crate::fbthrift_protocol::meta::services::meta_service::RestoreMetaExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::RestoreMetaExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "restoreMeta",
                ),
            ))
        }
        async fn listCluster(
            &self,
            _req: crate::fbthrift_protocol::meta::types::ListClusterInfoReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ListClusterInfoResp, crate::fbthrift_protocol::meta::services::meta_service::ListClusterExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::ListClusterExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "listCluster",
                ),
            ))
        }
        async fn getMetaDirInfo(
            &self,
            _req: crate::fbthrift_protocol::meta::types::GetMetaDirInfoReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::GetMetaDirInfoResp, crate::fbthrift_protocol::meta::services::meta_service::GetMetaDirInfoExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::GetMetaDirInfoExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "getMetaDirInfo",
                ),
            ))
        }
        async fn verifyClientVersion(
            &self,
            _req: crate::fbthrift_protocol::meta::types::VerifyClientVersionReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::VerifyClientVersionResp, crate::fbthrift_protocol::meta::services::meta_service::VerifyClientVersionExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::VerifyClientVersionExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "verifyClientVersion",
                ),
            ))
        }
        async fn saveGraphVersion(
            &self,
            _req: crate::fbthrift_protocol::meta::types::SaveGraphVersionReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::SaveGraphVersionResp, crate::fbthrift_protocol::meta::services::meta_service::SaveGraphVersionExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::SaveGraphVersionExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "saveGraphVersion",
                ),
            ))
        }
        async fn getSegmentId(
            &self,
            _req: crate::fbthrift_protocol::meta::types::GetSegmentIdReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::GetSegmentIdResp, crate::fbthrift_protocol::meta::services::meta_service::GetSegmentIdExn> {
            ::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::GetSegmentIdExn::ApplicationException(
                crate::fbthrift::ApplicationException::unimplemented_method(
                    "MetaService",
                    "getSegmentId",
                ),
            ))
        }
    }

    #[::async_trait::async_trait]
    impl<T> MetaService for ::std::boxed::Box<T>
    where
        T: MetaService + Send + Sync + ?Sized,
    {
        async fn createSpace(
            &self,
            req: crate::fbthrift_protocol::meta::types::CreateSpaceReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::CreateSpaceExn> {
            (**self).createSpace(
                req,
            ).await
        }
        async fn dropSpace(
            &self,
            req: crate::fbthrift_protocol::meta::types::DropSpaceReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::DropSpaceExn> {
            (**self).dropSpace(
                req,
            ).await
        }
        async fn clearSpace(
            &self,
            req: crate::fbthrift_protocol::meta::types::ClearSpaceReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::ClearSpaceExn> {
            (**self).clearSpace(
                req,
            ).await
        }
        async fn getSpace(
            &self,
            req: crate::fbthrift_protocol::meta::types::GetSpaceReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::GetSpaceResp, crate::fbthrift_protocol::meta::services::meta_service::GetSpaceExn> {
            (**self).getSpace(
                req,
            ).await
        }
        async fn listSpaces(
            &self,
            req: crate::fbthrift_protocol::meta::types::ListSpacesReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ListSpacesResp, crate::fbthrift_protocol::meta::services::meta_service::ListSpacesExn> {
            (**self).listSpaces(
                req,
            ).await
        }
        async fn alterSpace(
            &self,
            req: crate::fbthrift_protocol::meta::types::AlterSpaceReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::AlterSpaceExn> {
            (**self).alterSpace(
                req,
            ).await
        }
        async fn createSpaceAs(
            &self,
            req: crate::fbthrift_protocol::meta::types::CreateSpaceAsReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::CreateSpaceAsExn> {
            (**self).createSpaceAs(
                req,
            ).await
        }
        async fn createTag(
            &self,
            req: crate::fbthrift_protocol::meta::types::CreateTagReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::CreateTagExn> {
            (**self).createTag(
                req,
            ).await
        }
        async fn alterTag(
            &self,
            req: crate::fbthrift_protocol::meta::types::AlterTagReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::AlterTagExn> {
            (**self).alterTag(
                req,
            ).await
        }
        async fn dropTag(
            &self,
            req: crate::fbthrift_protocol::meta::types::DropTagReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::DropTagExn> {
            (**self).dropTag(
                req,
            ).await
        }
        async fn getTag(
            &self,
            req: crate::fbthrift_protocol::meta::types::GetTagReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::GetTagResp, crate::fbthrift_protocol::meta::services::meta_service::GetTagExn> {
            (**self).getTag(
                req,
            ).await
        }
        async fn listTags(
            &self,
            req: crate::fbthrift_protocol::meta::types::ListTagsReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ListTagsResp, crate::fbthrift_protocol::meta::services::meta_service::ListTagsExn> {
            (**self).listTags(
                req,
            ).await
        }
        async fn createEdge(
            &self,
            req: crate::fbthrift_protocol::meta::types::CreateEdgeReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::CreateEdgeExn> {
            (**self).createEdge(
                req,
            ).await
        }
        async fn alterEdge(
            &self,
            req: crate::fbthrift_protocol::meta::types::AlterEdgeReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::AlterEdgeExn> {
            (**self).alterEdge(
                req,
            ).await
        }
        async fn dropEdge(
            &self,
            req: crate::fbthrift_protocol::meta::types::DropEdgeReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::DropEdgeExn> {
            (**self).dropEdge(
                req,
            ).await
        }
        async fn getEdge(
            &self,
            req: crate::fbthrift_protocol::meta::types::GetEdgeReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::GetEdgeResp, crate::fbthrift_protocol::meta::services::meta_service::GetEdgeExn> {
            (**self).getEdge(
                req,
            ).await
        }
        async fn listEdges(
            &self,
            req: crate::fbthrift_protocol::meta::types::ListEdgesReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ListEdgesResp, crate::fbthrift_protocol::meta::services::meta_service::ListEdgesExn> {
            (**self).listEdges(
                req,
            ).await
        }
        async fn addHosts(
            &self,
            req: crate::fbthrift_protocol::meta::types::AddHostsReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::AddHostsExn> {
            (**self).addHosts(
                req,
            ).await
        }
        async fn addHostsIntoZone(
            &self,
            req: crate::fbthrift_protocol::meta::types::AddHostsIntoZoneReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::AddHostsIntoZoneExn> {
            (**self).addHostsIntoZone(
                req,
            ).await
        }
        async fn dropHosts(
            &self,
            req: crate::fbthrift_protocol::meta::types::DropHostsReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::DropHostsExn> {
            (**self).dropHosts(
                req,
            ).await
        }
        async fn listHosts(
            &self,
            req: crate::fbthrift_protocol::meta::types::ListHostsReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ListHostsResp, crate::fbthrift_protocol::meta::services::meta_service::ListHostsExn> {
            (**self).listHosts(
                req,
            ).await
        }
        async fn getPartsAlloc(
            &self,
            req: crate::fbthrift_protocol::meta::types::GetPartsAllocReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::GetPartsAllocResp, crate::fbthrift_protocol::meta::services::meta_service::GetPartsAllocExn> {
            (**self).getPartsAlloc(
                req,
            ).await
        }
        async fn listParts(
            &self,
            req: crate::fbthrift_protocol::meta::types::ListPartsReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ListPartsResp, crate::fbthrift_protocol::meta::services::meta_service::ListPartsExn> {
            (**self).listParts(
                req,
            ).await
        }
        async fn getWorkerId(
            &self,
            req: crate::fbthrift_protocol::meta::types::GetWorkerIdReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::GetWorkerIdResp, crate::fbthrift_protocol::meta::services::meta_service::GetWorkerIdExn> {
            (**self).getWorkerId(
                req,
            ).await
        }
        async fn createTagIndex(
            &self,
            req: crate::fbthrift_protocol::meta::types::CreateTagIndexReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::CreateTagIndexExn> {
            (**self).createTagIndex(
                req,
            ).await
        }
        async fn dropTagIndex(
            &self,
            req: crate::fbthrift_protocol::meta::types::DropTagIndexReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::DropTagIndexExn> {
            (**self).dropTagIndex(
                req,
            ).await
        }
        async fn getTagIndex(
            &self,
            req: crate::fbthrift_protocol::meta::types::GetTagIndexReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::GetTagIndexResp, crate::fbthrift_protocol::meta::services::meta_service::GetTagIndexExn> {
            (**self).getTagIndex(
                req,
            ).await
        }
        async fn listTagIndexes(
            &self,
            req: crate::fbthrift_protocol::meta::types::ListTagIndexesReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ListTagIndexesResp, crate::fbthrift_protocol::meta::services::meta_service::ListTagIndexesExn> {
            (**self).listTagIndexes(
                req,
            ).await
        }
        async fn rebuildTagIndex(
            &self,
            req: crate::fbthrift_protocol::meta::types::RebuildIndexReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::RebuildTagIndexExn> {
            (**self).rebuildTagIndex(
                req,
            ).await
        }
        async fn listTagIndexStatus(
            &self,
            req: crate::fbthrift_protocol::meta::types::ListIndexStatusReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ListIndexStatusResp, crate::fbthrift_protocol::meta::services::meta_service::ListTagIndexStatusExn> {
            (**self).listTagIndexStatus(
                req,
            ).await
        }
        async fn createEdgeIndex(
            &self,
            req: crate::fbthrift_protocol::meta::types::CreateEdgeIndexReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::CreateEdgeIndexExn> {
            (**self).createEdgeIndex(
                req,
            ).await
        }
        async fn dropEdgeIndex(
            &self,
            req: crate::fbthrift_protocol::meta::types::DropEdgeIndexReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::DropEdgeIndexExn> {
            (**self).dropEdgeIndex(
                req,
            ).await
        }
        async fn getEdgeIndex(
            &self,
            req: crate::fbthrift_protocol::meta::types::GetEdgeIndexReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::GetEdgeIndexResp, crate::fbthrift_protocol::meta::services::meta_service::GetEdgeIndexExn> {
            (**self).getEdgeIndex(
                req,
            ).await
        }
        async fn listEdgeIndexes(
            &self,
            req: crate::fbthrift_protocol::meta::types::ListEdgeIndexesReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ListEdgeIndexesResp, crate::fbthrift_protocol::meta::services::meta_service::ListEdgeIndexesExn> {
            (**self).listEdgeIndexes(
                req,
            ).await
        }
        async fn rebuildEdgeIndex(
            &self,
            req: crate::fbthrift_protocol::meta::types::RebuildIndexReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::RebuildEdgeIndexExn> {
            (**self).rebuildEdgeIndex(
                req,
            ).await
        }
        async fn listEdgeIndexStatus(
            &self,
            req: crate::fbthrift_protocol::meta::types::ListIndexStatusReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ListIndexStatusResp, crate::fbthrift_protocol::meta::services::meta_service::ListEdgeIndexStatusExn> {
            (**self).listEdgeIndexStatus(
                req,
            ).await
        }
        async fn createUser(
            &self,
            req: crate::fbthrift_protocol::meta::types::CreateUserReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::CreateUserExn> {
            (**self).createUser(
                req,
            ).await
        }
        async fn dropUser(
            &self,
            req: crate::fbthrift_protocol::meta::types::DropUserReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::DropUserExn> {
            (**self).dropUser(
                req,
            ).await
        }
        async fn alterUser(
            &self,
            req: crate::fbthrift_protocol::meta::types::AlterUserReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::AlterUserExn> {
            (**self).alterUser(
                req,
            ).await
        }
        async fn grantRole(
            &self,
            req: crate::fbthrift_protocol::meta::types::GrantRoleReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::GrantRoleExn> {
            (**self).grantRole(
                req,
            ).await
        }
        async fn revokeRole(
            &self,
            req: crate::fbthrift_protocol::meta::types::RevokeRoleReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::RevokeRoleExn> {
            (**self).revokeRole(
                req,
            ).await
        }
        async fn listUsers(
            &self,
            req: crate::fbthrift_protocol::meta::types::ListUsersReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ListUsersResp, crate::fbthrift_protocol::meta::services::meta_service::ListUsersExn> {
            (**self).listUsers(
                req,
            ).await
        }
        async fn listRoles(
            &self,
            req: crate::fbthrift_protocol::meta::types::ListRolesReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ListRolesResp, crate::fbthrift_protocol::meta::services::meta_service::ListRolesExn> {
            (**self).listRoles(
                req,
            ).await
        }
        async fn getUserRoles(
            &self,
            req: crate::fbthrift_protocol::meta::types::GetUserRolesReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ListRolesResp, crate::fbthrift_protocol::meta::services::meta_service::GetUserRolesExn> {
            (**self).getUserRoles(
                req,
            ).await
        }
        async fn changePassword(
            &self,
            req: crate::fbthrift_protocol::meta::types::ChangePasswordReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::ChangePasswordExn> {
            (**self).changePassword(
                req,
            ).await
        }
        async fn heartBeat(
            &self,
            req: crate::fbthrift_protocol::meta::types::HBReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::HBResp, crate::fbthrift_protocol::meta::services::meta_service::HeartBeatExn> {
            (**self).heartBeat(
                req,
            ).await
        }
        async fn agentHeartbeat(
            &self,
            req: crate::fbthrift_protocol::meta::types::AgentHBReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::AgentHBResp, crate::fbthrift_protocol::meta::services::meta_service::AgentHeartbeatExn> {
            (**self).agentHeartbeat(
                req,
            ).await
        }
        async fn regConfig(
            &self,
            req: crate::fbthrift_protocol::meta::types::RegConfigReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::RegConfigExn> {
            (**self).regConfig(
                req,
            ).await
        }
        async fn getConfig(
            &self,
            req: crate::fbthrift_protocol::meta::types::GetConfigReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::GetConfigResp, crate::fbthrift_protocol::meta::services::meta_service::GetConfigExn> {
            (**self).getConfig(
                req,
            ).await
        }
        async fn setConfig(
            &self,
            req: crate::fbthrift_protocol::meta::types::SetConfigReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::SetConfigExn> {
            (**self).setConfig(
                req,
            ).await
        }
        async fn listConfigs(
            &self,
            req: crate::fbthrift_protocol::meta::types::ListConfigsReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ListConfigsResp, crate::fbthrift_protocol::meta::services::meta_service::ListConfigsExn> {
            (**self).listConfigs(
                req,
            ).await
        }
        async fn createSnapshot(
            &self,
            req: crate::fbthrift_protocol::meta::types::CreateSnapshotReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::CreateSnapshotExn> {
            (**self).createSnapshot(
                req,
            ).await
        }
        async fn dropSnapshot(
            &self,
            req: crate::fbthrift_protocol::meta::types::DropSnapshotReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::DropSnapshotExn> {
            (**self).dropSnapshot(
                req,
            ).await
        }
        async fn listSnapshots(
            &self,
            req: crate::fbthrift_protocol::meta::types::ListSnapshotsReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ListSnapshotsResp, crate::fbthrift_protocol::meta::services::meta_service::ListSnapshotsExn> {
            (**self).listSnapshots(
                req,
            ).await
        }
        async fn runAdminJob(
            &self,
            req: crate::fbthrift_protocol::meta::types::AdminJobReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::AdminJobResp, crate::fbthrift_protocol::meta::services::meta_service::RunAdminJobExn> {
            (**self).runAdminJob(
                req,
            ).await
        }
        async fn mergeZone(
            &self,
            req: crate::fbthrift_protocol::meta::types::MergeZoneReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::MergeZoneExn> {
            (**self).mergeZone(
                req,
            ).await
        }
        async fn dropZone(
            &self,
            req: crate::fbthrift_protocol::meta::types::DropZoneReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::DropZoneExn> {
            (**self).dropZone(
                req,
            ).await
        }
        async fn divideZone(
            &self,
            req: crate::fbthrift_protocol::meta::types::DivideZoneReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::DivideZoneExn> {
            (**self).divideZone(
                req,
            ).await
        }
        async fn renameZone(
            &self,
            req: crate::fbthrift_protocol::meta::types::RenameZoneReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::RenameZoneExn> {
            (**self).renameZone(
                req,
            ).await
        }
        async fn getZone(
            &self,
            req: crate::fbthrift_protocol::meta::types::GetZoneReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::GetZoneResp, crate::fbthrift_protocol::meta::services::meta_service::GetZoneExn> {
            (**self).getZone(
                req,
            ).await
        }
        async fn listZones(
            &self,
            req: crate::fbthrift_protocol::meta::types::ListZonesReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ListZonesResp, crate::fbthrift_protocol::meta::services::meta_service::ListZonesExn> {
            (**self).listZones(
                req,
            ).await
        }
        async fn addListener(
            &self,
            req: crate::fbthrift_protocol::meta::types::AddListenerReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::AddListenerExn> {
            (**self).addListener(
                req,
            ).await
        }
        async fn removeListener(
            &self,
            req: crate::fbthrift_protocol::meta::types::RemoveListenerReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::RemoveListenerExn> {
            (**self).removeListener(
                req,
            ).await
        }
        async fn listListener(
            &self,
            req: crate::fbthrift_protocol::meta::types::ListListenerReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ListListenerResp, crate::fbthrift_protocol::meta::services::meta_service::ListListenerExn> {
            (**self).listListener(
                req,
            ).await
        }
        async fn getStats(
            &self,
            req: crate::fbthrift_protocol::meta::types::GetStatsReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::GetStatsResp, crate::fbthrift_protocol::meta::services::meta_service::GetStatsExn> {
            (**self).getStats(
                req,
            ).await
        }
        async fn signInService(
            &self,
            req: crate::fbthrift_protocol::meta::types::SignInServiceReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::SignInServiceExn> {
            (**self).signInService(
                req,
            ).await
        }
        async fn signOutService(
            &self,
            req: crate::fbthrift_protocol::meta::types::SignOutServiceReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::SignOutServiceExn> {
            (**self).signOutService(
                req,
            ).await
        }
        async fn listServiceClients(
            &self,
            req: crate::fbthrift_protocol::meta::types::ListServiceClientsReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ListServiceClientsResp, crate::fbthrift_protocol::meta::services::meta_service::ListServiceClientsExn> {
            (**self).listServiceClients(
                req,
            ).await
        }
        async fn createFTIndex(
            &self,
            req: crate::fbthrift_protocol::meta::types::CreateFTIndexReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::CreateFTIndexExn> {
            (**self).createFTIndex(
                req,
            ).await
        }
        async fn dropFTIndex(
            &self,
            req: crate::fbthrift_protocol::meta::types::DropFTIndexReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::DropFTIndexExn> {
            (**self).dropFTIndex(
                req,
            ).await
        }
        async fn listFTIndexes(
            &self,
            req: crate::fbthrift_protocol::meta::types::ListFTIndexesReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ListFTIndexesResp, crate::fbthrift_protocol::meta::services::meta_service::ListFTIndexesExn> {
            (**self).listFTIndexes(
                req,
            ).await
        }
        async fn createSession(
            &self,
            req: crate::fbthrift_protocol::meta::types::CreateSessionReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::CreateSessionResp, crate::fbthrift_protocol::meta::services::meta_service::CreateSessionExn> {
            (**self).createSession(
                req,
            ).await
        }
        async fn updateSessions(
            &self,
            req: crate::fbthrift_protocol::meta::types::UpdateSessionsReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::UpdateSessionsResp, crate::fbthrift_protocol::meta::services::meta_service::UpdateSessionsExn> {
            (**self).updateSessions(
                req,
            ).await
        }
        async fn listSessions(
            &self,
            req: crate::fbthrift_protocol::meta::types::ListSessionsReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ListSessionsResp, crate::fbthrift_protocol::meta::services::meta_service::ListSessionsExn> {
            (**self).listSessions(
                req,
            ).await
        }
        async fn getSession(
            &self,
            req: crate::fbthrift_protocol::meta::types::GetSessionReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::GetSessionResp, crate::fbthrift_protocol::meta::services::meta_service::GetSessionExn> {
            (**self).getSession(
                req,
            ).await
        }
        async fn removeSession(
            &self,
            req: crate::fbthrift_protocol::meta::types::RemoveSessionReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::RemoveSessionExn> {
            (**self).removeSession(
                req,
            ).await
        }
        async fn killQuery(
            &self,
            req: crate::fbthrift_protocol::meta::types::KillQueryReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::KillQueryExn> {
            (**self).killQuery(
                req,
            ).await
        }
        async fn reportTaskFinish(
            &self,
            req: crate::fbthrift_protocol::meta::types::ReportTaskReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::services::meta_service::ReportTaskFinishExn> {
            (**self).reportTaskFinish(
                req,
            ).await
        }
        async fn createBackup(
            &self,
            req: crate::fbthrift_protocol::meta::types::CreateBackupReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::CreateBackupResp, crate::fbthrift_protocol::meta::services::meta_service::CreateBackupExn> {
            (**self).createBackup(
                req,
            ).await
        }
        async fn restoreMeta(
            &self,
            req: crate::fbthrift_protocol::meta::types::RestoreMetaReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::RestoreMetaResp, crate::fbthrift_protocol::meta::services::meta_service::RestoreMetaExn> {
            (**self).restoreMeta(
                req,
            ).await
        }
        async fn listCluster(
            &self,
            req: crate::fbthrift_protocol::meta::types::ListClusterInfoReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ListClusterInfoResp, crate::fbthrift_protocol::meta::services::meta_service::ListClusterExn> {
            (**self).listCluster(
                req,
            ).await
        }
        async fn getMetaDirInfo(
            &self,
            req: crate::fbthrift_protocol::meta::types::GetMetaDirInfoReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::GetMetaDirInfoResp, crate::fbthrift_protocol::meta::services::meta_service::GetMetaDirInfoExn> {
            (**self).getMetaDirInfo(
                req,
            ).await
        }
        async fn verifyClientVersion(
            &self,
            req: crate::fbthrift_protocol::meta::types::VerifyClientVersionReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::VerifyClientVersionResp, crate::fbthrift_protocol::meta::services::meta_service::VerifyClientVersionExn> {
            (**self).verifyClientVersion(
                req,
            ).await
        }
        async fn saveGraphVersion(
            &self,
            req: crate::fbthrift_protocol::meta::types::SaveGraphVersionReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::SaveGraphVersionResp, crate::fbthrift_protocol::meta::services::meta_service::SaveGraphVersionExn> {
            (**self).saveGraphVersion(
                req,
            ).await
        }
        async fn getSegmentId(
            &self,
            req: crate::fbthrift_protocol::meta::types::GetSegmentIdReq,
        ) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::GetSegmentIdResp, crate::fbthrift_protocol::meta::services::meta_service::GetSegmentIdExn> {
            (**self).getSegmentId(
                req,
            ).await
        }
    }

    /// Processor for MetaService's methods.
    #[derive(Clone, Debug)]
    pub struct MetaServiceProcessor<P, H, R, RS> {
        service: H,
        supa: crate::fbthrift::NullServiceProcessor<P, R, RS>,
        _phantom: ::std::marker::PhantomData<(P, H, R, RS)>,
    }

    struct Args_MetaService_createSpace {
        req: crate::fbthrift_protocol::meta::types::CreateSpaceReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_createSpace {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.createSpace"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.createSpace", "req"))?,
            })
        }
    }

    struct Args_MetaService_dropSpace {
        req: crate::fbthrift_protocol::meta::types::DropSpaceReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_dropSpace {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.dropSpace"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.dropSpace", "req"))?,
            })
        }
    }

    struct Args_MetaService_clearSpace {
        req: crate::fbthrift_protocol::meta::types::ClearSpaceReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_clearSpace {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.clearSpace"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.clearSpace", "req"))?,
            })
        }
    }

    struct Args_MetaService_getSpace {
        req: crate::fbthrift_protocol::meta::types::GetSpaceReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_getSpace {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.getSpace"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.getSpace", "req"))?,
            })
        }
    }

    struct Args_MetaService_listSpaces {
        req: crate::fbthrift_protocol::meta::types::ListSpacesReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_listSpaces {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.listSpaces"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.listSpaces", "req"))?,
            })
        }
    }

    struct Args_MetaService_alterSpace {
        req: crate::fbthrift_protocol::meta::types::AlterSpaceReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_alterSpace {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.alterSpace"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.alterSpace", "req"))?,
            })
        }
    }

    struct Args_MetaService_createSpaceAs {
        req: crate::fbthrift_protocol::meta::types::CreateSpaceAsReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_createSpaceAs {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.createSpaceAs"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.createSpaceAs", "req"))?,
            })
        }
    }

    struct Args_MetaService_createTag {
        req: crate::fbthrift_protocol::meta::types::CreateTagReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_createTag {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.createTag"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.createTag", "req"))?,
            })
        }
    }

    struct Args_MetaService_alterTag {
        req: crate::fbthrift_protocol::meta::types::AlterTagReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_alterTag {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.alterTag"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.alterTag", "req"))?,
            })
        }
    }

    struct Args_MetaService_dropTag {
        req: crate::fbthrift_protocol::meta::types::DropTagReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_dropTag {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.dropTag"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.dropTag", "req"))?,
            })
        }
    }

    struct Args_MetaService_getTag {
        req: crate::fbthrift_protocol::meta::types::GetTagReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_getTag {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.getTag"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.getTag", "req"))?,
            })
        }
    }

    struct Args_MetaService_listTags {
        req: crate::fbthrift_protocol::meta::types::ListTagsReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_listTags {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.listTags"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.listTags", "req"))?,
            })
        }
    }

    struct Args_MetaService_createEdge {
        req: crate::fbthrift_protocol::meta::types::CreateEdgeReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_createEdge {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.createEdge"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.createEdge", "req"))?,
            })
        }
    }

    struct Args_MetaService_alterEdge {
        req: crate::fbthrift_protocol::meta::types::AlterEdgeReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_alterEdge {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.alterEdge"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.alterEdge", "req"))?,
            })
        }
    }

    struct Args_MetaService_dropEdge {
        req: crate::fbthrift_protocol::meta::types::DropEdgeReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_dropEdge {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.dropEdge"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.dropEdge", "req"))?,
            })
        }
    }

    struct Args_MetaService_getEdge {
        req: crate::fbthrift_protocol::meta::types::GetEdgeReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_getEdge {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.getEdge"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.getEdge", "req"))?,
            })
        }
    }

    struct Args_MetaService_listEdges {
        req: crate::fbthrift_protocol::meta::types::ListEdgesReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_listEdges {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.listEdges"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.listEdges", "req"))?,
            })
        }
    }

    struct Args_MetaService_addHosts {
        req: crate::fbthrift_protocol::meta::types::AddHostsReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_addHosts {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.addHosts"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.addHosts", "req"))?,
            })
        }
    }

    struct Args_MetaService_addHostsIntoZone {
        req: crate::fbthrift_protocol::meta::types::AddHostsIntoZoneReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_addHostsIntoZone {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.addHostsIntoZone"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.addHostsIntoZone", "req"))?,
            })
        }
    }

    struct Args_MetaService_dropHosts {
        req: crate::fbthrift_protocol::meta::types::DropHostsReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_dropHosts {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.dropHosts"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.dropHosts", "req"))?,
            })
        }
    }

    struct Args_MetaService_listHosts {
        req: crate::fbthrift_protocol::meta::types::ListHostsReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_listHosts {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.listHosts"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.listHosts", "req"))?,
            })
        }
    }

    struct Args_MetaService_getPartsAlloc {
        req: crate::fbthrift_protocol::meta::types::GetPartsAllocReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_getPartsAlloc {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.getPartsAlloc"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.getPartsAlloc", "req"))?,
            })
        }
    }

    struct Args_MetaService_listParts {
        req: crate::fbthrift_protocol::meta::types::ListPartsReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_listParts {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.listParts"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.listParts", "req"))?,
            })
        }
    }

    struct Args_MetaService_getWorkerId {
        req: crate::fbthrift_protocol::meta::types::GetWorkerIdReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_getWorkerId {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.getWorkerId"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.getWorkerId", "req"))?,
            })
        }
    }

    struct Args_MetaService_createTagIndex {
        req: crate::fbthrift_protocol::meta::types::CreateTagIndexReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_createTagIndex {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.createTagIndex"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.createTagIndex", "req"))?,
            })
        }
    }

    struct Args_MetaService_dropTagIndex {
        req: crate::fbthrift_protocol::meta::types::DropTagIndexReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_dropTagIndex {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.dropTagIndex"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.dropTagIndex", "req"))?,
            })
        }
    }

    struct Args_MetaService_getTagIndex {
        req: crate::fbthrift_protocol::meta::types::GetTagIndexReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_getTagIndex {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.getTagIndex"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.getTagIndex", "req"))?,
            })
        }
    }

    struct Args_MetaService_listTagIndexes {
        req: crate::fbthrift_protocol::meta::types::ListTagIndexesReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_listTagIndexes {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.listTagIndexes"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.listTagIndexes", "req"))?,
            })
        }
    }

    struct Args_MetaService_rebuildTagIndex {
        req: crate::fbthrift_protocol::meta::types::RebuildIndexReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_rebuildTagIndex {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.rebuildTagIndex"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.rebuildTagIndex", "req"))?,
            })
        }
    }

    struct Args_MetaService_listTagIndexStatus {
        req: crate::fbthrift_protocol::meta::types::ListIndexStatusReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_listTagIndexStatus {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.listTagIndexStatus"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.listTagIndexStatus", "req"))?,
            })
        }
    }

    struct Args_MetaService_createEdgeIndex {
        req: crate::fbthrift_protocol::meta::types::CreateEdgeIndexReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_createEdgeIndex {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.createEdgeIndex"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.createEdgeIndex", "req"))?,
            })
        }
    }

    struct Args_MetaService_dropEdgeIndex {
        req: crate::fbthrift_protocol::meta::types::DropEdgeIndexReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_dropEdgeIndex {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.dropEdgeIndex"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.dropEdgeIndex", "req"))?,
            })
        }
    }

    struct Args_MetaService_getEdgeIndex {
        req: crate::fbthrift_protocol::meta::types::GetEdgeIndexReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_getEdgeIndex {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.getEdgeIndex"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.getEdgeIndex", "req"))?,
            })
        }
    }

    struct Args_MetaService_listEdgeIndexes {
        req: crate::fbthrift_protocol::meta::types::ListEdgeIndexesReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_listEdgeIndexes {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.listEdgeIndexes"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.listEdgeIndexes", "req"))?,
            })
        }
    }

    struct Args_MetaService_rebuildEdgeIndex {
        req: crate::fbthrift_protocol::meta::types::RebuildIndexReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_rebuildEdgeIndex {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.rebuildEdgeIndex"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.rebuildEdgeIndex", "req"))?,
            })
        }
    }

    struct Args_MetaService_listEdgeIndexStatus {
        req: crate::fbthrift_protocol::meta::types::ListIndexStatusReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_listEdgeIndexStatus {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.listEdgeIndexStatus"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.listEdgeIndexStatus", "req"))?,
            })
        }
    }

    struct Args_MetaService_createUser {
        req: crate::fbthrift_protocol::meta::types::CreateUserReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_createUser {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.createUser"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.createUser", "req"))?,
            })
        }
    }

    struct Args_MetaService_dropUser {
        req: crate::fbthrift_protocol::meta::types::DropUserReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_dropUser {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.dropUser"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.dropUser", "req"))?,
            })
        }
    }

    struct Args_MetaService_alterUser {
        req: crate::fbthrift_protocol::meta::types::AlterUserReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_alterUser {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.alterUser"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.alterUser", "req"))?,
            })
        }
    }

    struct Args_MetaService_grantRole {
        req: crate::fbthrift_protocol::meta::types::GrantRoleReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_grantRole {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.grantRole"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.grantRole", "req"))?,
            })
        }
    }

    struct Args_MetaService_revokeRole {
        req: crate::fbthrift_protocol::meta::types::RevokeRoleReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_revokeRole {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.revokeRole"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.revokeRole", "req"))?,
            })
        }
    }

    struct Args_MetaService_listUsers {
        req: crate::fbthrift_protocol::meta::types::ListUsersReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_listUsers {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.listUsers"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.listUsers", "req"))?,
            })
        }
    }

    struct Args_MetaService_listRoles {
        req: crate::fbthrift_protocol::meta::types::ListRolesReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_listRoles {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.listRoles"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.listRoles", "req"))?,
            })
        }
    }

    struct Args_MetaService_getUserRoles {
        req: crate::fbthrift_protocol::meta::types::GetUserRolesReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_getUserRoles {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.getUserRoles"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.getUserRoles", "req"))?,
            })
        }
    }

    struct Args_MetaService_changePassword {
        req: crate::fbthrift_protocol::meta::types::ChangePasswordReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_changePassword {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.changePassword"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.changePassword", "req"))?,
            })
        }
    }

    struct Args_MetaService_heartBeat {
        req: crate::fbthrift_protocol::meta::types::HBReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_heartBeat {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.heartBeat"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.heartBeat", "req"))?,
            })
        }
    }

    struct Args_MetaService_agentHeartbeat {
        req: crate::fbthrift_protocol::meta::types::AgentHBReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_agentHeartbeat {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.agentHeartbeat"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.agentHeartbeat", "req"))?,
            })
        }
    }

    struct Args_MetaService_regConfig {
        req: crate::fbthrift_protocol::meta::types::RegConfigReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_regConfig {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.regConfig"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.regConfig", "req"))?,
            })
        }
    }

    struct Args_MetaService_getConfig {
        req: crate::fbthrift_protocol::meta::types::GetConfigReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_getConfig {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.getConfig"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.getConfig", "req"))?,
            })
        }
    }

    struct Args_MetaService_setConfig {
        req: crate::fbthrift_protocol::meta::types::SetConfigReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_setConfig {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.setConfig"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.setConfig", "req"))?,
            })
        }
    }

    struct Args_MetaService_listConfigs {
        req: crate::fbthrift_protocol::meta::types::ListConfigsReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_listConfigs {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.listConfigs"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.listConfigs", "req"))?,
            })
        }
    }

    struct Args_MetaService_createSnapshot {
        req: crate::fbthrift_protocol::meta::types::CreateSnapshotReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_createSnapshot {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.createSnapshot"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.createSnapshot", "req"))?,
            })
        }
    }

    struct Args_MetaService_dropSnapshot {
        req: crate::fbthrift_protocol::meta::types::DropSnapshotReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_dropSnapshot {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.dropSnapshot"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.dropSnapshot", "req"))?,
            })
        }
    }

    struct Args_MetaService_listSnapshots {
        req: crate::fbthrift_protocol::meta::types::ListSnapshotsReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_listSnapshots {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.listSnapshots"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.listSnapshots", "req"))?,
            })
        }
    }

    struct Args_MetaService_runAdminJob {
        req: crate::fbthrift_protocol::meta::types::AdminJobReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_runAdminJob {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.runAdminJob"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.runAdminJob", "req"))?,
            })
        }
    }

    struct Args_MetaService_mergeZone {
        req: crate::fbthrift_protocol::meta::types::MergeZoneReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_mergeZone {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.mergeZone"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.mergeZone", "req"))?,
            })
        }
    }

    struct Args_MetaService_dropZone {
        req: crate::fbthrift_protocol::meta::types::DropZoneReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_dropZone {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.dropZone"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.dropZone", "req"))?,
            })
        }
    }

    struct Args_MetaService_divideZone {
        req: crate::fbthrift_protocol::meta::types::DivideZoneReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_divideZone {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.divideZone"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.divideZone", "req"))?,
            })
        }
    }

    struct Args_MetaService_renameZone {
        req: crate::fbthrift_protocol::meta::types::RenameZoneReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_renameZone {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.renameZone"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.renameZone", "req"))?,
            })
        }
    }

    struct Args_MetaService_getZone {
        req: crate::fbthrift_protocol::meta::types::GetZoneReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_getZone {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.getZone"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.getZone", "req"))?,
            })
        }
    }

    struct Args_MetaService_listZones {
        req: crate::fbthrift_protocol::meta::types::ListZonesReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_listZones {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.listZones"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.listZones", "req"))?,
            })
        }
    }

    struct Args_MetaService_addListener {
        req: crate::fbthrift_protocol::meta::types::AddListenerReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_addListener {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.addListener"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.addListener", "req"))?,
            })
        }
    }

    struct Args_MetaService_removeListener {
        req: crate::fbthrift_protocol::meta::types::RemoveListenerReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_removeListener {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.removeListener"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.removeListener", "req"))?,
            })
        }
    }

    struct Args_MetaService_listListener {
        req: crate::fbthrift_protocol::meta::types::ListListenerReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_listListener {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.listListener"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.listListener", "req"))?,
            })
        }
    }

    struct Args_MetaService_getStats {
        req: crate::fbthrift_protocol::meta::types::GetStatsReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_getStats {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.getStats"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.getStats", "req"))?,
            })
        }
    }

    struct Args_MetaService_signInService {
        req: crate::fbthrift_protocol::meta::types::SignInServiceReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_signInService {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.signInService"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.signInService", "req"))?,
            })
        }
    }

    struct Args_MetaService_signOutService {
        req: crate::fbthrift_protocol::meta::types::SignOutServiceReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_signOutService {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.signOutService"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.signOutService", "req"))?,
            })
        }
    }

    struct Args_MetaService_listServiceClients {
        req: crate::fbthrift_protocol::meta::types::ListServiceClientsReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_listServiceClients {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.listServiceClients"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.listServiceClients", "req"))?,
            })
        }
    }

    struct Args_MetaService_createFTIndex {
        req: crate::fbthrift_protocol::meta::types::CreateFTIndexReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_createFTIndex {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.createFTIndex"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.createFTIndex", "req"))?,
            })
        }
    }

    struct Args_MetaService_dropFTIndex {
        req: crate::fbthrift_protocol::meta::types::DropFTIndexReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_dropFTIndex {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.dropFTIndex"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.dropFTIndex", "req"))?,
            })
        }
    }

    struct Args_MetaService_listFTIndexes {
        req: crate::fbthrift_protocol::meta::types::ListFTIndexesReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_listFTIndexes {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.listFTIndexes"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.listFTIndexes", "req"))?,
            })
        }
    }

    struct Args_MetaService_createSession {
        req: crate::fbthrift_protocol::meta::types::CreateSessionReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_createSession {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.createSession"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.createSession", "req"))?,
            })
        }
    }

    struct Args_MetaService_updateSessions {
        req: crate::fbthrift_protocol::meta::types::UpdateSessionsReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_updateSessions {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.updateSessions"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.updateSessions", "req"))?,
            })
        }
    }

    struct Args_MetaService_listSessions {
        req: crate::fbthrift_protocol::meta::types::ListSessionsReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_listSessions {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.listSessions"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.listSessions", "req"))?,
            })
        }
    }

    struct Args_MetaService_getSession {
        req: crate::fbthrift_protocol::meta::types::GetSessionReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_getSession {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.getSession"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.getSession", "req"))?,
            })
        }
    }

    struct Args_MetaService_removeSession {
        req: crate::fbthrift_protocol::meta::types::RemoveSessionReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_removeSession {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.removeSession"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.removeSession", "req"))?,
            })
        }
    }

    struct Args_MetaService_killQuery {
        req: crate::fbthrift_protocol::meta::types::KillQueryReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_killQuery {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.killQuery"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.killQuery", "req"))?,
            })
        }
    }

    struct Args_MetaService_reportTaskFinish {
        req: crate::fbthrift_protocol::meta::types::ReportTaskReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_reportTaskFinish {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.reportTaskFinish"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.reportTaskFinish", "req"))?,
            })
        }
    }

    struct Args_MetaService_createBackup {
        req: crate::fbthrift_protocol::meta::types::CreateBackupReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_createBackup {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.createBackup"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.createBackup", "req"))?,
            })
        }
    }

    struct Args_MetaService_restoreMeta {
        req: crate::fbthrift_protocol::meta::types::RestoreMetaReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_restoreMeta {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.restoreMeta"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.restoreMeta", "req"))?,
            })
        }
    }

    struct Args_MetaService_listCluster {
        req: crate::fbthrift_protocol::meta::types::ListClusterInfoReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_listCluster {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.listCluster"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.listCluster", "req"))?,
            })
        }
    }

    struct Args_MetaService_getMetaDirInfo {
        req: crate::fbthrift_protocol::meta::types::GetMetaDirInfoReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_getMetaDirInfo {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.getMetaDirInfo"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.getMetaDirInfo", "req"))?,
            })
        }
    }

    struct Args_MetaService_verifyClientVersion {
        req: crate::fbthrift_protocol::meta::types::VerifyClientVersionReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_verifyClientVersion {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.verifyClientVersion"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.verifyClientVersion", "req"))?,
            })
        }
    }

    struct Args_MetaService_saveGraphVersion {
        req: crate::fbthrift_protocol::meta::types::SaveGraphVersionReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_saveGraphVersion {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.saveGraphVersion"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.saveGraphVersion", "req"))?,
            })
        }
    }

    struct Args_MetaService_getSegmentId {
        req: crate::fbthrift_protocol::meta::types::GetSegmentIdReq,
    }
    impl<P: crate::fbthrift::ProtocolReader> crate::fbthrift::Deserialize<P> for self::Args_MetaService_getSegmentId {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MetaService.getSegmentId"))]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static ARGS: &[crate::fbthrift::Field] = &[
                crate::fbthrift::Field::new("req", crate::fbthrift::TType::Struct, 1),
            ];
            let mut field_req = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (crate::fbthrift::TType::Stop, _) => break,
                    (crate::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(crate::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MetaService.getSegmentId", "req"))?,
            })
        }
    }


    impl<P, H, R, RS> MetaServiceProcessor<P, H, R, RS>
    where
        P: crate::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Frame: ::std::marker::Send + 'static,
        P::Deserializer: ::std::marker::Send,
        H: MetaService,
        R: crate::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        RS: crate::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as crate::fbthrift::RequestContext>::ContextStack: crate::fbthrift::ContextStack<Name = R::Name, Buffer = crate::fbthrift::ProtocolDecoded<P>>
            + ::std::marker::Send + ::std::marker::Sync,
    {
        pub fn new(service: H) -> Self {
            Self {
                service,
                supa: crate::fbthrift::NullServiceProcessor::new(),
                _phantom: ::std::marker::PhantomData,
            }
        }

        pub fn into_inner(self) -> H {
            self.service
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.createSpace"))]
        async fn handle_createSpace<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createSpace";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_createSpace = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.createSpace(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::CreateSpaceExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::CreateSpaceExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "createSpace",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.createSpace", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::CreateSpaceExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "createSpace",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.dropSpace"))]
        async fn handle_dropSpace<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropSpace";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_dropSpace = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.dropSpace(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::DropSpaceExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::DropSpaceExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "dropSpace",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.dropSpace", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::DropSpaceExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "dropSpace",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.clearSpace"))]
        async fn handle_clearSpace<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.clearSpace";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_clearSpace = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.clearSpace(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::ClearSpaceExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::ClearSpaceExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "clearSpace",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.clearSpace", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::ClearSpaceExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "clearSpace",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.getSpace"))]
        async fn handle_getSpace<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getSpace";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_getSpace = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.getSpace(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::GetSpaceExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::GetSpaceExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getSpace",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.getSpace", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::GetSpaceExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "getSpace",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.listSpaces"))]
        async fn handle_listSpaces<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listSpaces";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_listSpaces = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.listSpaces(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::ListSpacesExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::ListSpacesExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listSpaces",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.listSpaces", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::ListSpacesExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "listSpaces",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.alterSpace"))]
        async fn handle_alterSpace<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.alterSpace";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_alterSpace = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.alterSpace(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::AlterSpaceExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::AlterSpaceExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "alterSpace",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.alterSpace", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::AlterSpaceExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "alterSpace",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.createSpaceAs"))]
        async fn handle_createSpaceAs<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createSpaceAs";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_createSpaceAs = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.createSpaceAs(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::CreateSpaceAsExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::CreateSpaceAsExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "createSpaceAs",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.createSpaceAs", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::CreateSpaceAsExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "createSpaceAs",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.createTag"))]
        async fn handle_createTag<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createTag";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_createTag = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.createTag(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::CreateTagExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::CreateTagExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "createTag",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.createTag", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::CreateTagExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "createTag",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.alterTag"))]
        async fn handle_alterTag<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.alterTag";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_alterTag = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.alterTag(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::AlterTagExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::AlterTagExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "alterTag",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.alterTag", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::AlterTagExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "alterTag",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.dropTag"))]
        async fn handle_dropTag<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropTag";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_dropTag = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.dropTag(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::DropTagExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::DropTagExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "dropTag",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.dropTag", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::DropTagExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "dropTag",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.getTag"))]
        async fn handle_getTag<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getTag";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_getTag = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.getTag(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::GetTagExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::GetTagExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getTag",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.getTag", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::GetTagExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "getTag",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.listTags"))]
        async fn handle_listTags<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listTags";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_listTags = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.listTags(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::ListTagsExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::ListTagsExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listTags",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.listTags", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::ListTagsExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "listTags",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.createEdge"))]
        async fn handle_createEdge<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createEdge";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_createEdge = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.createEdge(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::CreateEdgeExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::CreateEdgeExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "createEdge",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.createEdge", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::CreateEdgeExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "createEdge",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.alterEdge"))]
        async fn handle_alterEdge<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.alterEdge";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_alterEdge = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.alterEdge(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::AlterEdgeExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::AlterEdgeExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "alterEdge",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.alterEdge", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::AlterEdgeExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "alterEdge",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.dropEdge"))]
        async fn handle_dropEdge<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropEdge";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_dropEdge = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.dropEdge(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::DropEdgeExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::DropEdgeExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "dropEdge",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.dropEdge", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::DropEdgeExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "dropEdge",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.getEdge"))]
        async fn handle_getEdge<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getEdge";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_getEdge = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.getEdge(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::GetEdgeExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::GetEdgeExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getEdge",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.getEdge", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::GetEdgeExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "getEdge",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.listEdges"))]
        async fn handle_listEdges<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listEdges";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_listEdges = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.listEdges(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::ListEdgesExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::ListEdgesExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listEdges",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.listEdges", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::ListEdgesExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "listEdges",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.addHosts"))]
        async fn handle_addHosts<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.addHosts";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_addHosts = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.addHosts(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::AddHostsExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::AddHostsExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "addHosts",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.addHosts", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::AddHostsExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "addHosts",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.addHostsIntoZone"))]
        async fn handle_addHostsIntoZone<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.addHostsIntoZone";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_addHostsIntoZone = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.addHostsIntoZone(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::AddHostsIntoZoneExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::AddHostsIntoZoneExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "addHostsIntoZone",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.addHostsIntoZone", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::AddHostsIntoZoneExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "addHostsIntoZone",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.dropHosts"))]
        async fn handle_dropHosts<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropHosts";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_dropHosts = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.dropHosts(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::DropHostsExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::DropHostsExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "dropHosts",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.dropHosts", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::DropHostsExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "dropHosts",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.listHosts"))]
        async fn handle_listHosts<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listHosts";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_listHosts = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.listHosts(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::ListHostsExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::ListHostsExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listHosts",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.listHosts", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::ListHostsExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "listHosts",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.getPartsAlloc"))]
        async fn handle_getPartsAlloc<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getPartsAlloc";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_getPartsAlloc = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.getPartsAlloc(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::GetPartsAllocExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::GetPartsAllocExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getPartsAlloc",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.getPartsAlloc", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::GetPartsAllocExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "getPartsAlloc",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.listParts"))]
        async fn handle_listParts<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listParts";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_listParts = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.listParts(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::ListPartsExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::ListPartsExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listParts",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.listParts", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::ListPartsExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "listParts",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.getWorkerId"))]
        async fn handle_getWorkerId<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getWorkerId";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_getWorkerId = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.getWorkerId(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::GetWorkerIdExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::GetWorkerIdExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getWorkerId",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.getWorkerId", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::GetWorkerIdExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "getWorkerId",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.createTagIndex"))]
        async fn handle_createTagIndex<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createTagIndex";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_createTagIndex = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.createTagIndex(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::CreateTagIndexExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::CreateTagIndexExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "createTagIndex",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.createTagIndex", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::CreateTagIndexExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "createTagIndex",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.dropTagIndex"))]
        async fn handle_dropTagIndex<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropTagIndex";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_dropTagIndex = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.dropTagIndex(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::DropTagIndexExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::DropTagIndexExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "dropTagIndex",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.dropTagIndex", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::DropTagIndexExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "dropTagIndex",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.getTagIndex"))]
        async fn handle_getTagIndex<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getTagIndex";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_getTagIndex = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.getTagIndex(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::GetTagIndexExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::GetTagIndexExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getTagIndex",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.getTagIndex", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::GetTagIndexExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "getTagIndex",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.listTagIndexes"))]
        async fn handle_listTagIndexes<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listTagIndexes";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_listTagIndexes = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.listTagIndexes(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::ListTagIndexesExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::ListTagIndexesExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listTagIndexes",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.listTagIndexes", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::ListTagIndexesExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "listTagIndexes",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.rebuildTagIndex"))]
        async fn handle_rebuildTagIndex<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.rebuildTagIndex";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_rebuildTagIndex = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.rebuildTagIndex(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::RebuildTagIndexExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::RebuildTagIndexExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "rebuildTagIndex",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.rebuildTagIndex", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::RebuildTagIndexExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "rebuildTagIndex",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.listTagIndexStatus"))]
        async fn handle_listTagIndexStatus<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listTagIndexStatus";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_listTagIndexStatus = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.listTagIndexStatus(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::ListTagIndexStatusExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::ListTagIndexStatusExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listTagIndexStatus",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.listTagIndexStatus", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::ListTagIndexStatusExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "listTagIndexStatus",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.createEdgeIndex"))]
        async fn handle_createEdgeIndex<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createEdgeIndex";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_createEdgeIndex = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.createEdgeIndex(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::CreateEdgeIndexExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::CreateEdgeIndexExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "createEdgeIndex",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.createEdgeIndex", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::CreateEdgeIndexExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "createEdgeIndex",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.dropEdgeIndex"))]
        async fn handle_dropEdgeIndex<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropEdgeIndex";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_dropEdgeIndex = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.dropEdgeIndex(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::DropEdgeIndexExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::DropEdgeIndexExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "dropEdgeIndex",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.dropEdgeIndex", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::DropEdgeIndexExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "dropEdgeIndex",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.getEdgeIndex"))]
        async fn handle_getEdgeIndex<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getEdgeIndex";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_getEdgeIndex = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.getEdgeIndex(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::GetEdgeIndexExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::GetEdgeIndexExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getEdgeIndex",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.getEdgeIndex", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::GetEdgeIndexExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "getEdgeIndex",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.listEdgeIndexes"))]
        async fn handle_listEdgeIndexes<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listEdgeIndexes";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_listEdgeIndexes = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.listEdgeIndexes(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::ListEdgeIndexesExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::ListEdgeIndexesExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listEdgeIndexes",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.listEdgeIndexes", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::ListEdgeIndexesExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "listEdgeIndexes",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.rebuildEdgeIndex"))]
        async fn handle_rebuildEdgeIndex<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.rebuildEdgeIndex";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_rebuildEdgeIndex = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.rebuildEdgeIndex(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::RebuildEdgeIndexExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::RebuildEdgeIndexExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "rebuildEdgeIndex",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.rebuildEdgeIndex", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::RebuildEdgeIndexExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "rebuildEdgeIndex",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.listEdgeIndexStatus"))]
        async fn handle_listEdgeIndexStatus<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listEdgeIndexStatus";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_listEdgeIndexStatus = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.listEdgeIndexStatus(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::ListEdgeIndexStatusExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::ListEdgeIndexStatusExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listEdgeIndexStatus",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.listEdgeIndexStatus", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::ListEdgeIndexStatusExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "listEdgeIndexStatus",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.createUser"))]
        async fn handle_createUser<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createUser";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_createUser = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.createUser(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::CreateUserExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::CreateUserExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "createUser",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.createUser", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::CreateUserExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "createUser",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.dropUser"))]
        async fn handle_dropUser<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropUser";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_dropUser = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.dropUser(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::DropUserExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::DropUserExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "dropUser",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.dropUser", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::DropUserExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "dropUser",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.alterUser"))]
        async fn handle_alterUser<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.alterUser";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_alterUser = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.alterUser(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::AlterUserExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::AlterUserExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "alterUser",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.alterUser", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::AlterUserExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "alterUser",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.grantRole"))]
        async fn handle_grantRole<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.grantRole";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_grantRole = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.grantRole(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::GrantRoleExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::GrantRoleExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "grantRole",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.grantRole", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::GrantRoleExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "grantRole",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.revokeRole"))]
        async fn handle_revokeRole<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.revokeRole";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_revokeRole = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.revokeRole(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::RevokeRoleExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::RevokeRoleExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "revokeRole",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.revokeRole", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::RevokeRoleExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "revokeRole",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.listUsers"))]
        async fn handle_listUsers<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listUsers";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_listUsers = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.listUsers(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::ListUsersExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::ListUsersExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listUsers",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.listUsers", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::ListUsersExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "listUsers",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.listRoles"))]
        async fn handle_listRoles<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listRoles";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_listRoles = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.listRoles(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::ListRolesExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::ListRolesExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listRoles",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.listRoles", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::ListRolesExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "listRoles",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.getUserRoles"))]
        async fn handle_getUserRoles<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getUserRoles";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_getUserRoles = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.getUserRoles(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::GetUserRolesExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::GetUserRolesExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getUserRoles",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.getUserRoles", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::GetUserRolesExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "getUserRoles",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.changePassword"))]
        async fn handle_changePassword<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.changePassword";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_changePassword = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.changePassword(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::ChangePasswordExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::ChangePasswordExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "changePassword",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.changePassword", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::ChangePasswordExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "changePassword",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.heartBeat"))]
        async fn handle_heartBeat<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.heartBeat";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_heartBeat = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.heartBeat(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::HeartBeatExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::HeartBeatExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "heartBeat",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.heartBeat", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::HeartBeatExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "heartBeat",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.agentHeartbeat"))]
        async fn handle_agentHeartbeat<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.agentHeartbeat";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_agentHeartbeat = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.agentHeartbeat(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::AgentHeartbeatExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::AgentHeartbeatExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "agentHeartbeat",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.agentHeartbeat", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::AgentHeartbeatExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "agentHeartbeat",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.regConfig"))]
        async fn handle_regConfig<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.regConfig";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_regConfig = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.regConfig(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::RegConfigExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::RegConfigExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "regConfig",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.regConfig", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::RegConfigExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "regConfig",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.getConfig"))]
        async fn handle_getConfig<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getConfig";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_getConfig = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.getConfig(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::GetConfigExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::GetConfigExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getConfig",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.getConfig", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::GetConfigExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "getConfig",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.setConfig"))]
        async fn handle_setConfig<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.setConfig";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_setConfig = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.setConfig(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::SetConfigExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::SetConfigExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "setConfig",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.setConfig", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::SetConfigExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "setConfig",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.listConfigs"))]
        async fn handle_listConfigs<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listConfigs";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_listConfigs = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.listConfigs(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::ListConfigsExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::ListConfigsExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listConfigs",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.listConfigs", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::ListConfigsExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "listConfigs",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.createSnapshot"))]
        async fn handle_createSnapshot<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createSnapshot";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_createSnapshot = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.createSnapshot(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::CreateSnapshotExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::CreateSnapshotExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "createSnapshot",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.createSnapshot", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::CreateSnapshotExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "createSnapshot",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.dropSnapshot"))]
        async fn handle_dropSnapshot<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropSnapshot";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_dropSnapshot = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.dropSnapshot(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::DropSnapshotExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::DropSnapshotExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "dropSnapshot",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.dropSnapshot", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::DropSnapshotExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "dropSnapshot",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.listSnapshots"))]
        async fn handle_listSnapshots<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listSnapshots";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_listSnapshots = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.listSnapshots(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::ListSnapshotsExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::ListSnapshotsExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listSnapshots",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.listSnapshots", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::ListSnapshotsExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "listSnapshots",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.runAdminJob"))]
        async fn handle_runAdminJob<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.runAdminJob";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_runAdminJob = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.runAdminJob(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::RunAdminJobExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::RunAdminJobExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "runAdminJob",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.runAdminJob", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::RunAdminJobExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "runAdminJob",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.mergeZone"))]
        async fn handle_mergeZone<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.mergeZone";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_mergeZone = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.mergeZone(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::MergeZoneExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::MergeZoneExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "mergeZone",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.mergeZone", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::MergeZoneExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "mergeZone",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.dropZone"))]
        async fn handle_dropZone<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropZone";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_dropZone = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.dropZone(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::DropZoneExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::DropZoneExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "dropZone",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.dropZone", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::DropZoneExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "dropZone",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.divideZone"))]
        async fn handle_divideZone<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.divideZone";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_divideZone = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.divideZone(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::DivideZoneExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::DivideZoneExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "divideZone",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.divideZone", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::DivideZoneExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "divideZone",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.renameZone"))]
        async fn handle_renameZone<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.renameZone";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_renameZone = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.renameZone(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::RenameZoneExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::RenameZoneExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "renameZone",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.renameZone", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::RenameZoneExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "renameZone",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.getZone"))]
        async fn handle_getZone<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getZone";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_getZone = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.getZone(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::GetZoneExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::GetZoneExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getZone",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.getZone", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::GetZoneExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "getZone",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.listZones"))]
        async fn handle_listZones<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listZones";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_listZones = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.listZones(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::ListZonesExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::ListZonesExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listZones",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.listZones", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::ListZonesExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "listZones",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.addListener"))]
        async fn handle_addListener<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.addListener";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_addListener = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.addListener(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::AddListenerExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::AddListenerExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "addListener",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.addListener", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::AddListenerExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "addListener",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.removeListener"))]
        async fn handle_removeListener<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.removeListener";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_removeListener = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.removeListener(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::RemoveListenerExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::RemoveListenerExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "removeListener",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.removeListener", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::RemoveListenerExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "removeListener",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.listListener"))]
        async fn handle_listListener<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listListener";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_listListener = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.listListener(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::ListListenerExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::ListListenerExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listListener",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.listListener", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::ListListenerExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "listListener",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.getStats"))]
        async fn handle_getStats<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getStats";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_getStats = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.getStats(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::GetStatsExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::GetStatsExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getStats",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.getStats", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::GetStatsExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "getStats",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.signInService"))]
        async fn handle_signInService<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.signInService";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_signInService = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.signInService(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::SignInServiceExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::SignInServiceExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "signInService",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.signInService", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::SignInServiceExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "signInService",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.signOutService"))]
        async fn handle_signOutService<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.signOutService";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_signOutService = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.signOutService(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::SignOutServiceExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::SignOutServiceExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "signOutService",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.signOutService", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::SignOutServiceExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "signOutService",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.listServiceClients"))]
        async fn handle_listServiceClients<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listServiceClients";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_listServiceClients = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.listServiceClients(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::ListServiceClientsExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::ListServiceClientsExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listServiceClients",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.listServiceClients", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::ListServiceClientsExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "listServiceClients",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.createFTIndex"))]
        async fn handle_createFTIndex<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createFTIndex";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_createFTIndex = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.createFTIndex(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::CreateFTIndexExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::CreateFTIndexExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "createFTIndex",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.createFTIndex", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::CreateFTIndexExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "createFTIndex",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.dropFTIndex"))]
        async fn handle_dropFTIndex<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.dropFTIndex";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_dropFTIndex = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.dropFTIndex(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::DropFTIndexExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::DropFTIndexExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "dropFTIndex",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.dropFTIndex", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::DropFTIndexExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "dropFTIndex",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.listFTIndexes"))]
        async fn handle_listFTIndexes<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listFTIndexes";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_listFTIndexes = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.listFTIndexes(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::ListFTIndexesExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::ListFTIndexesExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listFTIndexes",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.listFTIndexes", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::ListFTIndexesExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "listFTIndexes",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.createSession"))]
        async fn handle_createSession<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createSession";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_createSession = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.createSession(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::CreateSessionExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::CreateSessionExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "createSession",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.createSession", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::CreateSessionExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "createSession",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.updateSessions"))]
        async fn handle_updateSessions<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.updateSessions";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_updateSessions = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.updateSessions(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::UpdateSessionsExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::UpdateSessionsExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "updateSessions",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.updateSessions", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::UpdateSessionsExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "updateSessions",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.listSessions"))]
        async fn handle_listSessions<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listSessions";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_listSessions = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.listSessions(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::ListSessionsExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::ListSessionsExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listSessions",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.listSessions", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::ListSessionsExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "listSessions",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.getSession"))]
        async fn handle_getSession<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getSession";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_getSession = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.getSession(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::GetSessionExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::GetSessionExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getSession",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.getSession", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::GetSessionExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "getSession",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.removeSession"))]
        async fn handle_removeSession<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.removeSession";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_removeSession = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.removeSession(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::RemoveSessionExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::RemoveSessionExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "removeSession",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.removeSession", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::RemoveSessionExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "removeSession",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.killQuery"))]
        async fn handle_killQuery<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.killQuery";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_killQuery = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.killQuery(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::KillQueryExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::KillQueryExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "killQuery",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.killQuery", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::KillQueryExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "killQuery",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.reportTaskFinish"))]
        async fn handle_reportTaskFinish<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.reportTaskFinish";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_reportTaskFinish = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.reportTaskFinish(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::ReportTaskFinishExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::ReportTaskFinishExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "reportTaskFinish",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.reportTaskFinish", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::ReportTaskFinishExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "reportTaskFinish",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.createBackup"))]
        async fn handle_createBackup<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.createBackup";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_createBackup = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.createBackup(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::CreateBackupExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::CreateBackupExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "createBackup",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.createBackup", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::CreateBackupExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "createBackup",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.restoreMeta"))]
        async fn handle_restoreMeta<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.restoreMeta";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_restoreMeta = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.restoreMeta(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::RestoreMetaExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::RestoreMetaExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "restoreMeta",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.restoreMeta", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::RestoreMetaExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "restoreMeta",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.listCluster"))]
        async fn handle_listCluster<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.listCluster";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_listCluster = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.listCluster(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::ListClusterExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::ListClusterExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listCluster",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.listCluster", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::ListClusterExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "listCluster",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.getMetaDirInfo"))]
        async fn handle_getMetaDirInfo<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getMetaDirInfo";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_getMetaDirInfo = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.getMetaDirInfo(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::GetMetaDirInfoExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::GetMetaDirInfoExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getMetaDirInfo",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.getMetaDirInfo", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::GetMetaDirInfoExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "getMetaDirInfo",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.verifyClientVersion"))]
        async fn handle_verifyClientVersion<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.verifyClientVersion";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_verifyClientVersion = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.verifyClientVersion(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::VerifyClientVersionExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::VerifyClientVersionExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "verifyClientVersion",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.verifyClientVersion", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::VerifyClientVersionExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "verifyClientVersion",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.saveGraphVersion"))]
        async fn handle_saveGraphVersion<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.saveGraphVersion";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_saveGraphVersion = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.saveGraphVersion(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::SaveGraphVersionExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::SaveGraphVersionExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "saveGraphVersion",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.saveGraphVersion", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::SaveGraphVersionExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "saveGraphVersion",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }

        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MetaService.getSegmentId"))]
        async fn handle_getSegmentId<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::const_cstr::const_cstr;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "MetaService";
                METHOD_NAME = "MetaService.getSegmentId";
            }
            let mut ctx_stack = req_ctxt.get_context_stack(
                SERVICE_NAME.as_cstr(),
                METHOD_NAME.as_cstr(),
            )?;
            crate::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MetaService_getSegmentId = crate::fbthrift::Deserialize::read(p)?;
            crate::fbthrift::ContextStack::on_read_data(&mut ctx_stack, &crate::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME.as_cstr(),
                buffer: ::std::marker::PhantomData, // FIXME P::into_buffer(p).reset(),
            })?;
            crate::fbthrift::ContextStack::post_read(&mut ctx_stack, 0)?;

            let res = ::std::panic::AssertUnwindSafe(
                self.service.getSegmentId(
                    _args.req,
                )
            )
            .catch_unwind()
            .await;

            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::info!("success");
                    crate::fbthrift_protocol::meta::services::meta_service::GetSegmentIdExn::Success(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(crate::fbthrift_protocol::meta::services::meta_service::GetSegmentIdExn::Success(_))) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getSegmentId",
                    )
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(exception = ?exn);
                    exn
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = crate::fbthrift::ApplicationException::handler_panic("MetaService.getSegmentId", exn);
                    crate::fbthrift_protocol::meta::services::meta_service::GetSegmentIdExn::ApplicationException(aexn)
                }
            };

            let env = crate::fbthrift::help::serialize_result_envelope::<P, R, _>(
                "getSegmentId",
                METHOD_NAME.as_cstr(),
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res
            )?;
            reply_state.lock().unwrap().send_reply(env);
            Ok(())
        }
    }

    #[::async_trait::async_trait]
    impl<P, H, R, RS> crate::fbthrift::ServiceProcessor<P> for MetaServiceProcessor<P, H, R, RS>
    where
        P: crate::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Deserializer: ::std::marker::Send,
        H: MetaService,
        P::Frame: ::std::marker::Send + 'static,
        R: crate::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as crate::fbthrift::RequestContext>::ContextStack: crate::fbthrift::ContextStack<Name = R::Name, Buffer = crate::fbthrift::ProtocolDecoded<P>>
            + ::std::marker::Send + ::std::marker::Sync + 'static,
        RS: crate::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static
    {
        type RequestContext = R;
        type ReplyState = RS;

        #[inline]
        fn method_idx(&self, name: &[::std::primitive::u8]) -> ::std::result::Result<::std::primitive::usize, crate::fbthrift::ApplicationException> {
            match name {
                b"createSpace" => ::std::result::Result::Ok(0usize),
                b"dropSpace" => ::std::result::Result::Ok(1usize),
                b"clearSpace" => ::std::result::Result::Ok(2usize),
                b"getSpace" => ::std::result::Result::Ok(3usize),
                b"listSpaces" => ::std::result::Result::Ok(4usize),
                b"alterSpace" => ::std::result::Result::Ok(5usize),
                b"createSpaceAs" => ::std::result::Result::Ok(6usize),
                b"createTag" => ::std::result::Result::Ok(7usize),
                b"alterTag" => ::std::result::Result::Ok(8usize),
                b"dropTag" => ::std::result::Result::Ok(9usize),
                b"getTag" => ::std::result::Result::Ok(10usize),
                b"listTags" => ::std::result::Result::Ok(11usize),
                b"createEdge" => ::std::result::Result::Ok(12usize),
                b"alterEdge" => ::std::result::Result::Ok(13usize),
                b"dropEdge" => ::std::result::Result::Ok(14usize),
                b"getEdge" => ::std::result::Result::Ok(15usize),
                b"listEdges" => ::std::result::Result::Ok(16usize),
                b"addHosts" => ::std::result::Result::Ok(17usize),
                b"addHostsIntoZone" => ::std::result::Result::Ok(18usize),
                b"dropHosts" => ::std::result::Result::Ok(19usize),
                b"listHosts" => ::std::result::Result::Ok(20usize),
                b"getPartsAlloc" => ::std::result::Result::Ok(21usize),
                b"listParts" => ::std::result::Result::Ok(22usize),
                b"getWorkerId" => ::std::result::Result::Ok(23usize),
                b"createTagIndex" => ::std::result::Result::Ok(24usize),
                b"dropTagIndex" => ::std::result::Result::Ok(25usize),
                b"getTagIndex" => ::std::result::Result::Ok(26usize),
                b"listTagIndexes" => ::std::result::Result::Ok(27usize),
                b"rebuildTagIndex" => ::std::result::Result::Ok(28usize),
                b"listTagIndexStatus" => ::std::result::Result::Ok(29usize),
                b"createEdgeIndex" => ::std::result::Result::Ok(30usize),
                b"dropEdgeIndex" => ::std::result::Result::Ok(31usize),
                b"getEdgeIndex" => ::std::result::Result::Ok(32usize),
                b"listEdgeIndexes" => ::std::result::Result::Ok(33usize),
                b"rebuildEdgeIndex" => ::std::result::Result::Ok(34usize),
                b"listEdgeIndexStatus" => ::std::result::Result::Ok(35usize),
                b"createUser" => ::std::result::Result::Ok(36usize),
                b"dropUser" => ::std::result::Result::Ok(37usize),
                b"alterUser" => ::std::result::Result::Ok(38usize),
                b"grantRole" => ::std::result::Result::Ok(39usize),
                b"revokeRole" => ::std::result::Result::Ok(40usize),
                b"listUsers" => ::std::result::Result::Ok(41usize),
                b"listRoles" => ::std::result::Result::Ok(42usize),
                b"getUserRoles" => ::std::result::Result::Ok(43usize),
                b"changePassword" => ::std::result::Result::Ok(44usize),
                b"heartBeat" => ::std::result::Result::Ok(45usize),
                b"agentHeartbeat" => ::std::result::Result::Ok(46usize),
                b"regConfig" => ::std::result::Result::Ok(47usize),
                b"getConfig" => ::std::result::Result::Ok(48usize),
                b"setConfig" => ::std::result::Result::Ok(49usize),
                b"listConfigs" => ::std::result::Result::Ok(50usize),
                b"createSnapshot" => ::std::result::Result::Ok(51usize),
                b"dropSnapshot" => ::std::result::Result::Ok(52usize),
                b"listSnapshots" => ::std::result::Result::Ok(53usize),
                b"runAdminJob" => ::std::result::Result::Ok(54usize),
                b"mergeZone" => ::std::result::Result::Ok(55usize),
                b"dropZone" => ::std::result::Result::Ok(56usize),
                b"divideZone" => ::std::result::Result::Ok(57usize),
                b"renameZone" => ::std::result::Result::Ok(58usize),
                b"getZone" => ::std::result::Result::Ok(59usize),
                b"listZones" => ::std::result::Result::Ok(60usize),
                b"addListener" => ::std::result::Result::Ok(61usize),
                b"removeListener" => ::std::result::Result::Ok(62usize),
                b"listListener" => ::std::result::Result::Ok(63usize),
                b"getStats" => ::std::result::Result::Ok(64usize),
                b"signInService" => ::std::result::Result::Ok(65usize),
                b"signOutService" => ::std::result::Result::Ok(66usize),
                b"listServiceClients" => ::std::result::Result::Ok(67usize),
                b"createFTIndex" => ::std::result::Result::Ok(68usize),
                b"dropFTIndex" => ::std::result::Result::Ok(69usize),
                b"listFTIndexes" => ::std::result::Result::Ok(70usize),
                b"createSession" => ::std::result::Result::Ok(71usize),
                b"updateSessions" => ::std::result::Result::Ok(72usize),
                b"listSessions" => ::std::result::Result::Ok(73usize),
                b"getSession" => ::std::result::Result::Ok(74usize),
                b"removeSession" => ::std::result::Result::Ok(75usize),
                b"killQuery" => ::std::result::Result::Ok(76usize),
                b"reportTaskFinish" => ::std::result::Result::Ok(77usize),
                b"createBackup" => ::std::result::Result::Ok(78usize),
                b"restoreMeta" => ::std::result::Result::Ok(79usize),
                b"listCluster" => ::std::result::Result::Ok(80usize),
                b"getMetaDirInfo" => ::std::result::Result::Ok(81usize),
                b"verifyClientVersion" => ::std::result::Result::Ok(82usize),
                b"saveGraphVersion" => ::std::result::Result::Ok(83usize),
                b"getSegmentId" => ::std::result::Result::Ok(84usize),
                _ => ::std::result::Result::Err(crate::fbthrift::ApplicationException::unknown_method()),
            }
        }

        #[allow(clippy::match_single_binding)]
        async fn handle_method(
            &self,
            idx: ::std::primitive::usize,
            _p: &mut P::Deserializer,
            _r: &R,
            _reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            match idx {
                0usize => {
                    self.handle_createSpace(_p, _r, _reply_state, _seqid).await
                }
                1usize => {
                    self.handle_dropSpace(_p, _r, _reply_state, _seqid).await
                }
                2usize => {
                    self.handle_clearSpace(_p, _r, _reply_state, _seqid).await
                }
                3usize => {
                    self.handle_getSpace(_p, _r, _reply_state, _seqid).await
                }
                4usize => {
                    self.handle_listSpaces(_p, _r, _reply_state, _seqid).await
                }
                5usize => {
                    self.handle_alterSpace(_p, _r, _reply_state, _seqid).await
                }
                6usize => {
                    self.handle_createSpaceAs(_p, _r, _reply_state, _seqid).await
                }
                7usize => {
                    self.handle_createTag(_p, _r, _reply_state, _seqid).await
                }
                8usize => {
                    self.handle_alterTag(_p, _r, _reply_state, _seqid).await
                }
                9usize => {
                    self.handle_dropTag(_p, _r, _reply_state, _seqid).await
                }
                10usize => {
                    self.handle_getTag(_p, _r, _reply_state, _seqid).await
                }
                11usize => {
                    self.handle_listTags(_p, _r, _reply_state, _seqid).await
                }
                12usize => {
                    self.handle_createEdge(_p, _r, _reply_state, _seqid).await
                }
                13usize => {
                    self.handle_alterEdge(_p, _r, _reply_state, _seqid).await
                }
                14usize => {
                    self.handle_dropEdge(_p, _r, _reply_state, _seqid).await
                }
                15usize => {
                    self.handle_getEdge(_p, _r, _reply_state, _seqid).await
                }
                16usize => {
                    self.handle_listEdges(_p, _r, _reply_state, _seqid).await
                }
                17usize => {
                    self.handle_addHosts(_p, _r, _reply_state, _seqid).await
                }
                18usize => {
                    self.handle_addHostsIntoZone(_p, _r, _reply_state, _seqid).await
                }
                19usize => {
                    self.handle_dropHosts(_p, _r, _reply_state, _seqid).await
                }
                20usize => {
                    self.handle_listHosts(_p, _r, _reply_state, _seqid).await
                }
                21usize => {
                    self.handle_getPartsAlloc(_p, _r, _reply_state, _seqid).await
                }
                22usize => {
                    self.handle_listParts(_p, _r, _reply_state, _seqid).await
                }
                23usize => {
                    self.handle_getWorkerId(_p, _r, _reply_state, _seqid).await
                }
                24usize => {
                    self.handle_createTagIndex(_p, _r, _reply_state, _seqid).await
                }
                25usize => {
                    self.handle_dropTagIndex(_p, _r, _reply_state, _seqid).await
                }
                26usize => {
                    self.handle_getTagIndex(_p, _r, _reply_state, _seqid).await
                }
                27usize => {
                    self.handle_listTagIndexes(_p, _r, _reply_state, _seqid).await
                }
                28usize => {
                    self.handle_rebuildTagIndex(_p, _r, _reply_state, _seqid).await
                }
                29usize => {
                    self.handle_listTagIndexStatus(_p, _r, _reply_state, _seqid).await
                }
                30usize => {
                    self.handle_createEdgeIndex(_p, _r, _reply_state, _seqid).await
                }
                31usize => {
                    self.handle_dropEdgeIndex(_p, _r, _reply_state, _seqid).await
                }
                32usize => {
                    self.handle_getEdgeIndex(_p, _r, _reply_state, _seqid).await
                }
                33usize => {
                    self.handle_listEdgeIndexes(_p, _r, _reply_state, _seqid).await
                }
                34usize => {
                    self.handle_rebuildEdgeIndex(_p, _r, _reply_state, _seqid).await
                }
                35usize => {
                    self.handle_listEdgeIndexStatus(_p, _r, _reply_state, _seqid).await
                }
                36usize => {
                    self.handle_createUser(_p, _r, _reply_state, _seqid).await
                }
                37usize => {
                    self.handle_dropUser(_p, _r, _reply_state, _seqid).await
                }
                38usize => {
                    self.handle_alterUser(_p, _r, _reply_state, _seqid).await
                }
                39usize => {
                    self.handle_grantRole(_p, _r, _reply_state, _seqid).await
                }
                40usize => {
                    self.handle_revokeRole(_p, _r, _reply_state, _seqid).await
                }
                41usize => {
                    self.handle_listUsers(_p, _r, _reply_state, _seqid).await
                }
                42usize => {
                    self.handle_listRoles(_p, _r, _reply_state, _seqid).await
                }
                43usize => {
                    self.handle_getUserRoles(_p, _r, _reply_state, _seqid).await
                }
                44usize => {
                    self.handle_changePassword(_p, _r, _reply_state, _seqid).await
                }
                45usize => {
                    self.handle_heartBeat(_p, _r, _reply_state, _seqid).await
                }
                46usize => {
                    self.handle_agentHeartbeat(_p, _r, _reply_state, _seqid).await
                }
                47usize => {
                    self.handle_regConfig(_p, _r, _reply_state, _seqid).await
                }
                48usize => {
                    self.handle_getConfig(_p, _r, _reply_state, _seqid).await
                }
                49usize => {
                    self.handle_setConfig(_p, _r, _reply_state, _seqid).await
                }
                50usize => {
                    self.handle_listConfigs(_p, _r, _reply_state, _seqid).await
                }
                51usize => {
                    self.handle_createSnapshot(_p, _r, _reply_state, _seqid).await
                }
                52usize => {
                    self.handle_dropSnapshot(_p, _r, _reply_state, _seqid).await
                }
                53usize => {
                    self.handle_listSnapshots(_p, _r, _reply_state, _seqid).await
                }
                54usize => {
                    self.handle_runAdminJob(_p, _r, _reply_state, _seqid).await
                }
                55usize => {
                    self.handle_mergeZone(_p, _r, _reply_state, _seqid).await
                }
                56usize => {
                    self.handle_dropZone(_p, _r, _reply_state, _seqid).await
                }
                57usize => {
                    self.handle_divideZone(_p, _r, _reply_state, _seqid).await
                }
                58usize => {
                    self.handle_renameZone(_p, _r, _reply_state, _seqid).await
                }
                59usize => {
                    self.handle_getZone(_p, _r, _reply_state, _seqid).await
                }
                60usize => {
                    self.handle_listZones(_p, _r, _reply_state, _seqid).await
                }
                61usize => {
                    self.handle_addListener(_p, _r, _reply_state, _seqid).await
                }
                62usize => {
                    self.handle_removeListener(_p, _r, _reply_state, _seqid).await
                }
                63usize => {
                    self.handle_listListener(_p, _r, _reply_state, _seqid).await
                }
                64usize => {
                    self.handle_getStats(_p, _r, _reply_state, _seqid).await
                }
                65usize => {
                    self.handle_signInService(_p, _r, _reply_state, _seqid).await
                }
                66usize => {
                    self.handle_signOutService(_p, _r, _reply_state, _seqid).await
                }
                67usize => {
                    self.handle_listServiceClients(_p, _r, _reply_state, _seqid).await
                }
                68usize => {
                    self.handle_createFTIndex(_p, _r, _reply_state, _seqid).await
                }
                69usize => {
                    self.handle_dropFTIndex(_p, _r, _reply_state, _seqid).await
                }
                70usize => {
                    self.handle_listFTIndexes(_p, _r, _reply_state, _seqid).await
                }
                71usize => {
                    self.handle_createSession(_p, _r, _reply_state, _seqid).await
                }
                72usize => {
                    self.handle_updateSessions(_p, _r, _reply_state, _seqid).await
                }
                73usize => {
                    self.handle_listSessions(_p, _r, _reply_state, _seqid).await
                }
                74usize => {
                    self.handle_getSession(_p, _r, _reply_state, _seqid).await
                }
                75usize => {
                    self.handle_removeSession(_p, _r, _reply_state, _seqid).await
                }
                76usize => {
                    self.handle_killQuery(_p, _r, _reply_state, _seqid).await
                }
                77usize => {
                    self.handle_reportTaskFinish(_p, _r, _reply_state, _seqid).await
                }
                78usize => {
                    self.handle_createBackup(_p, _r, _reply_state, _seqid).await
                }
                79usize => {
                    self.handle_restoreMeta(_p, _r, _reply_state, _seqid).await
                }
                80usize => {
                    self.handle_listCluster(_p, _r, _reply_state, _seqid).await
                }
                81usize => {
                    self.handle_getMetaDirInfo(_p, _r, _reply_state, _seqid).await
                }
                82usize => {
                    self.handle_verifyClientVersion(_p, _r, _reply_state, _seqid).await
                }
                83usize => {
                    self.handle_saveGraphVersion(_p, _r, _reply_state, _seqid).await
                }
                84usize => {
                    self.handle_getSegmentId(_p, _r, _reply_state, _seqid).await
                }
                bad => panic!(
                    "{}: unexpected method idx {}",
                    "MetaServiceProcessor",
                    bad
                ),
            }
        }

        #[allow(clippy::match_single_binding)]
        #[inline]
        fn create_interaction_idx(&self, name: &str) -> ::anyhow::Result<::std::primitive::usize> {
            match name {
                _ => ::anyhow::bail!("Unknown interaction"),
            }
        }

        #[allow(clippy::match_single_binding)]
        fn handle_create_interaction(
            &self,
            idx: ::std::primitive::usize,
        ) -> ::anyhow::Result<
            ::std::sync::Arc<dyn crate::fbthrift::ThriftService<P::Frame, Handler = (), RequestContext = Self::RequestContext, ReplyState = Self::ReplyState> + ::std::marker::Send + 'static>
        > {
            match idx {
                bad => panic!(
                    "{}: unexpected method idx {}",
                    "MetaServiceProcessor",
                    bad
                ),
            }
        }
    }

    #[::async_trait::async_trait]
    impl<P, H, R, RS> crate::fbthrift::ThriftService<P::Frame> for MetaServiceProcessor<P, H, R, RS>
    where
        P: crate::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Deserializer: ::std::marker::Send,
        P::Frame: ::std::marker::Send + 'static,
        H: MetaService,
        R: crate::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as crate::fbthrift::RequestContext>::ContextStack: crate::fbthrift::ContextStack<Name = R::Name, Buffer = crate::fbthrift::ProtocolDecoded<P>>
            + ::std::marker::Send + ::std::marker::Sync + 'static,
        RS: crate::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static
    {
        type Handler = H;
        type RequestContext = R;
        type ReplyState = RS;

        #[tracing::instrument(level="trace", skip_all, fields(service = "MetaService"))]
        async fn call(
            &self,
            req: crate::fbthrift::ProtocolDecoded<P>,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
        ) -> ::anyhow::Result<()> {
            use crate::fbthrift::{BufExt as _, ProtocolReader as _, ServiceProcessor as _};
            let mut p = P::deserializer(req);
            let (idx, mty, seqid) = p.read_message_begin(|name| self.method_idx(name))?;
            if mty != crate::fbthrift::MessageType::Call {
                return ::std::result::Result::Err(::std::convert::From::from(crate::fbthrift::ApplicationException::new(
                    crate::fbthrift::ApplicationExceptionErrorCode::InvalidMessageType,
                    format!("message type {:?} not handled", mty)
                )));
            }
            let idx = match idx {
                ::std::result::Result::Ok(idx) => idx,
                ::std::result::Result::Err(_) => {
                    let cur = P::into_buffer(p).reset();
                    return self.supa.call(cur, req_ctxt, reply_state).await;
                }
            };
            self.handle_method(idx, &mut p, req_ctxt, reply_state, seqid).await?;
            p.read_message_end()?;

            Ok(())
        }

        fn create_interaction(
            &self,
            name: &str,
        ) -> ::anyhow::Result<
            ::std::sync::Arc<dyn crate::fbthrift::ThriftService<P::Frame, Handler = (), RequestContext = R, ReplyState = RS> + ::std::marker::Send + 'static>
        > {
            use crate::fbthrift::{ServiceProcessor as _};
            let idx = self.create_interaction_idx(name);
            let idx = match idx {
                ::anyhow::Result::Ok(idx) => idx,
                ::anyhow::Result::Err(_) => {
                    return self.supa.create_interaction(name);
                }
            };
            self.handle_create_interaction(idx)
        }

        fn get_method_names(&self) -> &'static [&'static str] {
            &[
                // from MetaService
                "createSpace",
                "dropSpace",
                "clearSpace",
                "getSpace",
                "listSpaces",
                "alterSpace",
                "createSpaceAs",
                "createTag",
                "alterTag",
                "dropTag",
                "getTag",
                "listTags",
                "createEdge",
                "alterEdge",
                "dropEdge",
                "getEdge",
                "listEdges",
                "addHosts",
                "addHostsIntoZone",
                "dropHosts",
                "listHosts",
                "getPartsAlloc",
                "listParts",
                "getWorkerId",
                "createTagIndex",
                "dropTagIndex",
                "getTagIndex",
                "listTagIndexes",
                "rebuildTagIndex",
                "listTagIndexStatus",
                "createEdgeIndex",
                "dropEdgeIndex",
                "getEdgeIndex",
                "listEdgeIndexes",
                "rebuildEdgeIndex",
                "listEdgeIndexStatus",
                "createUser",
                "dropUser",
                "alterUser",
                "grantRole",
                "revokeRole",
                "listUsers",
                "listRoles",
                "getUserRoles",
                "changePassword",
                "heartBeat",
                "agentHeartbeat",
                "regConfig",
                "getConfig",
                "setConfig",
                "listConfigs",
                "createSnapshot",
                "dropSnapshot",
                "listSnapshots",
                "runAdminJob",
                "mergeZone",
                "dropZone",
                "divideZone",
                "renameZone",
                "getZone",
                "listZones",
                "addListener",
                "removeListener",
                "listListener",
                "getStats",
                "signInService",
                "signOutService",
                "listServiceClients",
                "createFTIndex",
                "dropFTIndex",
                "listFTIndexes",
                "createSession",
                "updateSessions",
                "listSessions",
                "getSession",
                "removeSession",
                "killQuery",
                "reportTaskFinish",
                "createBackup",
                "restoreMeta",
                "listCluster",
                "getMetaDirInfo",
                "verifyClientVersion",
                "saveGraphVersion",
                "getSegmentId",
            ]
        }
    }

    /// Construct a new instance of a MetaService service.
    ///
    /// This is called when a new instance of a Thrift service Processor
    /// is needed for a particular Thrift protocol.
    #[::tracing::instrument(level="debug", skip_all, fields(proto = ?proto))]
    pub fn make_MetaService_server<F, H, R, RS>(
        proto: crate::fbthrift::ProtocolID,
        handler: H,
    ) -> ::std::result::Result<::std::boxed::Box<dyn crate::fbthrift::ThriftService<F, Handler = H, RequestContext = R, ReplyState = RS> + ::std::marker::Send + 'static>, crate::fbthrift::ApplicationException>
    where
        F: crate::fbthrift::Framing + ::std::marker::Send + ::std::marker::Sync + 'static,
        H: MetaService,
        R: crate::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as crate::fbthrift::RequestContext>::ContextStack: crate::fbthrift::ContextStack<Name = R::Name, Buffer = F::DecBuf> + ::std::marker::Send + ::std::marker::Sync + 'static,
        RS: crate::fbthrift::ReplyState<F, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static
    {
        match proto {
            crate::fbthrift::ProtocolID::BinaryProtocol => {
                ::std::result::Result::Ok(::std::boxed::Box::new(MetaServiceProcessor::<crate::fbthrift::BinaryProtocol<F>, H, R, RS>::new(handler)))
            }
            crate::fbthrift::ProtocolID::CompactProtocol => {
                ::std::result::Result::Ok(::std::boxed::Box::new(MetaServiceProcessor::<crate::fbthrift::CompactProtocol<F>, H, R, RS>::new(handler)))
            }
            bad => {
                ::tracing::error!(method = "MetaService.", invalid_protocol = ?bad);
                ::std::result::Result::Err(crate::fbthrift::ApplicationException::invalid_protocol(bad))
            }
        }
    }
}

/// Client mocks. For every service, a struct mock::TheService that implements
/// client::TheService.
///
/// As an example of the generated API, for the following thrift service:
///
/// ```thrift
/// service MyService {
///     FunctionResponse myFunction(
///         1: FunctionRequest request,
///     ) throws {
///         1: StorageException s,
///         2: NotFoundException n,
///     ),
///
///     // other functions
/// }
/// ```
///
/// we would end up with this mock object under crate::mock::MyService:
///
/// ```
/// # const _: &str = stringify! {
/// impl crate::client::MyService for MyService<'mock> {...}
///
/// pub struct MyService<'mock> {
///     pub myFunction: myFunction<'mock>,
///     // ...
/// }
///
/// impl dyn crate::client::MyService {
///     pub fn mock<'mock>() -> MyService<'mock>;
/// }
///
/// impl myFunction<'mock> {
///     // directly return the given success response
///     pub fn ret(&self, value: FunctionResponse);
///
///     // invoke closure to compute success response
///     pub fn mock(
///         &self,
///         mock: impl FnMut(FunctionRequest) -> FunctionResponse + Send + Sync + 'mock,
///     );
///
///     // invoke closure to compute response
///     pub fn mock_result(
///         &self,
///         mock: impl FnMut(FunctionRequest) -> Result<FunctionResponse, crate::fbthrift_protocol::meta::services::MyService::MyFunctionExn> + Send + Sync + 'mock,
///     );
///
///     // return one of the function's declared exceptions
///     pub fn throw<E>(&self, exception: E)
///     where
///         E: Clone + Into<crate::fbthrift_protocol::meta::services::MyService::MyFunctionExn> + Send + Sync + 'mock;
/// }
///
/// impl From<StorageException> for MyFunctionExn {...}
/// impl From<NotFoundException> for MyFunctionExn {...}
/// # };
/// ```
///
/// The intended usage from a test would be:
///
/// ```
/// # const _: &str = stringify! {
/// use std::sync::Arc;
/// use thrift_if::client::MyService;
///
/// #[test]
/// fn test_my_client() {
///     let mock = Arc::new(<dyn MyService>::mock());
///
///     // directly return a success response
///     let resp = FunctionResponse {...};
///     mock.myFunction.ret(resp);
///
///     // or give a closure to compute the success response
///     mock.myFunction.mock(|request| FunctionResponse {...});
///
///     // or throw one of the function's exceptions
///     mock.myFunction.throw(StorageException::ItFailed);
///
///     // or compute a Result (useful if your exceptions aren't Clone)
///     mock.myFunction.mock_result(|request| Err(...));
///
///     let out = do_the_thing(mock).wait().unwrap();
///     assert!(out.what_i_expected());
/// }
///
/// fn do_the_thing(
///     client: Arc<dyn MyService + Send + Sync + 'static>,
/// ) -> impl Future<Item = Out> {...}
/// # };
/// ```
pub mod mock {
    pub struct MetaService<'mock> {
        pub createSpace: r#impl::meta_service::createSpace<'mock>,
        pub dropSpace: r#impl::meta_service::dropSpace<'mock>,
        pub clearSpace: r#impl::meta_service::clearSpace<'mock>,
        pub getSpace: r#impl::meta_service::getSpace<'mock>,
        pub listSpaces: r#impl::meta_service::listSpaces<'mock>,
        pub alterSpace: r#impl::meta_service::alterSpace<'mock>,
        pub createSpaceAs: r#impl::meta_service::createSpaceAs<'mock>,
        pub createTag: r#impl::meta_service::createTag<'mock>,
        pub alterTag: r#impl::meta_service::alterTag<'mock>,
        pub dropTag: r#impl::meta_service::dropTag<'mock>,
        pub getTag: r#impl::meta_service::getTag<'mock>,
        pub listTags: r#impl::meta_service::listTags<'mock>,
        pub createEdge: r#impl::meta_service::createEdge<'mock>,
        pub alterEdge: r#impl::meta_service::alterEdge<'mock>,
        pub dropEdge: r#impl::meta_service::dropEdge<'mock>,
        pub getEdge: r#impl::meta_service::getEdge<'mock>,
        pub listEdges: r#impl::meta_service::listEdges<'mock>,
        pub addHosts: r#impl::meta_service::addHosts<'mock>,
        pub addHostsIntoZone: r#impl::meta_service::addHostsIntoZone<'mock>,
        pub dropHosts: r#impl::meta_service::dropHosts<'mock>,
        pub listHosts: r#impl::meta_service::listHosts<'mock>,
        pub getPartsAlloc: r#impl::meta_service::getPartsAlloc<'mock>,
        pub listParts: r#impl::meta_service::listParts<'mock>,
        pub getWorkerId: r#impl::meta_service::getWorkerId<'mock>,
        pub createTagIndex: r#impl::meta_service::createTagIndex<'mock>,
        pub dropTagIndex: r#impl::meta_service::dropTagIndex<'mock>,
        pub getTagIndex: r#impl::meta_service::getTagIndex<'mock>,
        pub listTagIndexes: r#impl::meta_service::listTagIndexes<'mock>,
        pub rebuildTagIndex: r#impl::meta_service::rebuildTagIndex<'mock>,
        pub listTagIndexStatus: r#impl::meta_service::listTagIndexStatus<'mock>,
        pub createEdgeIndex: r#impl::meta_service::createEdgeIndex<'mock>,
        pub dropEdgeIndex: r#impl::meta_service::dropEdgeIndex<'mock>,
        pub getEdgeIndex: r#impl::meta_service::getEdgeIndex<'mock>,
        pub listEdgeIndexes: r#impl::meta_service::listEdgeIndexes<'mock>,
        pub rebuildEdgeIndex: r#impl::meta_service::rebuildEdgeIndex<'mock>,
        pub listEdgeIndexStatus: r#impl::meta_service::listEdgeIndexStatus<'mock>,
        pub createUser: r#impl::meta_service::createUser<'mock>,
        pub dropUser: r#impl::meta_service::dropUser<'mock>,
        pub alterUser: r#impl::meta_service::alterUser<'mock>,
        pub grantRole: r#impl::meta_service::grantRole<'mock>,
        pub revokeRole: r#impl::meta_service::revokeRole<'mock>,
        pub listUsers: r#impl::meta_service::listUsers<'mock>,
        pub listRoles: r#impl::meta_service::listRoles<'mock>,
        pub getUserRoles: r#impl::meta_service::getUserRoles<'mock>,
        pub changePassword: r#impl::meta_service::changePassword<'mock>,
        pub heartBeat: r#impl::meta_service::heartBeat<'mock>,
        pub agentHeartbeat: r#impl::meta_service::agentHeartbeat<'mock>,
        pub regConfig: r#impl::meta_service::regConfig<'mock>,
        pub getConfig: r#impl::meta_service::getConfig<'mock>,
        pub setConfig: r#impl::meta_service::setConfig<'mock>,
        pub listConfigs: r#impl::meta_service::listConfigs<'mock>,
        pub createSnapshot: r#impl::meta_service::createSnapshot<'mock>,
        pub dropSnapshot: r#impl::meta_service::dropSnapshot<'mock>,
        pub listSnapshots: r#impl::meta_service::listSnapshots<'mock>,
        pub runAdminJob: r#impl::meta_service::runAdminJob<'mock>,
        pub mergeZone: r#impl::meta_service::mergeZone<'mock>,
        pub dropZone: r#impl::meta_service::dropZone<'mock>,
        pub divideZone: r#impl::meta_service::divideZone<'mock>,
        pub renameZone: r#impl::meta_service::renameZone<'mock>,
        pub getZone: r#impl::meta_service::getZone<'mock>,
        pub listZones: r#impl::meta_service::listZones<'mock>,
        pub addListener: r#impl::meta_service::addListener<'mock>,
        pub removeListener: r#impl::meta_service::removeListener<'mock>,
        pub listListener: r#impl::meta_service::listListener<'mock>,
        pub getStats: r#impl::meta_service::getStats<'mock>,
        pub signInService: r#impl::meta_service::signInService<'mock>,
        pub signOutService: r#impl::meta_service::signOutService<'mock>,
        pub listServiceClients: r#impl::meta_service::listServiceClients<'mock>,
        pub createFTIndex: r#impl::meta_service::createFTIndex<'mock>,
        pub dropFTIndex: r#impl::meta_service::dropFTIndex<'mock>,
        pub listFTIndexes: r#impl::meta_service::listFTIndexes<'mock>,
        pub createSession: r#impl::meta_service::createSession<'mock>,
        pub updateSessions: r#impl::meta_service::updateSessions<'mock>,
        pub listSessions: r#impl::meta_service::listSessions<'mock>,
        pub getSession: r#impl::meta_service::getSession<'mock>,
        pub removeSession: r#impl::meta_service::removeSession<'mock>,
        pub killQuery: r#impl::meta_service::killQuery<'mock>,
        pub reportTaskFinish: r#impl::meta_service::reportTaskFinish<'mock>,
        pub createBackup: r#impl::meta_service::createBackup<'mock>,
        pub restoreMeta: r#impl::meta_service::restoreMeta<'mock>,
        pub listCluster: r#impl::meta_service::listCluster<'mock>,
        pub getMetaDirInfo: r#impl::meta_service::getMetaDirInfo<'mock>,
        pub verifyClientVersion: r#impl::meta_service::verifyClientVersion<'mock>,
        pub saveGraphVersion: r#impl::meta_service::saveGraphVersion<'mock>,
        pub getSegmentId: r#impl::meta_service::getSegmentId<'mock>,
        _marker: ::std::marker::PhantomData<&'mock ()>,
    }

    impl dyn super::client::MetaService {
        pub fn mock<'mock>() -> MetaService<'mock> {
            MetaService {
                createSpace: r#impl::meta_service::createSpace::unimplemented(),
                dropSpace: r#impl::meta_service::dropSpace::unimplemented(),
                clearSpace: r#impl::meta_service::clearSpace::unimplemented(),
                getSpace: r#impl::meta_service::getSpace::unimplemented(),
                listSpaces: r#impl::meta_service::listSpaces::unimplemented(),
                alterSpace: r#impl::meta_service::alterSpace::unimplemented(),
                createSpaceAs: r#impl::meta_service::createSpaceAs::unimplemented(),
                createTag: r#impl::meta_service::createTag::unimplemented(),
                alterTag: r#impl::meta_service::alterTag::unimplemented(),
                dropTag: r#impl::meta_service::dropTag::unimplemented(),
                getTag: r#impl::meta_service::getTag::unimplemented(),
                listTags: r#impl::meta_service::listTags::unimplemented(),
                createEdge: r#impl::meta_service::createEdge::unimplemented(),
                alterEdge: r#impl::meta_service::alterEdge::unimplemented(),
                dropEdge: r#impl::meta_service::dropEdge::unimplemented(),
                getEdge: r#impl::meta_service::getEdge::unimplemented(),
                listEdges: r#impl::meta_service::listEdges::unimplemented(),
                addHosts: r#impl::meta_service::addHosts::unimplemented(),
                addHostsIntoZone: r#impl::meta_service::addHostsIntoZone::unimplemented(),
                dropHosts: r#impl::meta_service::dropHosts::unimplemented(),
                listHosts: r#impl::meta_service::listHosts::unimplemented(),
                getPartsAlloc: r#impl::meta_service::getPartsAlloc::unimplemented(),
                listParts: r#impl::meta_service::listParts::unimplemented(),
                getWorkerId: r#impl::meta_service::getWorkerId::unimplemented(),
                createTagIndex: r#impl::meta_service::createTagIndex::unimplemented(),
                dropTagIndex: r#impl::meta_service::dropTagIndex::unimplemented(),
                getTagIndex: r#impl::meta_service::getTagIndex::unimplemented(),
                listTagIndexes: r#impl::meta_service::listTagIndexes::unimplemented(),
                rebuildTagIndex: r#impl::meta_service::rebuildTagIndex::unimplemented(),
                listTagIndexStatus: r#impl::meta_service::listTagIndexStatus::unimplemented(),
                createEdgeIndex: r#impl::meta_service::createEdgeIndex::unimplemented(),
                dropEdgeIndex: r#impl::meta_service::dropEdgeIndex::unimplemented(),
                getEdgeIndex: r#impl::meta_service::getEdgeIndex::unimplemented(),
                listEdgeIndexes: r#impl::meta_service::listEdgeIndexes::unimplemented(),
                rebuildEdgeIndex: r#impl::meta_service::rebuildEdgeIndex::unimplemented(),
                listEdgeIndexStatus: r#impl::meta_service::listEdgeIndexStatus::unimplemented(),
                createUser: r#impl::meta_service::createUser::unimplemented(),
                dropUser: r#impl::meta_service::dropUser::unimplemented(),
                alterUser: r#impl::meta_service::alterUser::unimplemented(),
                grantRole: r#impl::meta_service::grantRole::unimplemented(),
                revokeRole: r#impl::meta_service::revokeRole::unimplemented(),
                listUsers: r#impl::meta_service::listUsers::unimplemented(),
                listRoles: r#impl::meta_service::listRoles::unimplemented(),
                getUserRoles: r#impl::meta_service::getUserRoles::unimplemented(),
                changePassword: r#impl::meta_service::changePassword::unimplemented(),
                heartBeat: r#impl::meta_service::heartBeat::unimplemented(),
                agentHeartbeat: r#impl::meta_service::agentHeartbeat::unimplemented(),
                regConfig: r#impl::meta_service::regConfig::unimplemented(),
                getConfig: r#impl::meta_service::getConfig::unimplemented(),
                setConfig: r#impl::meta_service::setConfig::unimplemented(),
                listConfigs: r#impl::meta_service::listConfigs::unimplemented(),
                createSnapshot: r#impl::meta_service::createSnapshot::unimplemented(),
                dropSnapshot: r#impl::meta_service::dropSnapshot::unimplemented(),
                listSnapshots: r#impl::meta_service::listSnapshots::unimplemented(),
                runAdminJob: r#impl::meta_service::runAdminJob::unimplemented(),
                mergeZone: r#impl::meta_service::mergeZone::unimplemented(),
                dropZone: r#impl::meta_service::dropZone::unimplemented(),
                divideZone: r#impl::meta_service::divideZone::unimplemented(),
                renameZone: r#impl::meta_service::renameZone::unimplemented(),
                getZone: r#impl::meta_service::getZone::unimplemented(),
                listZones: r#impl::meta_service::listZones::unimplemented(),
                addListener: r#impl::meta_service::addListener::unimplemented(),
                removeListener: r#impl::meta_service::removeListener::unimplemented(),
                listListener: r#impl::meta_service::listListener::unimplemented(),
                getStats: r#impl::meta_service::getStats::unimplemented(),
                signInService: r#impl::meta_service::signInService::unimplemented(),
                signOutService: r#impl::meta_service::signOutService::unimplemented(),
                listServiceClients: r#impl::meta_service::listServiceClients::unimplemented(),
                createFTIndex: r#impl::meta_service::createFTIndex::unimplemented(),
                dropFTIndex: r#impl::meta_service::dropFTIndex::unimplemented(),
                listFTIndexes: r#impl::meta_service::listFTIndexes::unimplemented(),
                createSession: r#impl::meta_service::createSession::unimplemented(),
                updateSessions: r#impl::meta_service::updateSessions::unimplemented(),
                listSessions: r#impl::meta_service::listSessions::unimplemented(),
                getSession: r#impl::meta_service::getSession::unimplemented(),
                removeSession: r#impl::meta_service::removeSession::unimplemented(),
                killQuery: r#impl::meta_service::killQuery::unimplemented(),
                reportTaskFinish: r#impl::meta_service::reportTaskFinish::unimplemented(),
                createBackup: r#impl::meta_service::createBackup::unimplemented(),
                restoreMeta: r#impl::meta_service::restoreMeta::unimplemented(),
                listCluster: r#impl::meta_service::listCluster::unimplemented(),
                getMetaDirInfo: r#impl::meta_service::getMetaDirInfo::unimplemented(),
                verifyClientVersion: r#impl::meta_service::verifyClientVersion::unimplemented(),
                saveGraphVersion: r#impl::meta_service::saveGraphVersion::unimplemented(),
                getSegmentId: r#impl::meta_service::getSegmentId::unimplemented(),
                _marker: ::std::marker::PhantomData,
            }
        }
    }

    impl<'mock> super::client::MetaService for MetaService<'mock> {
        fn createSpace(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateSpaceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateSpaceError>> {
            let mut closure = self.createSpace.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::CreateSpaceReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn dropSpace(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropSpaceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropSpaceError>> {
            let mut closure = self.dropSpace.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::DropSpaceReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn clearSpace(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ClearSpaceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::ClearSpaceError>> {
            let mut closure = self.clearSpace.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ClearSpaceReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn getSpace(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetSpaceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetSpaceResp, crate::fbthrift_protocol::meta::errors::meta_service::GetSpaceError>> {
            let mut closure = self.getSpace.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::GetSpaceReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listSpaces(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListSpacesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListSpacesResp, crate::fbthrift_protocol::meta::errors::meta_service::ListSpacesError>> {
            let mut closure = self.listSpaces.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListSpacesReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn alterSpace(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::AlterSpaceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::AlterSpaceError>> {
            let mut closure = self.alterSpace.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::AlterSpaceReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn createSpaceAs(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateSpaceAsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateSpaceAsError>> {
            let mut closure = self.createSpaceAs.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::CreateSpaceAsReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn createTag(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateTagReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateTagError>> {
            let mut closure = self.createTag.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::CreateTagReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn alterTag(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::AlterTagReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::AlterTagError>> {
            let mut closure = self.alterTag.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::AlterTagReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn dropTag(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropTagReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropTagError>> {
            let mut closure = self.dropTag.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::DropTagReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn getTag(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetTagReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetTagResp, crate::fbthrift_protocol::meta::errors::meta_service::GetTagError>> {
            let mut closure = self.getTag.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::GetTagReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listTags(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListTagsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListTagsResp, crate::fbthrift_protocol::meta::errors::meta_service::ListTagsError>> {
            let mut closure = self.listTags.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListTagsReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn createEdge(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateEdgeReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateEdgeError>> {
            let mut closure = self.createEdge.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::CreateEdgeReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn alterEdge(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::AlterEdgeReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::AlterEdgeError>> {
            let mut closure = self.alterEdge.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::AlterEdgeReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn dropEdge(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropEdgeReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropEdgeError>> {
            let mut closure = self.dropEdge.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::DropEdgeReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn getEdge(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetEdgeReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetEdgeResp, crate::fbthrift_protocol::meta::errors::meta_service::GetEdgeError>> {
            let mut closure = self.getEdge.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::GetEdgeReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listEdges(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListEdgesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListEdgesResp, crate::fbthrift_protocol::meta::errors::meta_service::ListEdgesError>> {
            let mut closure = self.listEdges.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListEdgesReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn addHosts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::AddHostsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::AddHostsError>> {
            let mut closure = self.addHosts.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::AddHostsReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn addHostsIntoZone(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::AddHostsIntoZoneReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::AddHostsIntoZoneError>> {
            let mut closure = self.addHostsIntoZone.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::AddHostsIntoZoneReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn dropHosts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropHostsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropHostsError>> {
            let mut closure = self.dropHosts.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::DropHostsReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listHosts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListHostsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListHostsResp, crate::fbthrift_protocol::meta::errors::meta_service::ListHostsError>> {
            let mut closure = self.listHosts.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListHostsReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn getPartsAlloc(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetPartsAllocReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetPartsAllocResp, crate::fbthrift_protocol::meta::errors::meta_service::GetPartsAllocError>> {
            let mut closure = self.getPartsAlloc.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::GetPartsAllocReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listParts(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListPartsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListPartsResp, crate::fbthrift_protocol::meta::errors::meta_service::ListPartsError>> {
            let mut closure = self.listParts.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListPartsReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn getWorkerId(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetWorkerIdReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetWorkerIdResp, crate::fbthrift_protocol::meta::errors::meta_service::GetWorkerIdError>> {
            let mut closure = self.getWorkerId.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::GetWorkerIdReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn createTagIndex(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateTagIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateTagIndexError>> {
            let mut closure = self.createTagIndex.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::CreateTagIndexReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn dropTagIndex(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropTagIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropTagIndexError>> {
            let mut closure = self.dropTagIndex.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::DropTagIndexReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn getTagIndex(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetTagIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetTagIndexResp, crate::fbthrift_protocol::meta::errors::meta_service::GetTagIndexError>> {
            let mut closure = self.getTagIndex.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::GetTagIndexReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listTagIndexes(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListTagIndexesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListTagIndexesResp, crate::fbthrift_protocol::meta::errors::meta_service::ListTagIndexesError>> {
            let mut closure = self.listTagIndexes.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListTagIndexesReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn rebuildTagIndex(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::RebuildIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::RebuildTagIndexError>> {
            let mut closure = self.rebuildTagIndex.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::RebuildIndexReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listTagIndexStatus(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListIndexStatusReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListIndexStatusResp, crate::fbthrift_protocol::meta::errors::meta_service::ListTagIndexStatusError>> {
            let mut closure = self.listTagIndexStatus.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListIndexStatusReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn createEdgeIndex(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateEdgeIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateEdgeIndexError>> {
            let mut closure = self.createEdgeIndex.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::CreateEdgeIndexReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn dropEdgeIndex(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropEdgeIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropEdgeIndexError>> {
            let mut closure = self.dropEdgeIndex.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::DropEdgeIndexReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn getEdgeIndex(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetEdgeIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetEdgeIndexResp, crate::fbthrift_protocol::meta::errors::meta_service::GetEdgeIndexError>> {
            let mut closure = self.getEdgeIndex.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::GetEdgeIndexReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listEdgeIndexes(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListEdgeIndexesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListEdgeIndexesResp, crate::fbthrift_protocol::meta::errors::meta_service::ListEdgeIndexesError>> {
            let mut closure = self.listEdgeIndexes.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListEdgeIndexesReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn rebuildEdgeIndex(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::RebuildIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::RebuildEdgeIndexError>> {
            let mut closure = self.rebuildEdgeIndex.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::RebuildIndexReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listEdgeIndexStatus(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListIndexStatusReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListIndexStatusResp, crate::fbthrift_protocol::meta::errors::meta_service::ListEdgeIndexStatusError>> {
            let mut closure = self.listEdgeIndexStatus.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListIndexStatusReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn createUser(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateUserReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateUserError>> {
            let mut closure = self.createUser.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::CreateUserReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn dropUser(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropUserReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropUserError>> {
            let mut closure = self.dropUser.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::DropUserReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn alterUser(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::AlterUserReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::AlterUserError>> {
            let mut closure = self.alterUser.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::AlterUserReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn grantRole(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GrantRoleReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::GrantRoleError>> {
            let mut closure = self.grantRole.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::GrantRoleReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn revokeRole(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::RevokeRoleReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::RevokeRoleError>> {
            let mut closure = self.revokeRole.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::RevokeRoleReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listUsers(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListUsersReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListUsersResp, crate::fbthrift_protocol::meta::errors::meta_service::ListUsersError>> {
            let mut closure = self.listUsers.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListUsersReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listRoles(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListRolesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListRolesResp, crate::fbthrift_protocol::meta::errors::meta_service::ListRolesError>> {
            let mut closure = self.listRoles.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListRolesReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn getUserRoles(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetUserRolesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListRolesResp, crate::fbthrift_protocol::meta::errors::meta_service::GetUserRolesError>> {
            let mut closure = self.getUserRoles.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::GetUserRolesReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn changePassword(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ChangePasswordReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::ChangePasswordError>> {
            let mut closure = self.changePassword.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ChangePasswordReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn heartBeat(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::HBReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::HBResp, crate::fbthrift_protocol::meta::errors::meta_service::HeartBeatError>> {
            let mut closure = self.heartBeat.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::HBReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn agentHeartbeat(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::AgentHBReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::AgentHBResp, crate::fbthrift_protocol::meta::errors::meta_service::AgentHeartbeatError>> {
            let mut closure = self.agentHeartbeat.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::AgentHBReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn regConfig(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::RegConfigReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::RegConfigError>> {
            let mut closure = self.regConfig.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::RegConfigReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn getConfig(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetConfigReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetConfigResp, crate::fbthrift_protocol::meta::errors::meta_service::GetConfigError>> {
            let mut closure = self.getConfig.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::GetConfigReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn setConfig(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::SetConfigReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::SetConfigError>> {
            let mut closure = self.setConfig.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::SetConfigReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listConfigs(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListConfigsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListConfigsResp, crate::fbthrift_protocol::meta::errors::meta_service::ListConfigsError>> {
            let mut closure = self.listConfigs.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListConfigsReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn createSnapshot(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateSnapshotReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateSnapshotError>> {
            let mut closure = self.createSnapshot.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::CreateSnapshotReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn dropSnapshot(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropSnapshotReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropSnapshotError>> {
            let mut closure = self.dropSnapshot.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::DropSnapshotReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listSnapshots(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListSnapshotsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListSnapshotsResp, crate::fbthrift_protocol::meta::errors::meta_service::ListSnapshotsError>> {
            let mut closure = self.listSnapshots.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListSnapshotsReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn runAdminJob(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::AdminJobReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::AdminJobResp, crate::fbthrift_protocol::meta::errors::meta_service::RunAdminJobError>> {
            let mut closure = self.runAdminJob.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::AdminJobReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn mergeZone(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::MergeZoneReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::MergeZoneError>> {
            let mut closure = self.mergeZone.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::MergeZoneReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn dropZone(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropZoneReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropZoneError>> {
            let mut closure = self.dropZone.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::DropZoneReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn divideZone(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DivideZoneReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DivideZoneError>> {
            let mut closure = self.divideZone.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::DivideZoneReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn renameZone(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::RenameZoneReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::RenameZoneError>> {
            let mut closure = self.renameZone.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::RenameZoneReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn getZone(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetZoneReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetZoneResp, crate::fbthrift_protocol::meta::errors::meta_service::GetZoneError>> {
            let mut closure = self.getZone.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::GetZoneReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listZones(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListZonesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListZonesResp, crate::fbthrift_protocol::meta::errors::meta_service::ListZonesError>> {
            let mut closure = self.listZones.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListZonesReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn addListener(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::AddListenerReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::AddListenerError>> {
            let mut closure = self.addListener.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::AddListenerReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn removeListener(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::RemoveListenerReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::RemoveListenerError>> {
            let mut closure = self.removeListener.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::RemoveListenerReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listListener(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListListenerReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListListenerResp, crate::fbthrift_protocol::meta::errors::meta_service::ListListenerError>> {
            let mut closure = self.listListener.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListListenerReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn getStats(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetStatsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetStatsResp, crate::fbthrift_protocol::meta::errors::meta_service::GetStatsError>> {
            let mut closure = self.getStats.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::GetStatsReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn signInService(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::SignInServiceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::SignInServiceError>> {
            let mut closure = self.signInService.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::SignInServiceReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn signOutService(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::SignOutServiceReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::SignOutServiceError>> {
            let mut closure = self.signOutService.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::SignOutServiceReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listServiceClients(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListServiceClientsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListServiceClientsResp, crate::fbthrift_protocol::meta::errors::meta_service::ListServiceClientsError>> {
            let mut closure = self.listServiceClients.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListServiceClientsReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn createFTIndex(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateFTIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateFTIndexError>> {
            let mut closure = self.createFTIndex.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::CreateFTIndexReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn dropFTIndex(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::DropFTIndexReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropFTIndexError>> {
            let mut closure = self.dropFTIndex.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::DropFTIndexReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listFTIndexes(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListFTIndexesReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListFTIndexesResp, crate::fbthrift_protocol::meta::errors::meta_service::ListFTIndexesError>> {
            let mut closure = self.listFTIndexes.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListFTIndexesReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn createSession(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateSessionReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::CreateSessionResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateSessionError>> {
            let mut closure = self.createSession.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::CreateSessionReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn updateSessions(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::UpdateSessionsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::UpdateSessionsResp, crate::fbthrift_protocol::meta::errors::meta_service::UpdateSessionsError>> {
            let mut closure = self.updateSessions.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::UpdateSessionsReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listSessions(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListSessionsReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListSessionsResp, crate::fbthrift_protocol::meta::errors::meta_service::ListSessionsError>> {
            let mut closure = self.listSessions.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListSessionsReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn getSession(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetSessionReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetSessionResp, crate::fbthrift_protocol::meta::errors::meta_service::GetSessionError>> {
            let mut closure = self.getSession.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::GetSessionReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn removeSession(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::RemoveSessionReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::RemoveSessionError>> {
            let mut closure = self.removeSession.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::RemoveSessionReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn killQuery(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::KillQueryReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::KillQueryError>> {
            let mut closure = self.killQuery.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::KillQueryReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn reportTaskFinish(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ReportTaskReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::ReportTaskFinishError>> {
            let mut closure = self.reportTaskFinish.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ReportTaskReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn createBackup(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::CreateBackupReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::CreateBackupResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateBackupError>> {
            let mut closure = self.createBackup.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::CreateBackupReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn restoreMeta(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::RestoreMetaReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::RestoreMetaResp, crate::fbthrift_protocol::meta::errors::meta_service::RestoreMetaError>> {
            let mut closure = self.restoreMeta.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::RestoreMetaReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn listCluster(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::ListClusterInfoReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::ListClusterInfoResp, crate::fbthrift_protocol::meta::errors::meta_service::ListClusterError>> {
            let mut closure = self.listCluster.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListClusterInfoReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn getMetaDirInfo(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetMetaDirInfoReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetMetaDirInfoResp, crate::fbthrift_protocol::meta::errors::meta_service::GetMetaDirInfoError>> {
            let mut closure = self.getMetaDirInfo.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::GetMetaDirInfoReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn verifyClientVersion(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::VerifyClientVersionReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::VerifyClientVersionResp, crate::fbthrift_protocol::meta::errors::meta_service::VerifyClientVersionError>> {
            let mut closure = self.verifyClientVersion.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::VerifyClientVersionReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn saveGraphVersion(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::SaveGraphVersionReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::SaveGraphVersionResp, crate::fbthrift_protocol::meta::errors::meta_service::SaveGraphVersionError>> {
            let mut closure = self.saveGraphVersion.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::SaveGraphVersionReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
        fn getSegmentId(
            &self,
            arg_req: &crate::fbthrift_protocol::meta::types::GetSegmentIdReq,
        ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<crate::fbthrift_protocol::meta::types::GetSegmentIdResp, crate::fbthrift_protocol::meta::errors::meta_service::GetSegmentIdError>> {
            let mut closure = self.getSegmentId.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::GetSegmentIdReq) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_req.clone())))
        }
    }

    mod r#impl {
        pub mod meta_service {

            pub struct createSpace<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::CreateSpaceReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::ExecResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::CreateSpaceError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> createSpace<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::CreateSpaceReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "createSpace",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::ExecResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::CreateSpaceReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::CreateSpaceReq) -> crate::fbthrift_protocol::meta::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::CreateSpaceReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateSpaceError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::CreateSpaceError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::CreateSpaceReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct dropSpace<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::DropSpaceReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::ExecResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::DropSpaceError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> dropSpace<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::DropSpaceReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "dropSpace",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::ExecResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::DropSpaceReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::DropSpaceReq) -> crate::fbthrift_protocol::meta::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::DropSpaceReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropSpaceError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::DropSpaceError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::DropSpaceReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct clearSpace<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ClearSpaceReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::ExecResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::ClearSpaceError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> clearSpace<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::ClearSpaceReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "clearSpace",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::ExecResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::ClearSpaceReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ClearSpaceReq) -> crate::fbthrift_protocol::meta::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ClearSpaceReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::ClearSpaceError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::ClearSpaceError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::ClearSpaceReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getSpace<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::GetSpaceReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::GetSpaceResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::GetSpaceError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> getSpace<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::GetSpaceReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "getSpace",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::GetSpaceResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::GetSpaceReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::GetSpaceReq) -> crate::fbthrift_protocol::meta::types::GetSpaceResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::GetSpaceReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::GetSpaceResp, crate::fbthrift_protocol::meta::errors::meta_service::GetSpaceError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::GetSpaceError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::GetSpaceReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listSpaces<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListSpacesReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::ListSpacesResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::ListSpacesError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> listSpaces<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::ListSpacesReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listSpaces",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::ListSpacesResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::ListSpacesReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListSpacesReq) -> crate::fbthrift_protocol::meta::types::ListSpacesResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListSpacesReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ListSpacesResp, crate::fbthrift_protocol::meta::errors::meta_service::ListSpacesError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::ListSpacesError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::ListSpacesReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct alterSpace<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::AlterSpaceReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::ExecResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::AlterSpaceError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> alterSpace<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::AlterSpaceReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "alterSpace",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::ExecResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::AlterSpaceReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::AlterSpaceReq) -> crate::fbthrift_protocol::meta::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::AlterSpaceReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::AlterSpaceError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::AlterSpaceError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::AlterSpaceReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct createSpaceAs<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::CreateSpaceAsReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::ExecResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::CreateSpaceAsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> createSpaceAs<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::CreateSpaceAsReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "createSpaceAs",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::ExecResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::CreateSpaceAsReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::CreateSpaceAsReq) -> crate::fbthrift_protocol::meta::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::CreateSpaceAsReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateSpaceAsError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::CreateSpaceAsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::CreateSpaceAsReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct createTag<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::CreateTagReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::ExecResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::CreateTagError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> createTag<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::CreateTagReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "createTag",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::ExecResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::CreateTagReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::CreateTagReq) -> crate::fbthrift_protocol::meta::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::CreateTagReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateTagError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::CreateTagError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::CreateTagReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct alterTag<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::AlterTagReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::ExecResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::AlterTagError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> alterTag<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::AlterTagReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "alterTag",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::ExecResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::AlterTagReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::AlterTagReq) -> crate::fbthrift_protocol::meta::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::AlterTagReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::AlterTagError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::AlterTagError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::AlterTagReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct dropTag<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::DropTagReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::ExecResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::DropTagError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> dropTag<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::DropTagReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "dropTag",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::ExecResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::DropTagReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::DropTagReq) -> crate::fbthrift_protocol::meta::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::DropTagReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropTagError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::DropTagError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::DropTagReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getTag<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::GetTagReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::GetTagResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::GetTagError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> getTag<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::GetTagReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "getTag",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::GetTagResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::GetTagReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::GetTagReq) -> crate::fbthrift_protocol::meta::types::GetTagResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::GetTagReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::GetTagResp, crate::fbthrift_protocol::meta::errors::meta_service::GetTagError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::GetTagError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::GetTagReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listTags<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListTagsReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::ListTagsResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::ListTagsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> listTags<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::ListTagsReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listTags",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::ListTagsResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::ListTagsReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListTagsReq) -> crate::fbthrift_protocol::meta::types::ListTagsResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListTagsReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ListTagsResp, crate::fbthrift_protocol::meta::errors::meta_service::ListTagsError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::ListTagsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::ListTagsReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct createEdge<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::CreateEdgeReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::ExecResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::CreateEdgeError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> createEdge<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::CreateEdgeReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "createEdge",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::ExecResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::CreateEdgeReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::CreateEdgeReq) -> crate::fbthrift_protocol::meta::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::CreateEdgeReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateEdgeError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::CreateEdgeError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::CreateEdgeReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct alterEdge<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::AlterEdgeReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::ExecResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::AlterEdgeError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> alterEdge<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::AlterEdgeReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "alterEdge",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::ExecResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::AlterEdgeReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::AlterEdgeReq) -> crate::fbthrift_protocol::meta::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::AlterEdgeReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::AlterEdgeError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::AlterEdgeError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::AlterEdgeReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct dropEdge<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::DropEdgeReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::ExecResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::DropEdgeError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> dropEdge<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::DropEdgeReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "dropEdge",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::ExecResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::DropEdgeReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::DropEdgeReq) -> crate::fbthrift_protocol::meta::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::DropEdgeReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropEdgeError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::DropEdgeError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::DropEdgeReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getEdge<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::GetEdgeReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::GetEdgeResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::GetEdgeError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> getEdge<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::GetEdgeReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "getEdge",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::GetEdgeResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::GetEdgeReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::GetEdgeReq) -> crate::fbthrift_protocol::meta::types::GetEdgeResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::GetEdgeReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::GetEdgeResp, crate::fbthrift_protocol::meta::errors::meta_service::GetEdgeError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::GetEdgeError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::GetEdgeReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listEdges<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListEdgesReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::ListEdgesResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::ListEdgesError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> listEdges<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::ListEdgesReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listEdges",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::ListEdgesResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::ListEdgesReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListEdgesReq) -> crate::fbthrift_protocol::meta::types::ListEdgesResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListEdgesReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ListEdgesResp, crate::fbthrift_protocol::meta::errors::meta_service::ListEdgesError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::ListEdgesError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::ListEdgesReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct addHosts<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::AddHostsReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::ExecResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::AddHostsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> addHosts<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::AddHostsReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "addHosts",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::ExecResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::AddHostsReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::AddHostsReq) -> crate::fbthrift_protocol::meta::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::AddHostsReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::AddHostsError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::AddHostsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::AddHostsReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct addHostsIntoZone<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::AddHostsIntoZoneReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::ExecResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::AddHostsIntoZoneError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> addHostsIntoZone<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::AddHostsIntoZoneReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "addHostsIntoZone",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::ExecResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::AddHostsIntoZoneReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::AddHostsIntoZoneReq) -> crate::fbthrift_protocol::meta::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::AddHostsIntoZoneReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::AddHostsIntoZoneError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::AddHostsIntoZoneError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::AddHostsIntoZoneReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct dropHosts<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::DropHostsReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::ExecResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::DropHostsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> dropHosts<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::DropHostsReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "dropHosts",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::ExecResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::DropHostsReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::DropHostsReq) -> crate::fbthrift_protocol::meta::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::DropHostsReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropHostsError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::DropHostsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::DropHostsReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listHosts<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListHostsReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::ListHostsResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::ListHostsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> listHosts<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::ListHostsReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listHosts",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::ListHostsResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::ListHostsReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListHostsReq) -> crate::fbthrift_protocol::meta::types::ListHostsResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListHostsReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ListHostsResp, crate::fbthrift_protocol::meta::errors::meta_service::ListHostsError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::ListHostsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::ListHostsReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getPartsAlloc<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::GetPartsAllocReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::GetPartsAllocResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::GetPartsAllocError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> getPartsAlloc<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::GetPartsAllocReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "getPartsAlloc",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::GetPartsAllocResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::GetPartsAllocReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::GetPartsAllocReq) -> crate::fbthrift_protocol::meta::types::GetPartsAllocResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::GetPartsAllocReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::GetPartsAllocResp, crate::fbthrift_protocol::meta::errors::meta_service::GetPartsAllocError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::GetPartsAllocError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::GetPartsAllocReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listParts<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListPartsReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::ListPartsResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::ListPartsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> listParts<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::ListPartsReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listParts",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::ListPartsResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::ListPartsReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListPartsReq) -> crate::fbthrift_protocol::meta::types::ListPartsResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListPartsReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ListPartsResp, crate::fbthrift_protocol::meta::errors::meta_service::ListPartsError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::ListPartsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::ListPartsReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getWorkerId<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::GetWorkerIdReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::GetWorkerIdResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::GetWorkerIdError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> getWorkerId<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::GetWorkerIdReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "getWorkerId",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::GetWorkerIdResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::GetWorkerIdReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::GetWorkerIdReq) -> crate::fbthrift_protocol::meta::types::GetWorkerIdResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::GetWorkerIdReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::GetWorkerIdResp, crate::fbthrift_protocol::meta::errors::meta_service::GetWorkerIdError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::GetWorkerIdError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::GetWorkerIdReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct createTagIndex<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::CreateTagIndexReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::ExecResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::CreateTagIndexError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> createTagIndex<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::CreateTagIndexReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "createTagIndex",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::ExecResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::CreateTagIndexReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::CreateTagIndexReq) -> crate::fbthrift_protocol::meta::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::CreateTagIndexReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateTagIndexError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::CreateTagIndexError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::CreateTagIndexReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct dropTagIndex<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::DropTagIndexReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::ExecResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::DropTagIndexError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> dropTagIndex<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::DropTagIndexReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "dropTagIndex",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::ExecResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::DropTagIndexReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::DropTagIndexReq) -> crate::fbthrift_protocol::meta::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::DropTagIndexReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropTagIndexError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::DropTagIndexError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::DropTagIndexReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getTagIndex<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::GetTagIndexReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::GetTagIndexResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::GetTagIndexError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> getTagIndex<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::GetTagIndexReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "getTagIndex",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::GetTagIndexResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::GetTagIndexReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::GetTagIndexReq) -> crate::fbthrift_protocol::meta::types::GetTagIndexResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::GetTagIndexReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::GetTagIndexResp, crate::fbthrift_protocol::meta::errors::meta_service::GetTagIndexError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::GetTagIndexError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::GetTagIndexReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listTagIndexes<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListTagIndexesReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::ListTagIndexesResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::ListTagIndexesError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> listTagIndexes<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::ListTagIndexesReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listTagIndexes",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::ListTagIndexesResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::ListTagIndexesReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListTagIndexesReq) -> crate::fbthrift_protocol::meta::types::ListTagIndexesResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListTagIndexesReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ListTagIndexesResp, crate::fbthrift_protocol::meta::errors::meta_service::ListTagIndexesError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::ListTagIndexesError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::ListTagIndexesReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct rebuildTagIndex<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::RebuildIndexReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::ExecResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::RebuildTagIndexError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> rebuildTagIndex<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::RebuildIndexReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "rebuildTagIndex",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::ExecResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::RebuildIndexReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::RebuildIndexReq) -> crate::fbthrift_protocol::meta::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::RebuildIndexReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::RebuildTagIndexError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::RebuildTagIndexError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::RebuildIndexReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listTagIndexStatus<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListIndexStatusReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::ListIndexStatusResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::ListTagIndexStatusError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> listTagIndexStatus<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::ListIndexStatusReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listTagIndexStatus",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::ListIndexStatusResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::ListIndexStatusReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListIndexStatusReq) -> crate::fbthrift_protocol::meta::types::ListIndexStatusResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListIndexStatusReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ListIndexStatusResp, crate::fbthrift_protocol::meta::errors::meta_service::ListTagIndexStatusError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::ListTagIndexStatusError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::ListIndexStatusReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct createEdgeIndex<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::CreateEdgeIndexReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::ExecResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::CreateEdgeIndexError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> createEdgeIndex<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::CreateEdgeIndexReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "createEdgeIndex",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::ExecResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::CreateEdgeIndexReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::CreateEdgeIndexReq) -> crate::fbthrift_protocol::meta::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::CreateEdgeIndexReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateEdgeIndexError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::CreateEdgeIndexError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::CreateEdgeIndexReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct dropEdgeIndex<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::DropEdgeIndexReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::ExecResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::DropEdgeIndexError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> dropEdgeIndex<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::DropEdgeIndexReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "dropEdgeIndex",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::ExecResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::DropEdgeIndexReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::DropEdgeIndexReq) -> crate::fbthrift_protocol::meta::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::DropEdgeIndexReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropEdgeIndexError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::DropEdgeIndexError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::DropEdgeIndexReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getEdgeIndex<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::GetEdgeIndexReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::GetEdgeIndexResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::GetEdgeIndexError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> getEdgeIndex<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::GetEdgeIndexReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "getEdgeIndex",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::GetEdgeIndexResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::GetEdgeIndexReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::GetEdgeIndexReq) -> crate::fbthrift_protocol::meta::types::GetEdgeIndexResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::GetEdgeIndexReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::GetEdgeIndexResp, crate::fbthrift_protocol::meta::errors::meta_service::GetEdgeIndexError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::GetEdgeIndexError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::GetEdgeIndexReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listEdgeIndexes<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListEdgeIndexesReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::ListEdgeIndexesResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::ListEdgeIndexesError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> listEdgeIndexes<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::ListEdgeIndexesReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listEdgeIndexes",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::ListEdgeIndexesResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::ListEdgeIndexesReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListEdgeIndexesReq) -> crate::fbthrift_protocol::meta::types::ListEdgeIndexesResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListEdgeIndexesReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ListEdgeIndexesResp, crate::fbthrift_protocol::meta::errors::meta_service::ListEdgeIndexesError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::ListEdgeIndexesError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::ListEdgeIndexesReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct rebuildEdgeIndex<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::RebuildIndexReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::ExecResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::RebuildEdgeIndexError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> rebuildEdgeIndex<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::RebuildIndexReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "rebuildEdgeIndex",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::ExecResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::RebuildIndexReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::RebuildIndexReq) -> crate::fbthrift_protocol::meta::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::RebuildIndexReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::RebuildEdgeIndexError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::RebuildEdgeIndexError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::RebuildIndexReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listEdgeIndexStatus<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListIndexStatusReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::ListIndexStatusResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::ListEdgeIndexStatusError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> listEdgeIndexStatus<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::ListIndexStatusReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listEdgeIndexStatus",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::ListIndexStatusResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::ListIndexStatusReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListIndexStatusReq) -> crate::fbthrift_protocol::meta::types::ListIndexStatusResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListIndexStatusReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ListIndexStatusResp, crate::fbthrift_protocol::meta::errors::meta_service::ListEdgeIndexStatusError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::ListEdgeIndexStatusError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::ListIndexStatusReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct createUser<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::CreateUserReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::ExecResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::CreateUserError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> createUser<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::CreateUserReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "createUser",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::ExecResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::CreateUserReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::CreateUserReq) -> crate::fbthrift_protocol::meta::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::CreateUserReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateUserError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::CreateUserError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::CreateUserReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct dropUser<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::DropUserReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::ExecResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::DropUserError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> dropUser<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::DropUserReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "dropUser",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::ExecResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::DropUserReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::DropUserReq) -> crate::fbthrift_protocol::meta::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::DropUserReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropUserError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::DropUserError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::DropUserReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct alterUser<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::AlterUserReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::ExecResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::AlterUserError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> alterUser<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::AlterUserReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "alterUser",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::ExecResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::AlterUserReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::AlterUserReq) -> crate::fbthrift_protocol::meta::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::AlterUserReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::AlterUserError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::AlterUserError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::AlterUserReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct grantRole<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::GrantRoleReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::ExecResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::GrantRoleError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> grantRole<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::GrantRoleReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "grantRole",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::ExecResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::GrantRoleReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::GrantRoleReq) -> crate::fbthrift_protocol::meta::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::GrantRoleReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::GrantRoleError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::GrantRoleError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::GrantRoleReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct revokeRole<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::RevokeRoleReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::ExecResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::RevokeRoleError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> revokeRole<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::RevokeRoleReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "revokeRole",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::ExecResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::RevokeRoleReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::RevokeRoleReq) -> crate::fbthrift_protocol::meta::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::RevokeRoleReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::RevokeRoleError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::RevokeRoleError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::RevokeRoleReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listUsers<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListUsersReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::ListUsersResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::ListUsersError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> listUsers<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::ListUsersReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listUsers",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::ListUsersResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::ListUsersReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListUsersReq) -> crate::fbthrift_protocol::meta::types::ListUsersResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListUsersReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ListUsersResp, crate::fbthrift_protocol::meta::errors::meta_service::ListUsersError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::ListUsersError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::ListUsersReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listRoles<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListRolesReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::ListRolesResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::ListRolesError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> listRoles<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::ListRolesReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listRoles",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::ListRolesResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::ListRolesReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListRolesReq) -> crate::fbthrift_protocol::meta::types::ListRolesResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListRolesReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ListRolesResp, crate::fbthrift_protocol::meta::errors::meta_service::ListRolesError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::ListRolesError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::ListRolesReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getUserRoles<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::GetUserRolesReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::ListRolesResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::GetUserRolesError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> getUserRoles<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::GetUserRolesReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "getUserRoles",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::ListRolesResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::GetUserRolesReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::GetUserRolesReq) -> crate::fbthrift_protocol::meta::types::ListRolesResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::GetUserRolesReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ListRolesResp, crate::fbthrift_protocol::meta::errors::meta_service::GetUserRolesError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::GetUserRolesError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::GetUserRolesReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct changePassword<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ChangePasswordReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::ExecResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::ChangePasswordError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> changePassword<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::ChangePasswordReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "changePassword",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::ExecResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::ChangePasswordReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ChangePasswordReq) -> crate::fbthrift_protocol::meta::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ChangePasswordReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::ChangePasswordError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::ChangePasswordError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::ChangePasswordReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct heartBeat<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::HBReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::HBResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::HeartBeatError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> heartBeat<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::HBReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "heartBeat",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::HBResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::HBReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::HBReq) -> crate::fbthrift_protocol::meta::types::HBResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::HBReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::HBResp, crate::fbthrift_protocol::meta::errors::meta_service::HeartBeatError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::HeartBeatError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::HBReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct agentHeartbeat<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::AgentHBReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::AgentHBResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::AgentHeartbeatError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> agentHeartbeat<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::AgentHBReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "agentHeartbeat",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::AgentHBResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::AgentHBReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::AgentHBReq) -> crate::fbthrift_protocol::meta::types::AgentHBResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::AgentHBReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::AgentHBResp, crate::fbthrift_protocol::meta::errors::meta_service::AgentHeartbeatError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::AgentHeartbeatError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::AgentHBReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct regConfig<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::RegConfigReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::ExecResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::RegConfigError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> regConfig<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::RegConfigReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "regConfig",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::ExecResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::RegConfigReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::RegConfigReq) -> crate::fbthrift_protocol::meta::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::RegConfigReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::RegConfigError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::RegConfigError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::RegConfigReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getConfig<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::GetConfigReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::GetConfigResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::GetConfigError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> getConfig<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::GetConfigReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "getConfig",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::GetConfigResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::GetConfigReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::GetConfigReq) -> crate::fbthrift_protocol::meta::types::GetConfigResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::GetConfigReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::GetConfigResp, crate::fbthrift_protocol::meta::errors::meta_service::GetConfigError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::GetConfigError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::GetConfigReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct setConfig<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::SetConfigReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::ExecResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::SetConfigError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> setConfig<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::SetConfigReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "setConfig",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::ExecResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::SetConfigReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::SetConfigReq) -> crate::fbthrift_protocol::meta::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::SetConfigReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::SetConfigError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::SetConfigError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::SetConfigReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listConfigs<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListConfigsReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::ListConfigsResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::ListConfigsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> listConfigs<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::ListConfigsReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listConfigs",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::ListConfigsResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::ListConfigsReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListConfigsReq) -> crate::fbthrift_protocol::meta::types::ListConfigsResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListConfigsReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ListConfigsResp, crate::fbthrift_protocol::meta::errors::meta_service::ListConfigsError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::ListConfigsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::ListConfigsReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct createSnapshot<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::CreateSnapshotReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::ExecResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::CreateSnapshotError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> createSnapshot<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::CreateSnapshotReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "createSnapshot",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::ExecResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::CreateSnapshotReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::CreateSnapshotReq) -> crate::fbthrift_protocol::meta::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::CreateSnapshotReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateSnapshotError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::CreateSnapshotError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::CreateSnapshotReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct dropSnapshot<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::DropSnapshotReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::ExecResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::DropSnapshotError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> dropSnapshot<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::DropSnapshotReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "dropSnapshot",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::ExecResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::DropSnapshotReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::DropSnapshotReq) -> crate::fbthrift_protocol::meta::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::DropSnapshotReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropSnapshotError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::DropSnapshotError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::DropSnapshotReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listSnapshots<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListSnapshotsReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::ListSnapshotsResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::ListSnapshotsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> listSnapshots<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::ListSnapshotsReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listSnapshots",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::ListSnapshotsResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::ListSnapshotsReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListSnapshotsReq) -> crate::fbthrift_protocol::meta::types::ListSnapshotsResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListSnapshotsReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ListSnapshotsResp, crate::fbthrift_protocol::meta::errors::meta_service::ListSnapshotsError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::ListSnapshotsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::ListSnapshotsReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct runAdminJob<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::AdminJobReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::AdminJobResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::RunAdminJobError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> runAdminJob<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::AdminJobReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "runAdminJob",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::AdminJobResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::AdminJobReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::AdminJobReq) -> crate::fbthrift_protocol::meta::types::AdminJobResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::AdminJobReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::AdminJobResp, crate::fbthrift_protocol::meta::errors::meta_service::RunAdminJobError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::RunAdminJobError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::AdminJobReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct mergeZone<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::MergeZoneReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::ExecResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::MergeZoneError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> mergeZone<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::MergeZoneReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "mergeZone",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::ExecResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::MergeZoneReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::MergeZoneReq) -> crate::fbthrift_protocol::meta::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::MergeZoneReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::MergeZoneError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::MergeZoneError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::MergeZoneReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct dropZone<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::DropZoneReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::ExecResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::DropZoneError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> dropZone<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::DropZoneReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "dropZone",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::ExecResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::DropZoneReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::DropZoneReq) -> crate::fbthrift_protocol::meta::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::DropZoneReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropZoneError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::DropZoneError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::DropZoneReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct divideZone<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::DivideZoneReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::ExecResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::DivideZoneError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> divideZone<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::DivideZoneReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "divideZone",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::ExecResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::DivideZoneReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::DivideZoneReq) -> crate::fbthrift_protocol::meta::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::DivideZoneReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DivideZoneError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::DivideZoneError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::DivideZoneReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct renameZone<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::RenameZoneReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::ExecResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::RenameZoneError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> renameZone<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::RenameZoneReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "renameZone",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::ExecResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::RenameZoneReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::RenameZoneReq) -> crate::fbthrift_protocol::meta::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::RenameZoneReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::RenameZoneError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::RenameZoneError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::RenameZoneReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getZone<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::GetZoneReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::GetZoneResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::GetZoneError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> getZone<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::GetZoneReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "getZone",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::GetZoneResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::GetZoneReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::GetZoneReq) -> crate::fbthrift_protocol::meta::types::GetZoneResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::GetZoneReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::GetZoneResp, crate::fbthrift_protocol::meta::errors::meta_service::GetZoneError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::GetZoneError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::GetZoneReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listZones<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListZonesReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::ListZonesResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::ListZonesError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> listZones<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::ListZonesReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listZones",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::ListZonesResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::ListZonesReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListZonesReq) -> crate::fbthrift_protocol::meta::types::ListZonesResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListZonesReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ListZonesResp, crate::fbthrift_protocol::meta::errors::meta_service::ListZonesError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::ListZonesError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::ListZonesReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct addListener<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::AddListenerReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::ExecResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::AddListenerError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> addListener<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::AddListenerReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "addListener",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::ExecResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::AddListenerReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::AddListenerReq) -> crate::fbthrift_protocol::meta::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::AddListenerReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::AddListenerError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::AddListenerError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::AddListenerReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct removeListener<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::RemoveListenerReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::ExecResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::RemoveListenerError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> removeListener<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::RemoveListenerReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "removeListener",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::ExecResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::RemoveListenerReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::RemoveListenerReq) -> crate::fbthrift_protocol::meta::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::RemoveListenerReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::RemoveListenerError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::RemoveListenerError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::RemoveListenerReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listListener<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListListenerReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::ListListenerResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::ListListenerError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> listListener<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::ListListenerReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listListener",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::ListListenerResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::ListListenerReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListListenerReq) -> crate::fbthrift_protocol::meta::types::ListListenerResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListListenerReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ListListenerResp, crate::fbthrift_protocol::meta::errors::meta_service::ListListenerError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::ListListenerError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::ListListenerReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getStats<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::GetStatsReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::GetStatsResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::GetStatsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> getStats<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::GetStatsReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "getStats",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::GetStatsResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::GetStatsReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::GetStatsReq) -> crate::fbthrift_protocol::meta::types::GetStatsResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::GetStatsReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::GetStatsResp, crate::fbthrift_protocol::meta::errors::meta_service::GetStatsError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::GetStatsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::GetStatsReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct signInService<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::SignInServiceReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::ExecResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::SignInServiceError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> signInService<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::SignInServiceReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "signInService",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::ExecResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::SignInServiceReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::SignInServiceReq) -> crate::fbthrift_protocol::meta::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::SignInServiceReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::SignInServiceError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::SignInServiceError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::SignInServiceReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct signOutService<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::SignOutServiceReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::ExecResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::SignOutServiceError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> signOutService<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::SignOutServiceReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "signOutService",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::ExecResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::SignOutServiceReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::SignOutServiceReq) -> crate::fbthrift_protocol::meta::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::SignOutServiceReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::SignOutServiceError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::SignOutServiceError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::SignOutServiceReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listServiceClients<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListServiceClientsReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::ListServiceClientsResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::ListServiceClientsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> listServiceClients<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::ListServiceClientsReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listServiceClients",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::ListServiceClientsResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::ListServiceClientsReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListServiceClientsReq) -> crate::fbthrift_protocol::meta::types::ListServiceClientsResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListServiceClientsReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ListServiceClientsResp, crate::fbthrift_protocol::meta::errors::meta_service::ListServiceClientsError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::ListServiceClientsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::ListServiceClientsReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct createFTIndex<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::CreateFTIndexReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::ExecResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::CreateFTIndexError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> createFTIndex<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::CreateFTIndexReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "createFTIndex",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::ExecResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::CreateFTIndexReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::CreateFTIndexReq) -> crate::fbthrift_protocol::meta::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::CreateFTIndexReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateFTIndexError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::CreateFTIndexError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::CreateFTIndexReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct dropFTIndex<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::DropFTIndexReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::ExecResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::DropFTIndexError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> dropFTIndex<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::DropFTIndexReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "dropFTIndex",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::ExecResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::DropFTIndexReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::DropFTIndexReq) -> crate::fbthrift_protocol::meta::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::DropFTIndexReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::DropFTIndexError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::DropFTIndexError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::DropFTIndexReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listFTIndexes<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListFTIndexesReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::ListFTIndexesResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::ListFTIndexesError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> listFTIndexes<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::ListFTIndexesReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listFTIndexes",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::ListFTIndexesResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::ListFTIndexesReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListFTIndexesReq) -> crate::fbthrift_protocol::meta::types::ListFTIndexesResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListFTIndexesReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ListFTIndexesResp, crate::fbthrift_protocol::meta::errors::meta_service::ListFTIndexesError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::ListFTIndexesError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::ListFTIndexesReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct createSession<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::CreateSessionReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::CreateSessionResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::CreateSessionError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> createSession<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::CreateSessionReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "createSession",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::CreateSessionResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::CreateSessionReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::CreateSessionReq) -> crate::fbthrift_protocol::meta::types::CreateSessionResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::CreateSessionReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::CreateSessionResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateSessionError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::CreateSessionError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::CreateSessionReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct updateSessions<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::UpdateSessionsReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::UpdateSessionsResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::UpdateSessionsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> updateSessions<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::UpdateSessionsReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "updateSessions",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::UpdateSessionsResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::UpdateSessionsReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::UpdateSessionsReq) -> crate::fbthrift_protocol::meta::types::UpdateSessionsResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::UpdateSessionsReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::UpdateSessionsResp, crate::fbthrift_protocol::meta::errors::meta_service::UpdateSessionsError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::UpdateSessionsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::UpdateSessionsReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listSessions<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListSessionsReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::ListSessionsResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::ListSessionsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> listSessions<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::ListSessionsReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listSessions",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::ListSessionsResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::ListSessionsReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListSessionsReq) -> crate::fbthrift_protocol::meta::types::ListSessionsResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListSessionsReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ListSessionsResp, crate::fbthrift_protocol::meta::errors::meta_service::ListSessionsError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::ListSessionsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::ListSessionsReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getSession<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::GetSessionReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::GetSessionResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::GetSessionError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> getSession<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::GetSessionReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "getSession",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::GetSessionResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::GetSessionReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::GetSessionReq) -> crate::fbthrift_protocol::meta::types::GetSessionResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::GetSessionReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::GetSessionResp, crate::fbthrift_protocol::meta::errors::meta_service::GetSessionError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::GetSessionError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::GetSessionReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct removeSession<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::RemoveSessionReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::ExecResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::RemoveSessionError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> removeSession<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::RemoveSessionReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "removeSession",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::ExecResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::RemoveSessionReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::RemoveSessionReq) -> crate::fbthrift_protocol::meta::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::RemoveSessionReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::RemoveSessionError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::RemoveSessionError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::RemoveSessionReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct killQuery<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::KillQueryReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::ExecResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::KillQueryError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> killQuery<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::KillQueryReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "killQuery",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::ExecResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::KillQueryReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::KillQueryReq) -> crate::fbthrift_protocol::meta::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::KillQueryReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::KillQueryError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::KillQueryError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::KillQueryReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct reportTaskFinish<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ReportTaskReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::ExecResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::ReportTaskFinishError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> reportTaskFinish<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::ReportTaskReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "reportTaskFinish",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::ExecResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::ReportTaskReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ReportTaskReq) -> crate::fbthrift_protocol::meta::types::ExecResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ReportTaskReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, crate::fbthrift_protocol::meta::errors::meta_service::ReportTaskFinishError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::ReportTaskFinishError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::ReportTaskReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct createBackup<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::CreateBackupReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::CreateBackupResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::CreateBackupError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> createBackup<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::CreateBackupReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "createBackup",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::CreateBackupResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::CreateBackupReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::CreateBackupReq) -> crate::fbthrift_protocol::meta::types::CreateBackupResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::CreateBackupReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::CreateBackupResp, crate::fbthrift_protocol::meta::errors::meta_service::CreateBackupError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::CreateBackupError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::CreateBackupReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct restoreMeta<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::RestoreMetaReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::RestoreMetaResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::RestoreMetaError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> restoreMeta<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::RestoreMetaReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "restoreMeta",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::RestoreMetaResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::RestoreMetaReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::RestoreMetaReq) -> crate::fbthrift_protocol::meta::types::RestoreMetaResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::RestoreMetaReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::RestoreMetaResp, crate::fbthrift_protocol::meta::errors::meta_service::RestoreMetaError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::RestoreMetaError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::RestoreMetaReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct listCluster<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListClusterInfoReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::ListClusterInfoResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::ListClusterError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> listCluster<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::ListClusterInfoReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "listCluster",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::ListClusterInfoResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::ListClusterInfoReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListClusterInfoReq) -> crate::fbthrift_protocol::meta::types::ListClusterInfoResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::ListClusterInfoReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::ListClusterInfoResp, crate::fbthrift_protocol::meta::errors::meta_service::ListClusterError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::ListClusterError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::ListClusterInfoReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getMetaDirInfo<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::GetMetaDirInfoReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::GetMetaDirInfoResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::GetMetaDirInfoError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> getMetaDirInfo<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::GetMetaDirInfoReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "getMetaDirInfo",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::GetMetaDirInfoResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::GetMetaDirInfoReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::GetMetaDirInfoReq) -> crate::fbthrift_protocol::meta::types::GetMetaDirInfoResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::GetMetaDirInfoReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::GetMetaDirInfoResp, crate::fbthrift_protocol::meta::errors::meta_service::GetMetaDirInfoError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::GetMetaDirInfoError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::GetMetaDirInfoReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct verifyClientVersion<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::VerifyClientVersionReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::VerifyClientVersionResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::VerifyClientVersionError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> verifyClientVersion<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::VerifyClientVersionReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "verifyClientVersion",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::VerifyClientVersionResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::VerifyClientVersionReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::VerifyClientVersionReq) -> crate::fbthrift_protocol::meta::types::VerifyClientVersionResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::VerifyClientVersionReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::VerifyClientVersionResp, crate::fbthrift_protocol::meta::errors::meta_service::VerifyClientVersionError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::VerifyClientVersionError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::VerifyClientVersionReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct saveGraphVersion<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::SaveGraphVersionReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::SaveGraphVersionResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::SaveGraphVersionError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> saveGraphVersion<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::SaveGraphVersionReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "saveGraphVersion",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::SaveGraphVersionResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::SaveGraphVersionReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::SaveGraphVersionReq) -> crate::fbthrift_protocol::meta::types::SaveGraphVersionResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::SaveGraphVersionReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::SaveGraphVersionResp, crate::fbthrift_protocol::meta::errors::meta_service::SaveGraphVersionError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::SaveGraphVersionError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::SaveGraphVersionReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getSegmentId<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::GetSegmentIdReq) -> ::std::result::Result<
                        crate::fbthrift_protocol::meta::types::GetSegmentIdResp,
                        crate::fbthrift_protocol::meta::errors::meta_service::GetSegmentIdError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            #[allow(clippy::redundant_closure)]
            impl<'mock> getSegmentId<'mock> {
                pub fn unimplemented() -> Self {
                    Self {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::fbthrift_protocol::meta::types::GetSegmentIdReq| panic!(
                            "{}::{} is not mocked",
                            "MetaService",
                            "getSegmentId",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::fbthrift_protocol::meta::types::GetSegmentIdResp) {
                    self.mock(move |_: crate::fbthrift_protocol::meta::types::GetSegmentIdReq| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::GetSegmentIdReq) -> crate::fbthrift_protocol::meta::types::GetSegmentIdResp + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| ::std::result::Result::Ok(mock(req)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::fbthrift_protocol::meta::types::GetSegmentIdReq) -> ::std::result::Result<crate::fbthrift_protocol::meta::types::GetSegmentIdResp, crate::fbthrift_protocol::meta::errors::meta_service::GetSegmentIdError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |req| mock(req));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::fbthrift_protocol::meta::errors::meta_service::GetSegmentIdError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::fbthrift_protocol::meta::types::GetSegmentIdReq| ::std::result::Result::Err(exception.clone().into()));
                }
            }
        }
    }
}

/// Error return types.
pub mod errors {
    /// Errors for MetaService functions.
    pub mod meta_service {

        pub type CreateSpaceError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::CreateSpaceExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, CreateSpaceError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::CreateSpaceExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::CreateSpaceExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::CreateSpaceExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(CreateSpaceError::ApplicationException(aexn)),
                }
            }
        }

        pub type DropSpaceError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::DropSpaceExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, DropSpaceError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::DropSpaceExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::DropSpaceExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::DropSpaceExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(DropSpaceError::ApplicationException(aexn)),
                }
            }
        }

        pub type ClearSpaceError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::ClearSpaceExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, ClearSpaceError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::ClearSpaceExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::ClearSpaceExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::ClearSpaceExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ClearSpaceError::ApplicationException(aexn)),
                }
            }
        }

        pub type GetSpaceError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::GetSpaceExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::GetSpaceResp, GetSpaceError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::GetSpaceExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::GetSpaceExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::GetSpaceExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetSpaceError::ApplicationException(aexn)),
                }
            }
        }

        pub type ListSpacesError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::ListSpacesExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::ListSpacesResp, ListSpacesError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::ListSpacesExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::ListSpacesExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::ListSpacesExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ListSpacesError::ApplicationException(aexn)),
                }
            }
        }

        pub type AlterSpaceError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::AlterSpaceExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, AlterSpaceError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::AlterSpaceExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::AlterSpaceExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::AlterSpaceExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(AlterSpaceError::ApplicationException(aexn)),
                }
            }
        }

        pub type CreateSpaceAsError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::CreateSpaceAsExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, CreateSpaceAsError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::CreateSpaceAsExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::CreateSpaceAsExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::CreateSpaceAsExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(CreateSpaceAsError::ApplicationException(aexn)),
                }
            }
        }

        pub type CreateTagError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::CreateTagExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, CreateTagError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::CreateTagExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::CreateTagExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::CreateTagExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(CreateTagError::ApplicationException(aexn)),
                }
            }
        }

        pub type AlterTagError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::AlterTagExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, AlterTagError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::AlterTagExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::AlterTagExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::AlterTagExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(AlterTagError::ApplicationException(aexn)),
                }
            }
        }

        pub type DropTagError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::DropTagExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, DropTagError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::DropTagExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::DropTagExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::DropTagExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(DropTagError::ApplicationException(aexn)),
                }
            }
        }

        pub type GetTagError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::GetTagExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::GetTagResp, GetTagError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::GetTagExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::GetTagExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::GetTagExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetTagError::ApplicationException(aexn)),
                }
            }
        }

        pub type ListTagsError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::ListTagsExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::ListTagsResp, ListTagsError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::ListTagsExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::ListTagsExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::ListTagsExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ListTagsError::ApplicationException(aexn)),
                }
            }
        }

        pub type CreateEdgeError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::CreateEdgeExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, CreateEdgeError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::CreateEdgeExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::CreateEdgeExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::CreateEdgeExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(CreateEdgeError::ApplicationException(aexn)),
                }
            }
        }

        pub type AlterEdgeError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::AlterEdgeExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, AlterEdgeError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::AlterEdgeExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::AlterEdgeExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::AlterEdgeExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(AlterEdgeError::ApplicationException(aexn)),
                }
            }
        }

        pub type DropEdgeError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::DropEdgeExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, DropEdgeError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::DropEdgeExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::DropEdgeExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::DropEdgeExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(DropEdgeError::ApplicationException(aexn)),
                }
            }
        }

        pub type GetEdgeError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::GetEdgeExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::GetEdgeResp, GetEdgeError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::GetEdgeExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::GetEdgeExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::GetEdgeExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetEdgeError::ApplicationException(aexn)),
                }
            }
        }

        pub type ListEdgesError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::ListEdgesExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::ListEdgesResp, ListEdgesError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::ListEdgesExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::ListEdgesExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::ListEdgesExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ListEdgesError::ApplicationException(aexn)),
                }
            }
        }

        pub type AddHostsError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::AddHostsExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, AddHostsError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::AddHostsExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::AddHostsExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::AddHostsExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(AddHostsError::ApplicationException(aexn)),
                }
            }
        }

        pub type AddHostsIntoZoneError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::AddHostsIntoZoneExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, AddHostsIntoZoneError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::AddHostsIntoZoneExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::AddHostsIntoZoneExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::AddHostsIntoZoneExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(AddHostsIntoZoneError::ApplicationException(aexn)),
                }
            }
        }

        pub type DropHostsError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::DropHostsExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, DropHostsError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::DropHostsExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::DropHostsExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::DropHostsExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(DropHostsError::ApplicationException(aexn)),
                }
            }
        }

        pub type ListHostsError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::ListHostsExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::ListHostsResp, ListHostsError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::ListHostsExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::ListHostsExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::ListHostsExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ListHostsError::ApplicationException(aexn)),
                }
            }
        }

        pub type GetPartsAllocError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::GetPartsAllocExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::GetPartsAllocResp, GetPartsAllocError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::GetPartsAllocExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::GetPartsAllocExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::GetPartsAllocExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetPartsAllocError::ApplicationException(aexn)),
                }
            }
        }

        pub type ListPartsError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::ListPartsExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::ListPartsResp, ListPartsError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::ListPartsExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::ListPartsExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::ListPartsExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ListPartsError::ApplicationException(aexn)),
                }
            }
        }

        pub type GetWorkerIdError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::GetWorkerIdExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::GetWorkerIdResp, GetWorkerIdError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::GetWorkerIdExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::GetWorkerIdExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::GetWorkerIdExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetWorkerIdError::ApplicationException(aexn)),
                }
            }
        }

        pub type CreateTagIndexError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::CreateTagIndexExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, CreateTagIndexError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::CreateTagIndexExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::CreateTagIndexExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::CreateTagIndexExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(CreateTagIndexError::ApplicationException(aexn)),
                }
            }
        }

        pub type DropTagIndexError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::DropTagIndexExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, DropTagIndexError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::DropTagIndexExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::DropTagIndexExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::DropTagIndexExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(DropTagIndexError::ApplicationException(aexn)),
                }
            }
        }

        pub type GetTagIndexError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::GetTagIndexExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::GetTagIndexResp, GetTagIndexError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::GetTagIndexExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::GetTagIndexExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::GetTagIndexExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetTagIndexError::ApplicationException(aexn)),
                }
            }
        }

        pub type ListTagIndexesError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::ListTagIndexesExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::ListTagIndexesResp, ListTagIndexesError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::ListTagIndexesExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::ListTagIndexesExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::ListTagIndexesExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ListTagIndexesError::ApplicationException(aexn)),
                }
            }
        }

        pub type RebuildTagIndexError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::RebuildTagIndexExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, RebuildTagIndexError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::RebuildTagIndexExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::RebuildTagIndexExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::RebuildTagIndexExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(RebuildTagIndexError::ApplicationException(aexn)),
                }
            }
        }

        pub type ListTagIndexStatusError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::ListTagIndexStatusExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::ListIndexStatusResp, ListTagIndexStatusError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::ListTagIndexStatusExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::ListTagIndexStatusExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::ListTagIndexStatusExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ListTagIndexStatusError::ApplicationException(aexn)),
                }
            }
        }

        pub type CreateEdgeIndexError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::CreateEdgeIndexExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, CreateEdgeIndexError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::CreateEdgeIndexExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::CreateEdgeIndexExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::CreateEdgeIndexExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(CreateEdgeIndexError::ApplicationException(aexn)),
                }
            }
        }

        pub type DropEdgeIndexError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::DropEdgeIndexExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, DropEdgeIndexError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::DropEdgeIndexExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::DropEdgeIndexExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::DropEdgeIndexExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(DropEdgeIndexError::ApplicationException(aexn)),
                }
            }
        }

        pub type GetEdgeIndexError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::GetEdgeIndexExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::GetEdgeIndexResp, GetEdgeIndexError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::GetEdgeIndexExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::GetEdgeIndexExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::GetEdgeIndexExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetEdgeIndexError::ApplicationException(aexn)),
                }
            }
        }

        pub type ListEdgeIndexesError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::ListEdgeIndexesExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::ListEdgeIndexesResp, ListEdgeIndexesError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::ListEdgeIndexesExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::ListEdgeIndexesExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::ListEdgeIndexesExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ListEdgeIndexesError::ApplicationException(aexn)),
                }
            }
        }

        pub type RebuildEdgeIndexError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::RebuildEdgeIndexExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, RebuildEdgeIndexError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::RebuildEdgeIndexExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::RebuildEdgeIndexExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::RebuildEdgeIndexExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(RebuildEdgeIndexError::ApplicationException(aexn)),
                }
            }
        }

        pub type ListEdgeIndexStatusError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::ListEdgeIndexStatusExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::ListIndexStatusResp, ListEdgeIndexStatusError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::ListEdgeIndexStatusExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::ListEdgeIndexStatusExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::ListEdgeIndexStatusExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ListEdgeIndexStatusError::ApplicationException(aexn)),
                }
            }
        }

        pub type CreateUserError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::CreateUserExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, CreateUserError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::CreateUserExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::CreateUserExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::CreateUserExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(CreateUserError::ApplicationException(aexn)),
                }
            }
        }

        pub type DropUserError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::DropUserExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, DropUserError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::DropUserExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::DropUserExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::DropUserExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(DropUserError::ApplicationException(aexn)),
                }
            }
        }

        pub type AlterUserError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::AlterUserExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, AlterUserError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::AlterUserExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::AlterUserExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::AlterUserExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(AlterUserError::ApplicationException(aexn)),
                }
            }
        }

        pub type GrantRoleError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::GrantRoleExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, GrantRoleError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::GrantRoleExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::GrantRoleExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::GrantRoleExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GrantRoleError::ApplicationException(aexn)),
                }
            }
        }

        pub type RevokeRoleError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::RevokeRoleExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, RevokeRoleError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::RevokeRoleExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::RevokeRoleExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::RevokeRoleExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(RevokeRoleError::ApplicationException(aexn)),
                }
            }
        }

        pub type ListUsersError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::ListUsersExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::ListUsersResp, ListUsersError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::ListUsersExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::ListUsersExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::ListUsersExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ListUsersError::ApplicationException(aexn)),
                }
            }
        }

        pub type ListRolesError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::ListRolesExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::ListRolesResp, ListRolesError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::ListRolesExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::ListRolesExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::ListRolesExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ListRolesError::ApplicationException(aexn)),
                }
            }
        }

        pub type GetUserRolesError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::GetUserRolesExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::ListRolesResp, GetUserRolesError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::GetUserRolesExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::GetUserRolesExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::GetUserRolesExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetUserRolesError::ApplicationException(aexn)),
                }
            }
        }

        pub type ChangePasswordError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::ChangePasswordExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, ChangePasswordError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::ChangePasswordExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::ChangePasswordExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::ChangePasswordExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ChangePasswordError::ApplicationException(aexn)),
                }
            }
        }

        pub type HeartBeatError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::HeartBeatExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::HBResp, HeartBeatError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::HeartBeatExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::HeartBeatExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::HeartBeatExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(HeartBeatError::ApplicationException(aexn)),
                }
            }
        }

        pub type AgentHeartbeatError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::AgentHeartbeatExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::AgentHBResp, AgentHeartbeatError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::AgentHeartbeatExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::AgentHeartbeatExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::AgentHeartbeatExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(AgentHeartbeatError::ApplicationException(aexn)),
                }
            }
        }

        pub type RegConfigError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::RegConfigExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, RegConfigError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::RegConfigExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::RegConfigExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::RegConfigExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(RegConfigError::ApplicationException(aexn)),
                }
            }
        }

        pub type GetConfigError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::GetConfigExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::GetConfigResp, GetConfigError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::GetConfigExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::GetConfigExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::GetConfigExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetConfigError::ApplicationException(aexn)),
                }
            }
        }

        pub type SetConfigError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::SetConfigExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, SetConfigError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::SetConfigExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::SetConfigExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::SetConfigExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(SetConfigError::ApplicationException(aexn)),
                }
            }
        }

        pub type ListConfigsError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::ListConfigsExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::ListConfigsResp, ListConfigsError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::ListConfigsExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::ListConfigsExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::ListConfigsExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ListConfigsError::ApplicationException(aexn)),
                }
            }
        }

        pub type CreateSnapshotError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::CreateSnapshotExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, CreateSnapshotError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::CreateSnapshotExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::CreateSnapshotExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::CreateSnapshotExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(CreateSnapshotError::ApplicationException(aexn)),
                }
            }
        }

        pub type DropSnapshotError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::DropSnapshotExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, DropSnapshotError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::DropSnapshotExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::DropSnapshotExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::DropSnapshotExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(DropSnapshotError::ApplicationException(aexn)),
                }
            }
        }

        pub type ListSnapshotsError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::ListSnapshotsExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::ListSnapshotsResp, ListSnapshotsError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::ListSnapshotsExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::ListSnapshotsExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::ListSnapshotsExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ListSnapshotsError::ApplicationException(aexn)),
                }
            }
        }

        pub type RunAdminJobError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::RunAdminJobExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::AdminJobResp, RunAdminJobError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::RunAdminJobExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::RunAdminJobExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::RunAdminJobExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(RunAdminJobError::ApplicationException(aexn)),
                }
            }
        }

        pub type MergeZoneError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::MergeZoneExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, MergeZoneError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::MergeZoneExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::MergeZoneExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::MergeZoneExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(MergeZoneError::ApplicationException(aexn)),
                }
            }
        }

        pub type DropZoneError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::DropZoneExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, DropZoneError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::DropZoneExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::DropZoneExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::DropZoneExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(DropZoneError::ApplicationException(aexn)),
                }
            }
        }

        pub type DivideZoneError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::DivideZoneExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, DivideZoneError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::DivideZoneExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::DivideZoneExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::DivideZoneExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(DivideZoneError::ApplicationException(aexn)),
                }
            }
        }

        pub type RenameZoneError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::RenameZoneExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, RenameZoneError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::RenameZoneExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::RenameZoneExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::RenameZoneExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(RenameZoneError::ApplicationException(aexn)),
                }
            }
        }

        pub type GetZoneError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::GetZoneExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::GetZoneResp, GetZoneError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::GetZoneExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::GetZoneExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::GetZoneExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetZoneError::ApplicationException(aexn)),
                }
            }
        }

        pub type ListZonesError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::ListZonesExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::ListZonesResp, ListZonesError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::ListZonesExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::ListZonesExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::ListZonesExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ListZonesError::ApplicationException(aexn)),
                }
            }
        }

        pub type AddListenerError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::AddListenerExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, AddListenerError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::AddListenerExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::AddListenerExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::AddListenerExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(AddListenerError::ApplicationException(aexn)),
                }
            }
        }

        pub type RemoveListenerError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::RemoveListenerExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, RemoveListenerError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::RemoveListenerExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::RemoveListenerExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::RemoveListenerExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(RemoveListenerError::ApplicationException(aexn)),
                }
            }
        }

        pub type ListListenerError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::ListListenerExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::ListListenerResp, ListListenerError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::ListListenerExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::ListListenerExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::ListListenerExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ListListenerError::ApplicationException(aexn)),
                }
            }
        }

        pub type GetStatsError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::GetStatsExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::GetStatsResp, GetStatsError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::GetStatsExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::GetStatsExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::GetStatsExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetStatsError::ApplicationException(aexn)),
                }
            }
        }

        pub type SignInServiceError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::SignInServiceExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, SignInServiceError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::SignInServiceExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::SignInServiceExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::SignInServiceExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(SignInServiceError::ApplicationException(aexn)),
                }
            }
        }

        pub type SignOutServiceError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::SignOutServiceExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, SignOutServiceError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::SignOutServiceExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::SignOutServiceExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::SignOutServiceExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(SignOutServiceError::ApplicationException(aexn)),
                }
            }
        }

        pub type ListServiceClientsError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::ListServiceClientsExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::ListServiceClientsResp, ListServiceClientsError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::ListServiceClientsExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::ListServiceClientsExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::ListServiceClientsExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ListServiceClientsError::ApplicationException(aexn)),
                }
            }
        }

        pub type CreateFTIndexError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::CreateFTIndexExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, CreateFTIndexError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::CreateFTIndexExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::CreateFTIndexExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::CreateFTIndexExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(CreateFTIndexError::ApplicationException(aexn)),
                }
            }
        }

        pub type DropFTIndexError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::DropFTIndexExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, DropFTIndexError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::DropFTIndexExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::DropFTIndexExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::DropFTIndexExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(DropFTIndexError::ApplicationException(aexn)),
                }
            }
        }

        pub type ListFTIndexesError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::ListFTIndexesExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::ListFTIndexesResp, ListFTIndexesError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::ListFTIndexesExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::ListFTIndexesExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::ListFTIndexesExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ListFTIndexesError::ApplicationException(aexn)),
                }
            }
        }

        pub type CreateSessionError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::CreateSessionExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::CreateSessionResp, CreateSessionError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::CreateSessionExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::CreateSessionExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::CreateSessionExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(CreateSessionError::ApplicationException(aexn)),
                }
            }
        }

        pub type UpdateSessionsError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::UpdateSessionsExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::UpdateSessionsResp, UpdateSessionsError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::UpdateSessionsExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::UpdateSessionsExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::UpdateSessionsExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(UpdateSessionsError::ApplicationException(aexn)),
                }
            }
        }

        pub type ListSessionsError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::ListSessionsExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::ListSessionsResp, ListSessionsError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::ListSessionsExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::ListSessionsExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::ListSessionsExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ListSessionsError::ApplicationException(aexn)),
                }
            }
        }

        pub type GetSessionError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::GetSessionExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::GetSessionResp, GetSessionError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::GetSessionExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::GetSessionExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::GetSessionExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetSessionError::ApplicationException(aexn)),
                }
            }
        }

        pub type RemoveSessionError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::RemoveSessionExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, RemoveSessionError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::RemoveSessionExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::RemoveSessionExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::RemoveSessionExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(RemoveSessionError::ApplicationException(aexn)),
                }
            }
        }

        pub type KillQueryError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::KillQueryExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, KillQueryError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::KillQueryExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::KillQueryExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::KillQueryExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(KillQueryError::ApplicationException(aexn)),
                }
            }
        }

        pub type ReportTaskFinishError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::ReportTaskFinishExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::ExecResp, ReportTaskFinishError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::ReportTaskFinishExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::ReportTaskFinishExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::ReportTaskFinishExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ReportTaskFinishError::ApplicationException(aexn)),
                }
            }
        }

        pub type CreateBackupError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::CreateBackupExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::CreateBackupResp, CreateBackupError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::CreateBackupExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::CreateBackupExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::CreateBackupExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(CreateBackupError::ApplicationException(aexn)),
                }
            }
        }

        pub type RestoreMetaError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::RestoreMetaExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::RestoreMetaResp, RestoreMetaError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::RestoreMetaExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::RestoreMetaExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::RestoreMetaExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(RestoreMetaError::ApplicationException(aexn)),
                }
            }
        }

        pub type ListClusterError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::ListClusterExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::ListClusterInfoResp, ListClusterError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::ListClusterExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::ListClusterExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::ListClusterExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ListClusterError::ApplicationException(aexn)),
                }
            }
        }

        pub type GetMetaDirInfoError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::GetMetaDirInfoExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::GetMetaDirInfoResp, GetMetaDirInfoError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::GetMetaDirInfoExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::GetMetaDirInfoExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::GetMetaDirInfoExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetMetaDirInfoError::ApplicationException(aexn)),
                }
            }
        }

        pub type VerifyClientVersionError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::VerifyClientVersionExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::VerifyClientVersionResp, VerifyClientVersionError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::VerifyClientVersionExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::VerifyClientVersionExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::VerifyClientVersionExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(VerifyClientVersionError::ApplicationException(aexn)),
                }
            }
        }

        pub type SaveGraphVersionError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::SaveGraphVersionExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::SaveGraphVersionResp, SaveGraphVersionError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::SaveGraphVersionExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::SaveGraphVersionExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::SaveGraphVersionExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(SaveGraphVersionError::ApplicationException(aexn)),
                }
            }
        }

        pub type GetSegmentIdError = crate::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::fbthrift_protocol::meta::services::meta_service::GetSegmentIdExn> for
            ::std::result::Result<crate::fbthrift_protocol::meta::types::GetSegmentIdResp, GetSegmentIdError>
        {
            fn from(e: crate::fbthrift_protocol::meta::services::meta_service::GetSegmentIdExn) -> Self {
                match e {
                    crate::fbthrift_protocol::meta::services::meta_service::GetSegmentIdExn::Success(res) => {
                        ::std::result::Result::Ok(res)
                    }
                    crate::fbthrift_protocol::meta::services::meta_service::GetSegmentIdExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetSegmentIdError::ApplicationException(aexn)),
                }
            }
        }

    }

}
